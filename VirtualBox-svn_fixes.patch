diff -urN VirtualBox-2.0.0/include/iprt/asm.h vbox/include/iprt/asm.h
--- VirtualBox-2.0.0/include/iprt/asm.h	2008-09-08 10:06:11.000000000 +0200
+++ vbox/include/iprt/asm.h	2008-09-08 10:06:52.000000000 +0200
@@ -1728,6 +1728,318 @@
 }
 #endif
 
+/**
+ * Gets dr0.
+ *
+ * @returns dr0.
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(RTCCUINTREG) ASMGetDR0(void);
+#else
+DECLINLINE(RTCCUINTREG) ASMGetDR0(void)
+{
+    RTCCUINTREG uDR0;
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %%dr0, %0\n\t" : "=r" (uDR0));
+#  else
+    __asm__ __volatile__("movl   %%dr0, %0\n\t" : "=r" (uDR0));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     rax, dr0
+        mov     [uDR0], rax
+#  else
+        mov     eax, dr0
+        mov     [uDR0], eax
+#  endif
+    }
+# endif
+    return uDR0;
+}
+#endif
+
+
+/**
+ * Gets dr1.
+ *
+ * @returns dr1.
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(RTCCUINTREG) ASMGetDR1(void);
+#else
+DECLINLINE(RTCCUINTREG) ASMGetDR1(void)
+{
+    RTCCUINTREG uDR1;
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %%dr1, %0\n\t" : "=r" (uDR1));
+#  else
+    __asm__ __volatile__("movl   %%dr1, %0\n\t" : "=r" (uDR1));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     rax, dr1
+        mov     [uDR1], rax
+#  else
+        mov     eax, dr1
+        mov     [uDR1], eax
+#  endif
+    }
+# endif
+    return uDR1;
+}
+#endif
+
+/**
+ * Gets dr2.
+ *
+ * @returns dr2.
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(RTCCUINTREG) ASMGetDR2(void);
+#else
+DECLINLINE(RTCCUINTREG) ASMGetDR2(void)
+{
+    RTCCUINTREG uDR2;
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %%dr2, %0\n\t" : "=r" (uDR2));
+#  else
+    __asm__ __volatile__("movl   %%dr2, %0\n\t" : "=r" (uDR2));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     rax, dr2
+        mov     [uDR2], rax
+#  else
+        mov     eax, dr2
+        mov     [uDR2], eax
+#  endif
+    }
+# endif
+    return uDR2;
+}
+#endif
+
+/**
+ * Gets dr3.
+ *
+ * @returns dr3.
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(RTCCUINTREG) ASMGetDR3(void);
+#else
+DECLINLINE(RTCCUINTREG) ASMGetDR3(void)
+{
+    RTCCUINTREG uDR3;
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %%dr3, %0\n\t" : "=r" (uDR3));
+#  else
+    __asm__ __volatile__("movl   %%dr3, %0\n\t" : "=r" (uDR3));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     rax, dr3
+        mov     [uDR3], rax
+#  else
+        mov     eax, dr3
+        mov     [uDR3], eax
+#  endif
+    }
+# endif
+    return uDR3;
+}
+#endif
+
+/**
+ * Sets dr0.
+ *
+ * @param   uDRVal   Debug register value to write
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(void) ASMSetDR0(RTCCUINTREG uDRVal);
+#else
+DECLINLINE(void) ASMSetDR0(RTCCUINTREG uDRVal)
+{
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %0, %%dr0\n\t" : "=r" (uDRVal));
+#  else
+    __asm__ __volatile__("movl   %0, %%dr0\n\t" : "=r" (uDRVal));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     dr0, [uDRVal]
+#  else
+        mov     eax, [uDRVal]
+        mov     dr0, eax
+#  endif
+    }
+# endif
+}
+#endif
+
+/**
+ * Sets dr1.
+ *
+ * @param   uDRVal   Debug register value to write
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(void) ASMSetDR1(RTCCUINTREG uDRVal);
+#else
+DECLINLINE(void) ASMSetDR1(RTCCUINTREG uDRVal)
+{
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %0, %%dr1\n\t" : "=r" (uDRVal));
+#  else
+    __asm__ __volatile__("movl   %0, %%dr1\n\t" : "=r" (uDRVal));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     dr1, [uDRVal]
+#  else
+        mov     eax, [uDRVal]
+        mov     dr1, eax
+#  endif
+    }
+# endif
+}
+#endif
+
+/**
+ * Sets dr2.
+ *
+ * @param   uDRVal   Debug register value to write
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(void) ASMSetDR2(RTCCUINTREG uDRVal);
+#else
+DECLINLINE(void) ASMSetDR2(RTCCUINTREG uDRVal)
+{
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %0, %%dr2\n\t" : "=r" (uDRVal));
+#  else
+    __asm__ __volatile__("movl   %0, %%dr2\n\t" : "=r" (uDRVal));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     dr2, [uDRVal]
+#  else
+        mov     eax, [uDRVal]
+        mov     dr2, eax
+#  endif
+    }
+# endif
+}
+#endif
+
+/**
+ * Sets dr3.
+ *
+ * @param   uDRVal   Debug register value to write
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(void) ASMSetDR3(RTCCUINTREG uDRVal);
+#else
+DECLINLINE(void) ASMSetDR3(RTCCUINTREG uDRVal)
+{
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %0, %%dr3\n\t" : "=r" (uDRVal));
+#  else
+    __asm__ __volatile__("movl   %0, %%dr3\n\t" : "=r" (uDRVal));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     dr3, [uDRVal]
+#  else
+        mov     eax, [uDRVal]
+        mov     dr3, eax
+#  endif
+    }
+# endif
+}
+#endif
+
+/**
+ * Sets dr6.
+ *
+ * @param   uDRVal   Debug register value to write
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(void) ASMSetDR6(RTCCUINTREG uDRVal);
+#else
+DECLINLINE(void) ASMSetDR6(RTCCUINTREG uDRVal)
+{
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %0, %%dr6\n\t" : "=r" (uDRVal));
+#  else
+    __asm__ __volatile__("movl   %0, %%dr6\n\t" : "=r" (uDRVal));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     dr6, [uDRVal]
+#  else
+        mov     eax, [uDRVal]
+        mov     dr6, eax
+#  endif
+    }
+# endif
+}
+#endif
+
+/**
+ * Sets dr7.
+ *
+ * @param   uDRVal   Debug register value to write
+ */
+#if RT_INLINE_ASM_EXTERNAL
+DECLASM(void) ASMSetDR7(RTCCUINTREG uDRVal);
+#else
+DECLINLINE(void) ASMSetDR7(RTCCUINTREG uDRVal)
+{
+# if RT_INLINE_ASM_GNU_STYLE
+#  ifdef RT_ARCH_AMD64
+    __asm__ __volatile__("movq   %0, %%dr7\n\t" : "=r" (uDRVal));
+#  else
+    __asm__ __volatile__("movl   %0, %%dr7\n\t" : "=r" (uDRVal));
+#  endif
+# else
+    __asm
+    {
+#  ifdef RT_ARCH_AMD64
+        mov     dr7, [uDRVal]
+#  else
+        mov     eax, [uDRVal]
+        mov     dr7, eax
+#  endif
+    }
+# endif
+}
+#endif
 
 /**
  * Compiler memory barrier.
diff -urN VirtualBox-2.0.0/include/iprt/log.h vbox/include/iprt/log.h
--- VirtualBox-2.0.0/include/iprt/log.h	2008-09-08 10:06:10.000000000 +0200
+++ vbox/include/iprt/log.h	2008-09-08 10:06:52.000000000 +0200
@@ -799,10 +799,11 @@
 /** @def LogIt
  * Write to specific logger if group enabled.
  */
-#if defined(LOG_USE_C99)
-# define _LogRelRemoveParentheseis(...)                __VA_ARGS__
-#  define _LogRelIt(pvInst, fFlags, iGroup, ...)       RTLogLoggerEx((PRTLOGGER)pvInst, fFlags, iGroup, __VA_ARGS__)
-#  define LogRelIt(pvInst, fFlags, iGroup, fmtargs) \
+#ifndef IN_RING0 /* causes problems in ring 0; do not enable before tracking this down (see 3137 & 3144) */
+# if defined(LOG_USE_C99)
+#  define _LogRelRemoveParentheseis(...)                __VA_ARGS__
+#   define _LogRelIt(pvInst, fFlags, iGroup, ...)       RTLogLoggerEx((PRTLOGGER)pvInst, fFlags, iGroup, __VA_ARGS__)
+#   define LogRelIt(pvInst, fFlags, iGroup, fmtargs) \
     do \
     { \
         PRTLOGGER LogRelIt_pLogger = (PRTLOGGER)(pvInst) ? (PRTLOGGER)(pvInst) : RTLogRelDefaultInstance(); \
@@ -810,8 +811,8 @@
             _LogRelIt(LogRelIt_pLogger, fFlags, iGroup, _LogRelRemoveParentheseis fmtargs); \
         LogIt(LOG_INSTANCE, fFlags, iGroup, fmtargs); \
     } while (0)
-#else
-# define LogRelIt(pvInst, fFlags, iGroup, fmtargs) \
+# else
+#  define LogRelIt(pvInst, fFlags, iGroup, fmtargs) \
    do \
    { \
        PRTLOGGER LogRelIt_pLogger = (PRTLOGGER)(pvInst) ? (PRTLOGGER)(pvInst) : RTLogRelDefaultInstance(); \
@@ -823,9 +824,15 @@
        } \
        LogIt(LOG_INSTANCE, fFlags, iGroup, fmtargs); \
   } while (0)
+# endif
+#else
+# define LogRelIt(pvInst, fFlags, iGroup, fmtargs)         do { } while (0)
+# if defined(LOG_USE_C99)
+#  define _LogRelRemoveParentheseis(...)                __VA_ARGS__
+#  define _LogRelIt(pvInst, fFlags, iGroup, ...)           do { } while (0)
+# endif
 #endif
 
-
 /** @def LogRel
  * Level 1 logging.
  */
diff -urN VirtualBox-2.0.0/include/iprt/mp.h vbox/include/iprt/mp.h
--- VirtualBox-2.0.0/include/iprt/mp.h	2008-09-08 10:06:10.000000000 +0200
+++ vbox/include/iprt/mp.h	2008-09-08 10:06:52.000000000 +0200
@@ -83,6 +83,7 @@
  */
 RTDECL(RTCPUID) RTMpGetMaxCpuId(void);
 
+
 /**
  * Checks if a CPU exists in the system or may possibly be hotplugged later.
  *
@@ -108,6 +109,7 @@
  */
 RTDECL(RTCPUID) RTMpGetCount(void);
 
+
 /**
  * Gets set of the CPUs present that are currently online.
  *
@@ -131,6 +133,31 @@
  */
 RTDECL(bool) RTMpIsCpuOnline(RTCPUID idCpu);
 
+
+/**
+ * Gets set of the CPUs present in the system.
+ *
+ * @returns pSet.
+ * @param   pSet    Where to put the set.
+ */
+RTDECL(PRTCPUSET) RTMpGetPresentSet(PRTCPUSET pSet);
+
+/**
+ * Get the count of CPUs that are present in the system.
+ *
+ * @return The count.
+ */
+RTDECL(RTCPUID) RTMpGetPresentCount(void);
+
+/**
+ * Checks if a CPU is present in the system.
+ *
+ * @returns true/false accordingly.
+ * @param   idCpu       The identifier of the CPU.
+ */
+RTDECL(bool) RTMpIsCpuPresent(RTCPUID idCpu);
+
+
 /**
  * Get the current frequency of a CPU.
  *
diff -urN VirtualBox-2.0.0/include/VBox/err.h vbox/include/VBox/err.h
--- VirtualBox-2.0.0/include/VBox/err.h	2008-09-08 10:06:11.000000000 +0200
+++ vbox/include/VBox/err.h	2008-09-08 10:06:52.000000000 +0200
@@ -1213,6 +1213,14 @@
 #define VERR_VMX_X86_CR4_VMXE_CLEARED               (-4012)
 /** VT-x features locked or unavailable in MSR. */
 #define VERR_VMX_MSR_LOCKED_OR_DISABLED             (-4013)
+/** Unable to switch due to invalid guest state. */
+#define VERR_VMX_INVALID_GUEST_STATE                (-4014)
+/** Unexpected VM exit code. */
+#define VERR_VMX_UNEXPECTED_EXIT_CODE               (-4015)
+/** Unexpected VM exception code. */
+#define VERR_VMX_UNEXPECTED_EXCEPTION               (-4016)
+/** Unexpected interruption exit code. */
+#define VERR_VMX_UNEXPECTED_INTERRUPTION_EXIT_CODE  (-4017)
 /** @} */
 
 
diff -urN VirtualBox-2.0.0/include/VBox/x86.h vbox/include/VBox/x86.h
--- VirtualBox-2.0.0/include/VBox/x86.h	2008-09-08 10:06:11.000000000 +0200
+++ vbox/include/VBox/x86.h	2008-09-08 10:06:53.000000000 +0200
@@ -624,6 +624,8 @@
 #define X86_DR6_BS                          RT_BIT(14)
 /** Bit 15 - BT - Task switch. (TSS T bit.) */
 #define X86_DR6_BT                          RT_BIT(15)
+/** Value of DR6 after powerup/reset. */
+#define X86_DR6_INIT_VAL                    UINT64_C(0xFFFF0FF0)
 /** @} */
 
 
@@ -716,7 +718,7 @@
 #define X86_DR7_LEN(iBp, cb)                ( (cb) << ((iBp) * 4 + 18) )
 
 /** Mask used to check if any breakpoints are enabled. */
-#define X86_DR7_ENABLED_MASK                (RT_BIT(0) | RT_BIT(1) | RT_BIT(2) | RT_BIT(3) | RT_BIT(4) | RT_BIT(5) | RT_BIT(6) | RT_BIT(7))
+#define X86_DR7_ENABLED_MASK                (RT_BIT(0) | RT_BIT(1) | RT_BIT(2) | RT_BIT(3) | RT_BIT(4) | RT_BIT(5) | RT_BIT(6) | RT_BIT(7)) | X86_DR7_GD
 
 /** @} */
 
diff -urN VirtualBox-2.0.0/kBuild/envwin.cmd vbox/kBuild/envwin.cmd
--- VirtualBox-2.0.0/kBuild/envwin.cmd	2008-09-08 10:06:35.000000000 +0200
+++ vbox/kBuild/envwin.cmd	2008-09-08 10:07:24.000000000 +0200
@@ -234,9 +234,9 @@
 echo       Force AMD64 64-bit windows target platform.
 echo   --nt
 echo       Force NT target and host platform.
-echo   --win32
+echo   --nt32
 echo       Force x86 32-bit NT target platform.
-echo   --win64
+echo   --nt64
 echo       Force AMD64 64-bit NT target platform.
 echo   --debug, --release, --profile
 echo       Alternative way of specifying KBUILD_TYPE.
diff -urN VirtualBox-2.0.0/kBuild/footer.kmk vbox/kBuild/footer.kmk
--- VirtualBox-2.0.0/kBuild/footer.kmk	2008-09-08 10:06:36.000000000 +0200
+++ vbox/kBuild/footer.kmk	2008-09-08 10:07:25.000000000 +0200
@@ -90,8 +90,8 @@
 	$(_ALL_FETCHES) \
 	$(_ALL_PATCHES)
 
-# dependency files.
-_DEPFILES :=
+# Dependency files. (currently not on target level, only this global stuff)
+_DEPFILES        := $(DEPFILES)    $(DEPFILES.$(KBUILD_TARGET))      $(DEPFILES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(DEPFILES.$(KBUILD_TARGET_ARCH))    $(DEPFILES.$(KBUILD_TARGET_CPU))     $(DEPFILES.$(KBUILD_TYPE))
 
 # included dependency files.
 _DEPFILES_INCLUDED :=
@@ -1351,12 +1351,28 @@
 TARGET_$(target) := $(out)
 
 # INSTARGET_*
-ifndef $(target)_NOINST
-INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)), \
-	$(if $($(target)_INST), $(addprefix $(PATH_INS)/,$($(target)_INST)), $(definst)/))
+ifeq ($(strip $($(target)_NOINST) $($(target)_NOINST.$(bld_trg)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type))  $($(target)_NOINST.$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg_cpu)) $($(target)_NOINST.$(bld_trg_type))),)
+ ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_type)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg_arch))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg_arch)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg)))
+ else ifneq ($(strip $($(target)_INST.$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_type)))
+ else ifneq ($(strip $($(target)_INST)),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST))
+ else
+  local inst := $(definst)/
+ endif
+ INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)),$(inst))
 
 else # NOINST
-INSTARGET_$(target) :=
+ INSTARGET_$(target) :=
 endif # NOINST
 
 endef
@@ -2098,21 +2114,37 @@
 # @param	$(typevar)  The name of the variable with all the root targets of its type.
 # @remark   Only library uses this now.
 define def_target_install_pluss
-ifndef $(target)_NOINST
-INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)), \
-	$(if $($(target)_INST), $(addprefix $(PATH_INS)/,$($(target)_INST)), $(definst)/))
+ifeq ($(strip $($(target)_NOINST) $($(target)_NOINST.$(bld_trg)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type))  $($(target)_NOINST.$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg_cpu)) $($(target)_NOINST.$(bld_trg_type))),)
+ ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_type)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg_arch))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg_arch)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg)))
+ else ifneq ($(strip $($(target)_INST.$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_type)))
+ else ifneq ($(strip $($(target)_INST)),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST))
+ else
+  local inst := $(definst)/
+ endif
+ INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)),$(inst))
 
 $(eval $(def_link_install_rule))
 
-_INSTALLS_FILES += $(INSTARGET_$(target))
+ _INSTALLS_FILES += $(INSTARGET_$(target))
 
-ifdef KBUILD_DO_AUTO_INSTALL
-$(typevar) += $(INSTARGET_$(target))
-else
-$(typevar) += $(out)
-endif
+ ifdef KBUILD_DO_AUTO_INSTALL
+  $(typevar) += $(INSTARGET_$(target))
+ else
+  $(typevar) += $(out)
+ endif
 else # _NOINST
-$(typevar) += $(out)
+ $(typevar) += $(out)
 endif
 
 _OUT_FILES += $($(target)_OUTPUT_) $($(target)_OUTPUT_MAYBE_) $(out)
@@ -2203,8 +2235,40 @@
 	$($(target)_ARFLAGS.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_ARFLAGS.$(bld_trg_cpu))
 local dirdep      := $(call DIRDEP,$(dir $(out)))
-local deps        := $($(target)_DEPS)
-local orderdeps   := $($(target)_ORDERDEPS)
+local deps        := \
+	$($(target)_DEPS.$(bld_trg_cpu)) \
+	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_DEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_DEPS.$(bld_trg_arch)) \
+	$($(target)_DEPS.$(bld_trg)) \
+	$($(target)_DEPS.$(bld_type)) \
+	$($(target)_DEPS) \
+	$($(target)_LNK_DEPS.$(bld_trg_cpu)) \
+	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_LNK_DEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_LNK_DEPS.$(bld_trg_arch)) \
+	$($(target)_LNK_DEPS.$(bld_trg)) \
+	$($(target)_LNK_DEPS.$(bld_type)) \
+	$($(target)_LNK_DEPS)
+local orderdeps   := \
+	$($(target)_ORDERDEPS.$(bld_trg_cpu)) \
+	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_ORDERDEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_ORDERDEPS.$(bld_trg_arch)) \
+	$($(target)_ORDERDEPS.$(bld_trg)) \
+	$($(target)_ORDERDEPS.$(bld_type)) \
+	$($(target)_ORDERDEPS) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg_cpu)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg_arch)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_type)) \
+	$($(target)_LNK_ORDERDEPS)
 
 # Adjust paths if we got a default path.
 ifneq ($(defpath),)
@@ -2216,6 +2280,7 @@
 
 
 # Custom pre-link actions.
+## @todo bld_trg_cpu is missing here.
 ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
  local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
 else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch)
@@ -2530,8 +2595,40 @@
 	$(TOOL_$(tool)_LIBPATH.$(bld_type))\
 	$(TOOL_$(tool)_LIBPATH)
 local dirdep      := $(call DIRDEP,$(dir $(out)))
-local deps        := $($(target)_DEPS)
-local orderdeps   := $($(target)_ORDERDEPS)
+local deps        := \
+	$($(target)_DEPS.$(bld_trg_cpu)) \
+	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_DEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_DEPS.$(bld_trg_arch)) \
+	$($(target)_DEPS.$(bld_trg)) \
+	$($(target)_DEPS.$(bld_type)) \
+	$($(target)_DEPS) \
+	$($(target)_LNK_DEPS.$(bld_trg_cpu)) \
+	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_LNK_DEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_LNK_DEPS.$(bld_trg_arch)) \
+	$($(target)_LNK_DEPS.$(bld_trg)) \
+	$($(target)_LNK_DEPS.$(bld_type)) \
+	$($(target)_LNK_DEPS)
+local orderdeps   := \
+	$($(target)_ORDERDEPS.$(bld_trg_cpu)) \
+	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_ORDERDEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_ORDERDEPS.$(bld_trg_arch)) \
+	$($(target)_ORDERDEPS.$(bld_trg)) \
+	$($(target)_ORDERDEPS.$(bld_type)) \
+	$($(target)_ORDERDEPS) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg_cpu)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_type)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg_arch)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_trg)) \
+	$($(target)_LNK_ORDERDEPS.$(bld_type)) \
+	$($(target)_LNK_ORDERDEPS)
 
 # Adjust paths if we got a default path.
 ifneq ($(defpath),)
@@ -2609,20 +2706,36 @@
 local objs = $($(target)_OBJS_)
 
 # installation targets
-ifndef $(target)_NOINST
-INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)), \
-	$(if $($(target)_INST), $(addprefix $(PATH_INS)/,$($(target)_INST)), $(definst)/))
-ifdef KBUILD_DO_AUTO_INSTALL
-$(typevar)  += $(INSTARGET_$(target))
-else
-$(typevar)  += $(out)
-endif
-# generate the install rule
+ifeq ($(strip $($(target)_NOINST) $($(target)_NOINST.$(bld_trg)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type))  $($(target)_NOINST.$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg_cpu)) $($(target)_NOINST.$(bld_trg_type))),)
+ ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_type)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg_arch))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg_arch)))
+ else ifneq ($(strip $($(target)_INST.$(bld_trg))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg)))
+ else ifneq ($(strip $($(target)_INST.$(bld_type))),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_type)))
+ else ifneq ($(strip $($(target)_INST)),)
+  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST))
+ else
+  local inst := $(definst)/
+ endif
+ INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)),$(inst))
+ ifdef KBUILD_DO_AUTO_INSTALL
+  $(typevar)  += $(INSTARGET_$(target))
+ else
+  $(typevar)  += $(out)
+ endif
+ # generate the install rule
 $(eval $(def_link_install_rule))
 
 else # NOINST
-INSTARGET_$(target) :=
-$(typevar)  += $(out)
+ INSTARGET_$(target) :=
+ $(typevar)  += $(out)
 endif # NOINST
 
 # dependency file
diff -urN VirtualBox-2.0.0/kBuild/header.kmk vbox/kBuild/header.kmk
--- VirtualBox-2.0.0/kBuild/header.kmk	2008-09-08 10:06:36.000000000 +0200
+++ vbox/kBuild/header.kmk	2008-09-08 10:07:25.000000000 +0200
@@ -63,7 +63,7 @@
 # The revision in which this file was last modified.
 # This can be useful when using development versions of kBuild.
 #
-KMK_REVISION := $(patsubst %:,,  $Rev: 1664 $  )
+KMK_REVISION := $(patsubst %:,,  $Rev: 1702 $  )
 
 
 #
@@ -377,9 +377,9 @@
 endif
 ifndef PATH_OUT
  ifdef BUILD_TARGET_SUB # (BUILD_TARGET_SUB is not currently recognized by kBuild in any other places - obsolete)
-  PATH_OUT          := $(PATH_OUT_BASE)/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH).$(BUILD_TARGET_SUB)/$(KBUILD_TYPE)
+  PATH_OUT           = $(PATH_OUT_BASE)/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH).$(BUILD_TARGET_SUB)/$(KBUILD_TYPE)
  else
-  PATH_OUT          := $(PATH_OUT_BASE)/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/$(KBUILD_TYPE)
+  PATH_OUT           = $(PATH_OUT_BASE)/$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)/$(KBUILD_TYPE)
  endif
 endif # !define PATH_OUT
 PATH_OBJCACHE        = $(PATH_OUT_BASE)/kObjCache
@@ -719,7 +719,7 @@
 # A Config.kmk file can add it's own properties to this list and kBuild
 # will do the necessary inheritance from templates to targets.
 PROPS_ACCUMULATE_R := \
-	DEPS ORDERDEPS DEFS \
+	DEPS LNK_DEPS ORDERDEPS LNK_ORDERDEPS DEFS \
 	ARFLAGS \
 	CFLAGS CDEFS \
 	CXXFLAGS CXXDEFS \
@@ -732,7 +732,7 @@
 ## PROPS_ACCUMULATE_R_LNK
 # Subset of PROPS_ACCUMULATE_R which applies to all linkable targets.
 PROPS_ACCUMULATE_R_LNK := \
-	DEPS ORDERDEPS DEFS \
+	DEPS LNK_DEPS ORDERDEPS LNK_ORDERDEPS DEFS \
 	CFLAGS CDEFS \
 	CXXFLAGS CXXDEFS \
 	OBJCFLAGS OBJCDEFS \
@@ -1019,6 +1019,7 @@
 # This prevents some trouble when users override the defaults for these
 # variables and uses relative paths or paths with incorrect case.
 #
+PATH_OUT_BASE := $(abspath $(PATH_OUT_BASE))
 PATH_OUT    := $(abspath $(PATH_OUT))
 PATH_OBJ    := $(abspath $(PATH_OBJ))
 PATH_TARGET := $(abspath $(PATH_TARGET))
diff -urN VirtualBox-2.0.0/kBuild/tools/VCC70.kmk vbox/kBuild/tools/VCC70.kmk
--- VirtualBox-2.0.0/kBuild/tools/VCC70.kmk	2008-09-08 10:06:36.000000000 +0200
+++ vbox/kBuild/tools/VCC70.kmk	2008-09-08 10:07:25.000000000 +0200
@@ -293,7 +293,7 @@
 #
 # @param    $(outbase)  Output basename (full). Use this for list files and such.
 TOOL_VCC70_LINK_DLL_OUTPUT = $(outbase).map $(outbase).lib $(outbase).exp
-TOOL_VCC70_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk
+TOOL_VCC70_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(PATH_LIB)/$(notdir $(outbase)).lib $(PATH_LIB)/$(notdir $(outbase)).exp
 TOOL_VCC70_LINK_DLL_DEPEND = $(objs) $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib))) $(othersrc)
 TOOL_VCC70_LINK_DLL_DEPORD = $(call DIRDEP,$(PATH_LIB))
 define TOOL_VCC70_LINK_DLL_CMDS
@@ -308,9 +308,7 @@
 		$(foreach p,$(libpath), /LIBPATH:$(p)) \
 		$(subst /,\\,$(objs)) \
 		$(subst /,\\,$(libs))
-ifeq ($(filter %.exp .def,$(othersrc)),)
 	$(QUIET)$(CP) --changed --ignore-non-existing $(outbase).exp $(outbase).lib $(PATH_LIB)/
-endif
 $(eval _DIRS += $(PATH_LIB))
 endef
 
diff -urN VirtualBox-2.0.0/kBuild/tools/VCC80AMD64.kmk vbox/kBuild/tools/VCC80AMD64.kmk
--- VirtualBox-2.0.0/kBuild/tools/VCC80AMD64.kmk	2008-09-08 10:06:36.000000000 +0200
+++ vbox/kBuild/tools/VCC80AMD64.kmk	2008-09-08 10:07:25.000000000 +0200
@@ -265,7 +265,7 @@
 TOOL_VCC80AMD64_LINK_DLL_DEPEND = $(objs) $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib))) $(othersrc)
 TOOL_VCC80AMD64_LINK_DLL_DEPORD = $(call DIRDEP,$(PATH_LIB))
 TOOL_VCC80AMD64_LINK_DLL_OUTPUT = $(outbase).map $(outbase).lib $(outbase).exp
-TOOL_VCC80AMD64_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(out).manifest
+TOOL_VCC80AMD64_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(out).manifest $(PATH_LIB)/$(notdir $(outbase)).lib $(PATH_LIB)/$(notdir $(outbase)).exp
 define TOOL_VCC80AMD64_LINK_DLL_CMDS
 	$(QUIET)$(TOOL_VCC80AMD64_LD) $(flags) \
 		/OUT:$(out) \
@@ -280,9 +280,7 @@
 		$(subst /,\\,$(libs))
 	$(QUIET)$(TEST) -f $(out).manifest -- \
 		$(TOOL_VCC80AMD64_MT) -manifest $(subst /,\\,$(out)).manifest '-outputresource:$(subst /,\\,$(out));#2'
-ifeq ($(filter %.exp .def,$(othersrc)),)
 	$(QUIET)$(CP) --changed --ignore-non-existing $(outbase).exp $(outbase).lib $(PATH_LIB)/
-endif
 $(eval _DIRS += $(PATH_LIB))
 endef
 
diff -urN VirtualBox-2.0.0/kBuild/tools/VCC80.kmk vbox/kBuild/tools/VCC80.kmk
--- VirtualBox-2.0.0/kBuild/tools/VCC80.kmk	2008-09-08 10:06:36.000000000 +0200
+++ vbox/kBuild/tools/VCC80.kmk	2008-09-08 10:07:25.000000000 +0200
@@ -288,7 +288,7 @@
 TOOL_VCC80_LINK_DLL_DEPEND = $(objs) $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib))) $(othersrc)
 TOOL_VCC80_LINK_DLL_DEPORD = $(call DIRDEP,$(PATH_LIB))
 TOOL_VCC80_LINK_DLL_OUTPUT = $(outbase).map $(outbase).lib $(outbase).exp
-TOOL_VCC80_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(out).manifest
+TOOL_VCC80_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(out).manifest $(PATH_LIB)/$(notdir $(outbase)).lib $(PATH_LIB)/$(notdir $(outbase)).exp
 define TOOL_VCC80_LINK_DLL_CMDS
 	$(QUIET)$(TOOL_VCC80_LD) $(flags) \
 		/OUT:$(out) \
@@ -303,9 +303,7 @@
 		$(subst /,\\,$(libs))
 	$(QUIET)$(TEST) -f $(out).manifest -- \
 		$(TOOL_VCC80_MT) -manifest $(subst /,\\,$(out)).manifest '-outputresource:$(subst /,\\,$(out));#2'
-ifeq ($(filter %.exp .def,$(othersrc)),)
 	$(QUIET)$(CP) --changed --ignore-non-existing $(outbase).exp $(outbase).lib $(PATH_LIB)/
-endif
 $(eval _DIRS += $(PATH_LIB))
 endef
 
diff -urN VirtualBox-2.0.0/kBuild/tools/VCC80X86.kmk vbox/kBuild/tools/VCC80X86.kmk
--- VirtualBox-2.0.0/kBuild/tools/VCC80X86.kmk	2008-09-08 10:06:36.000000000 +0200
+++ vbox/kBuild/tools/VCC80X86.kmk	2008-09-08 10:07:25.000000000 +0200
@@ -265,8 +265,8 @@
 # @param    $(outbase)  Output basename (full). Use this for list files and such.
 TOOL_VCC80X86_LINK_DLL_DEPEND = $(objs) $(foreach lib,$(libs),$(if $(findstring $(lib),$(subst /,x,$(lib))),, $(lib))) $(othersrc)
 TOOL_VCC80X86_LINK_DLL_DEPORD = $(call DIRDEP,$(PATH_LIB))
-TOOL_VCC80X86_LINK_DLL_OUTPUT = $(outbase).map $(outbase).lib $(outbase).exp
-TOOL_VCC80X86_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(out).manifest
+TOOL_VCC80X86_LINK_DLL_OUTPUT = $(outbase).map $(outbase).lib $(outbase).exp 
+TOOL_VCC80X86_LINK_DLL_OUTPUT_MAYBE = $(outbase).pdb $(outbase).ilk $(out).manifest $(PATH_LIB)/$(notdir $(outbase)).lib $(PATH_LIB)/$(notdir $(outbase)).exp
 define TOOL_VCC80X86_LINK_DLL_CMDS
 	$(QUIET)$(TOOL_VCC80X86_LD) $(flags) \
 		/OUT:$(out) \
@@ -281,9 +281,7 @@
 		$(subst /,\\,$(libs))
 	$(QUIET)$(TEST) -f $(out).manifest -- \
 		$(TOOL_VCC80X86_MT) -manifest $(subst /,\\,$(out)).manifest '-outputresource:$(subst /,\\,$(out));#2'
-ifeq ($(filter %.exp .def,$(othersrc)),)
 	$(QUIET)$(CP) --changed --ignore-non-existing $(outbase).exp $(outbase).lib $(PATH_LIB)/
-endif
 $(eval _DIRS += $(PATH_LIB))
 endef
 
diff -urN VirtualBox-2.0.0/Makefile.kmk vbox/Makefile.kmk
--- VirtualBox-2.0.0/Makefile.kmk	2008-09-08 10:06:34.000000000 +0200
+++ vbox/Makefile.kmk	2008-09-08 10:07:22.000000000 +0200
@@ -710,9 +710,11 @@
 		$(VBOX_PATH_ADDITIONS)/VBoxGuestAdditions.iso
 
 sdk:
-	+ $(KMK) VBOX_ONLY_SDK=1 VBOX_WITH_PYTHON=1  \
+	+ $(KMK) VBOX_ONLY_SDK=1  \
               pass_bldprogs pass_others pass_installs pass_packing
 
+fetch_sdk_reqs:
+	+ $(KMK) KBUILD_TARGET=win  KBUILD_ARCH=x86  -C tools fetch
 
 #
 # Generate VirtualBox-OSE-x.x.x.tar.bz2 tarballs for distribution
diff -urN VirtualBox-2.0.0/src/libs/xpcom18a4/Makefile.kmk vbox/src/libs/xpcom18a4/Makefile.kmk
--- VirtualBox-2.0.0/src/libs/xpcom18a4/Makefile.kmk	2008-09-08 10:06:16.000000000 +0200
+++ vbox/src/libs/xpcom18a4/Makefile.kmk	2008-09-08 10:07:02.000000000 +0200
@@ -1190,8 +1190,7 @@
  TEMPLATE_XPCOMIPC_DEFS           += IPC_LOGGING
 endif
 
-TEMPLATE_XPCOMIPC_LIBS.darwin      = $(TARGET_VBoxXPCOM) $(TEMPLATE_XPCOM_LIBS.darwin)
-TEMPLATE_XPCOMIPC_LIBS.os2         = $(TARGET_VBoxXPCOM) $(TEMPLATE_XPCOM_LIBS.os2)
+TEMPLATE_XPCOMIPC_LIBS       = $(TARGET_VBoxXPCOM) $(TEMPLATE_XPCOM_LIBS)
 
 TEMPLATE_XPCOMIPCEXE               = XPCOM IPC executables
 TEMPLATE_XPCOMIPCEXE_EXTENDS       = XPCOMEXE
@@ -1325,6 +1324,7 @@
 VBoxPython_DEFS = _IMPL_NS_COM _IMPL_NS_BASE EXPORT_XPTI_API EXPORT_XPT_API \
                   VBOX_PYXPCOM VBOX_WITH_XPCOM
 VBoxPython_NAME.darwin = VBoxPython2_3
+VBoxPython_INST.solaris.amd64 = $(INST_BIN)/64/
 VBoxPython_INCS = \
 	python/src \
 	$(VBOX_PATH_PYTHON_INC)
diff -urN VirtualBox-2.0.0/src/libs/xpcom18a4/python/sample/vboxshell.py vbox/src/libs/xpcom18a4/python/sample/vboxshell.py
--- VirtualBox-2.0.0/src/libs/xpcom18a4/python/sample/vboxshell.py	2008-09-08 10:06:14.000000000 +0200
+++ vbox/src/libs/xpcom18a4/python/sample/vboxshell.py	2008-09-08 10:06:59.000000000 +0200
@@ -15,23 +15,9 @@
 # Please note the trailing slash in VBOX_PROGRAM_PATH - it's a must.
 # 
 # This is the place where VirtualBox resides
-#  export VBOX_PROGRAM_PATH=/home/nike/work/ws/out/linux.amd64/debug/bin/
+#  export VBOX_PROGRAM_PATH=/opt/VirtualBox-2.0.0/
 # To allow Python find modules
-#  export PYTHONPATH=$VBOX_PROGRAM_PATH/sdk/bindings/xpcom/python:$VBOX_PROGRAM_PATH
-# To allow library resolution
-#  export LD_LIBRARY_PATH=$VBOX_PROGRAM_PATH
-#
-# Additionally, on 64-bit Solaris, you need to use 64-bit Python from 
-# /usr/bin/amd64/python and due to quirks in native modules loading of 
-# Python do the following:
-#   mkdir $VBOX_PROGRAM_PATH/64
-#   ln -s $VBOX_PROGRAM_PATH/VBoxPython.so $VBOX_PROGRAM_PATH/64/VBoxPython.so 
-#
-# Mac OS X users can get away with just this:
-#   export PYTHONPATH=$VBOX_SDK/bindings/xpcom/python:$PYTHONPATH
-# , where $VBOX_SDK is is replaced with the place you unzipped the SDK
-# or <trunk>/out/darwin.x86/release/dist/sdk.
-#  
+#  export PYTHONPATH=../:$VBOX_PROGRAM_PATH
 #
 
 # this one has to be the first XPCOM related import
diff -urN VirtualBox-2.0.0/src/VBox/Additions/Makefile.kmk vbox/src/VBox/Additions/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/Additions/Makefile.kmk	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Additions/Makefile.kmk	2008-09-08 10:07:16.000000000 +0200
@@ -135,20 +135,13 @@
  	VBoxLinuxAdditions-x86.run=$(VBOX_PATH_ADDITIONS.linux.x86)/VBoxLinuxAdditions.run
 endif
 
-
+# Solaris has only one additions package containing both 32-bit and 64-bit additions
 ifdef VBOX_WITH_ADDITIONS_ISO.solaris.amd64
- VBOX_PATH_ADDITIONS.solaris.amd64 = $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions
- GUESTADDITIONS_FILESPEC.solaris.amd64 = \
- 	VBoxSolarisAdditions-amd64.pkg=$(VBOX_PATH_ADDITIONS.solaris.amd64)/VBoxSolarisAdditions.pkg
-endif
-ifdef VBOX_WITH_ADDITIONS_ISO.solaris.x86
- VBOX_PATH_ADDITIONS.solaris.x86 = $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions
-## @todo 64-bit additions: rename this package, update docs (?) and tests (?).
- GUESTADDITIONS_FILESPEC.solaris.x86 = \
- 	VBoxSolarisAdditions-x86.pkg=$(VBOX_PATH_ADDITIONS.solaris.x86)/VBoxSolarisAdditions.pkg
+ VBOX_PATH_ADDITIONS.solaris = $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions
+ GUESTADDITIONS_FILESPEC.solaris = \
+ 	VBoxSolarisAdditions.pkg=$(VBOX_PATH_ADDITIONS.solaris)/VBoxSolarisAdditions.pkg
 endif
 
-
 ifdef VBOX_WITH_ADDITIONS_ISO.win.amd64
  VBOX_PATH_ADDITIONS.win.amd64 = $(PATH_OUT_BASE)/win.amd64/$(KBUILD_TYPE)/bin/additions
  GUESTADDITIONS_FILESPEC.win.amd64 = \
@@ -222,8 +215,7 @@
 			$(subst =,=deleteme= ,\
 				$(GUESTADDITIONS_FILESPEC.win.x86) \
 				$(GUESTADDITIONS_FILESPEC.win.amd64) \
-				$(GUESTADDITIONS_FILESPEC.solaris.x86) \
-				$(GUESTADDITIONS_FILESPEC.solaris.amd64) \
+				$(GUESTADDITIONS_FILESPEC.solaris) \
 				$(GUESTADDITIONS_FILESPEC.os2.x86) \
 				$(GUESTADDITIONS_FILESPEC.linux.x86) \
 				$(GUESTADDITIONS_FILESPEC.linux.amd64) \
@@ -242,8 +234,7 @@
 		$(GUESTADDITIONS_FILESPEC.win) \
 		$(GUESTADDITIONS_FILESPEC.win.x86) \
 		$(GUESTADDITIONS_FILESPEC.win.amd64) \
-		$(GUESTADDITIONS_FILESPEC.solaris.x86) \
-		$(GUESTADDITIONS_FILESPEC.solaris.amd64) \
+		$(GUESTADDITIONS_FILESPEC.solaris) \
 		$(GUESTADDITIONS_FILESPEC.os2.x86) \
 		$(GUESTADDITIONS_FILESPEC.linux.x86) \
 		$(GUESTADDITIONS_FILESPEC.linux.amd64) \
diff -urN VirtualBox-2.0.0/src/VBox/Additions/solaris/Installer/makepackage.sh vbox/src/VBox/Additions/solaris/Installer/makepackage.sh
--- VirtualBox-2.0.0/src/VBox/Additions/solaris/Installer/makepackage.sh	2008-09-08 10:06:27.000000000 +0200
+++ vbox/src/VBox/Additions/solaris/Installer/makepackage.sh	2008-09-08 10:07:15.000000000 +0200
@@ -21,24 +21,33 @@
 # Usage:
 #       makespackage.sh $(PATH_TARGET)/install packagename $(KBUILD_TARGET_ARCH)
 
-if test -z "$3"; then
-    echo "Usage: $0 installdir packagename x86|amd64"
+if test -z "$2"; then
+    echo "Usage: $0 installdir packagename"
     exit 1
 fi
 
-MY_PKGNAME=SUNWvboxguest
-MY_GGREP=/usr/sfw/bin/ggrep
-MY_AWK=/usr/bin/awk
+VBOX_PKGNAME=SUNWvboxguest
+VBOX_AWK=/usr/bin/awk
+VBOX_GGREP=/usr/sfw/bin/ggrep
+VBOX_AWK=/usr/bin/awk
 
 # check for GNU grep we use which might not ship with all Solaris
-if test ! -f "$MY_GGREP" && test ! -h "$MY_GGREP"; then
-    echo "## GNU grep not found in $MY_GGREP."
+if test ! -f "$VBOX_GGREP" && test ! -h "$VBOX_GGREP"; then
+    echo "## GNU grep not found in $VBOX_GGREP."
     exit 1
 fi
 
 # bail out on non-zero exit status
 set -e
 
+# Fixup filelist using awk, the parameters must be in awk syntax
+# params: filename condition action
+filelist_fixup()
+{
+    "$VBOX_AWK" 'NF == 6 && '"$2"' { '"$3"' } { print }' "$1" > "tmp-$1"
+    mv -f "tmp-$1" "$1"
+}
+
 # prepare file list
 cd "$1"
 echo 'i pkginfo=./vboxguest.pkginfo' > prototype
@@ -49,24 +58,25 @@
     echo 'i copyright=./vboxguest.copyright' >> prototype
 fi
 echo 'e sed /etc/devlink.tab ? ? ?' >> prototype
-find . -print | $MY_GGREP -v -E 'prototype|makepackage.sh|vboxguest.pkginfo|postinstall.sh|preremove.sh|vboxguest.space|vboxguest.copyright' | pkgproto >> prototype
+find . -print | $VBOX_GGREP -v -E 'prototype|makepackage.sh|vboxguest.pkginfo|postinstall.sh|preremove.sh|vboxguest.space|vboxguest.copyright' | pkgproto >> prototype
 
 # don't grok for the sed class files
-$MY_AWK 'NF == 6 && $2 == "none" { $5 = "root"; $6 = "bin" } { print }' prototype > prototype2
-$MY_AWK 'NF == 6 && $2 == "none" { $3 = "opt/VirtualBoxAdditions/"$3"="$3 } { print }' prototype2 > prototype
+filelist_fixup prototype '$2 == "none"'                                                     '$5 = "root"; $6 = "bin"'
+filelist_fixup prototype '$2 == "none"'                                                     '$3 = "opt/VirtualBoxAdditions/"$3"="$3'
 
-# install the kernel module to the right place
-if test "$3" = "x86"; then
-    $MY_AWK 'NF == 6 && $3 == "opt/VirtualBoxAdditions/vboxguest=vboxguest" { $3 = "platform/i86pc/kernel/drv/vboxguest=vboxguest"; $6 = "sys" } { print }' prototype > prototype2
-else
-    $MY_AWK 'NF == 6 && $3 == "opt/VirtualBoxAdditions/vboxguest=vboxguest" { $3 = "platform/i86pc/kernel/drv/amd64/vboxguest=vboxguest"; $6 = "sys" } { print }' prototype > prototype2
-fi
-$MY_AWK 'NF == 6 && $3 == "opt/VirtualBoxAdditions/vboxguest.conf=vboxguest.conf" { $3 = "platform/i86pc/kernel/drv/vboxguest.conf=vboxguest.conf" } { print }' prototype2 > prototype
+# 32-bit kernel module
+filelist_fixup prototype '$3 == "opt/VirtualBoxAdditions/vboxguest=vboxguest"'              '$3 = "platform/i86pc/kernel/drv/vboxguest=vboxguest"; $6="sys"'
 
-# install the timesync SMF service
-$MY_AWK 'NF == 6 && $3 == "opt/VirtualBoxAdditions/vboxservice.xml=vboxservice.xml" { $3 = "/var/svc/manifest/system/virtualbox/vboxservice.xml=vboxservice.xml" } { print }' prototype2 > prototype
+# 64-bit kernel module
+filelist_fixup prototype '$3 == "opt/VirtualBoxAdditions/amd64/vboxguest=amd64/vboxguest"'  '$3 = "platform/i86pc/kernel/drv/amd64/vboxguest=amd64/vboxguest"; $6="sys"'
 
-rm prototype2
+# kernel module config file
+filelist_fixup prototype '$3 == "opt/VirtualBoxAdditions/vboxguest.conf=vboxguest.conf"'    '$3 = "platform/i86pc/kernel/drv/vboxguest.conf=vboxguest.conf"'
+
+filelist_fixup prototype '$3 == "opt/VirtualBoxAdditions/vboxservice.xml=vboxservice.xml"'  '$3 = "var/svc/manifest/system/virtualbox/vboxservice.xml=vboxservice.xml"'
+echo " --- start of prototype  ---" 
+cat prototype
+echo " --- end of prototype --- "
 
 # explicitly set timestamp to shutup warning
 VBOXPKG_TIMESTAMP=vboxguest`date '+%Y%m%d%H%M%S'`
@@ -75,8 +85,8 @@
 pkgmk -p $VBOXPKG_TIMESTAMP -o -r .
 
 # translate into package datastream
-pkgtrans -s -o /var/spool/pkg `pwd`/$2 "$MY_PKGNAME"
+pkgtrans -s -o /var/spool/pkg `pwd`/$2 "$VBOX_PKGNAME"
 
-rm -rf "/var/spool/pkg/$MY_PKGNAME"
+rm -rf "/var/spool/pkg/$VBOX_PKGNAME"
 exit $?
 
diff -urN VirtualBox-2.0.0/src/VBox/Additions/solaris/Installer/postinstall.sh vbox/src/VBox/Additions/solaris/Installer/postinstall.sh
--- VirtualBox-2.0.0/src/VBox/Additions/solaris/Installer/postinstall.sh	2008-09-08 10:06:27.000000000 +0200
+++ vbox/src/VBox/Additions/solaris/Installer/postinstall.sh	2008-09-08 10:07:15.000000000 +0200
@@ -21,30 +21,28 @@
 
 sync
 vboxadditions_path="/opt/VirtualBoxAdditions"
+vboxadditions64_path="/opt/VirtualBoxAdditions/amd64"
+solaris64dir="amd64"
 
 # vboxguest.sh would've been installed, we just need to call it.
 $vboxadditions_path/vboxguest.sh restart silentunload
 
-# get what ISA the guest is running
-cputype=`isainfo -k`
-isadir=""
-if test "$cputype" = "amd64"; then
-    isadir="amd64"
-fi
-
-
-# suid permissions for timesync
+# Set permissions
 chmod 04755 $vboxadditions_path/VBoxService
+chmod a+x $vboxadditions_path/VBox.sh
 chmod a+x $vboxadditions_path/VBoxClient
 chmod a+x $vboxadditions_path/VBoxControl
 chmod a+x $vboxadditions_path/VBoxRandR.sh
+chmod 04755 $vboxadditions64_path/VBoxService
+chmod a+x $vboxadditions64_path/VBoxClient
+chmod a+x $vboxadditions64_path/VBoxControl
 
 # create links
 echo "Creating links..."
 /usr/sbin/installf -c none $PKGINST /dev/vboxguest=../devices/pci@0,0/pci80ee,cafe@4:vboxguest s
-/usr/sbin/installf -c none $PKGINST /usr/bin/VBoxClient=$vboxadditions_path/VBoxClient s
-/usr/sbin/installf -c none $PKGINST /usr/bin/VBoxService=$vboxadditions_path/VBoxService s
-/usr/sbin/installf -c none $PKGINST /usr/bin/VBoxControl=$vboxadditions_path/VBoxControl s
+/usr/sbin/installf -c none $PKGINST /usr/bin/VBoxClient=$vboxadditions_path/VBox.sh s
+/usr/sbin/installf -c none $PKGINST /usr/bin/VBoxService=$vboxadditions_path/VBox.sh s
+/usr/sbin/installf -c none $PKGINST /usr/bin/VBoxControl=$vboxadditions_path/VBox.sh s
 /usr/sbin/installf -c none $PKGINST /usr/bin/VBoxRandR=$vboxadditions_path/VBoxRandR.sh s
 
 # Install Xorg components to the required places
@@ -56,20 +54,20 @@
 
 case "$xorgversion" in
     1.3.* )
-        vboxmouse_src="$vboxadditions_path/vboxmouse_drv_71.so"
-        vboxvideo_src="$vboxadditions_path/vboxvideo_drv_13.so"
+        vboxmouse_src="vboxmouse_drv_71.so"
+        vboxvideo_src="vboxvideo_drv_13.so"
         ;;
     1.4.* )
-        vboxmouse_src="$vboxadditions_path/vboxmouse_drv_14.so"
-        vboxvideo_src="$vboxadditions_path/vboxvideo_drv_14.so"
+        vboxmouse_src="vboxmouse_drv_14.so"
+        vboxvideo_src="vboxvideo_drv_14.so"
         ;;
     7.1.* | *7.2.* )
-        vboxmouse_src="$vboxadditions_path/vboxmouse_drv_71.so"
-        vboxvideo_src="$vboxadditions_path/vboxvideo_drv_71.so"
+        vboxmouse_src="vboxmouse_drv_71.so"
+        vboxvideo_src="vboxvideo_drv_71.so"
 	    ;;
     6.9.* | 7.0.* )
-        vboxmouse_src="$vboxadditions_path/vboxmouse_drv_70.so"
-        vboxvideo_src="$vboxadditions_path/vboxvideo_drv_70.so"
+        vboxmouse_src="vboxmouse_drv_70.so"
+        vboxvideo_src="vboxvideo_drv_70.so"
         ;;
 esac
 
@@ -82,18 +80,36 @@
     retval=2
 else
     echo "Configuring Xorg..."
-    vboxmouse_dest="/usr/X11/lib/modules/input/$isadir/vboxmouse_drv.so"
-    vboxvideo_dest="/usr/X11/lib/modules/input/$isadir/vboxvideo_drv.so"
+
+    # 32-bit
+    vboxmouse_dest="/usr/X11/lib/modules/input/vboxmouse_drv.so"
+    vboxvideo_dest="/usr/X11/lib/modules/drivers/vboxvideo_drv.so"
     /usr/sbin/installf -c none $PKGINST "$vboxmouse_dest" f
     /usr/sbin/installf -c none $PKGINST "$vboxvideo_dest" f
-    cp "$vboxmouse_src" "$vboxmouse_dest"
-    cp "$vboxvideo_src" "$vboxvideo_dest"
+    cp "$vboxadditions_path/$vboxmouse_src" "$vboxmouse_dest"
+    cp "$vboxadditions_path/$vboxvideo_src" "$vboxvideo_dest"
+
+    # 64-bit
+    vboxmouse_dest="/usr/X11/lib/modules/input/$solaris64dir/vboxmouse_drv.so"
+    vboxvideo_dest="/usr/X11/lib/modules/drivers/$solaris64dir/vboxvideo_drv.so"
+    /usr/sbin/installf -c none $PKGINST "$vboxmouse_dest" f
+    /usr/sbin/installf -c none $PKGINST "$vboxvideo_dest" f
+    cp "$vboxadditions64_path/$vboxmouse_src" "$vboxmouse_dest"
+    cp "$vboxadditions64_path/$vboxvideo_src" "$vboxvideo_dest"
 
     # Removing redudant files
+    # 32-bit
     /usr/sbin/removef $PKGINST $vboxadditions_path/vboxmouse_drv_* 1>/dev/null 2>/dev/null
     /usr/sbin/removef $PKGINST $vboxadditions_path/vboxvideo_drv_* 1>/dev/null 2>/dev/null
     rm -f $vboxadditions_path/vboxmouse_drv_*
     rm -f $vboxadditions_path/vboxvideo_drv_*
+
+    # 64-bit
+    /usr/sbin/removef $PKGINST $vboxadditions64_path/vboxmouse_drv_* 1>/dev/null 2>/dev/null
+    /usr/sbin/removef $PKGINST $vboxadditions64_path/vboxvideo_drv_* 1>/dev/null 2>/dev/null
+    rm -f $vboxadditions64_path/vboxmouse_drv_*
+    rm -f $vboxadditions64_path/vboxvideo_drv_*
+
     /usr/sbin/removef -f $PKGINST
 
     # Some distros like Indiana have no xorg.conf, deal with this
diff -urN VirtualBox-2.0.0/src/VBox/Additions/solaris/Installer/VBox.sh vbox/src/VBox/Additions/solaris/Installer/VBox.sh
--- VirtualBox-2.0.0/src/VBox/Additions/solaris/Installer/VBox.sh	1970-01-01 01:00:00.000000000 +0100
+++ vbox/src/VBox/Additions/solaris/Installer/VBox.sh	2008-09-08 10:07:15.000000000 +0200
@@ -0,0 +1,43 @@
+#!/bin/sh
+# Sun xVM VirtualBox
+# VirtualBox startup script for Solaris Guests Additions
+#
+# Copyright (C) 2008 Sun Microsystems, Inc.
+#
+# This file is part of VirtualBox Open Source Edition (OSE), as
+# available from http://www.virtualbox.org. This file is free software;
+# you can redistribute it and/or modify it under the terms of the GNU
+# General Public License (GPL) as published by the Free Software
+# Foundation, in version 2 as it comes in the "COPYING" file of the
+# VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+# hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+#
+# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+# Clara, CA 95054 USA or visit http://www.sun.com if you need
+# additional information or have any questions.
+#
+
+CPUTYPE=`isainfo -k`
+ISADIR=""
+if test "$CPUTYPE" = "amd64"; then
+    ISADIR="amd64"
+fi
+
+INSTALL_DIR="/opt/VirtualBoxAdditions"
+APP=`which $0`
+APP=`basename $APP`
+case "$APP" in
+  VBoxClient)
+    exec "$INSTALL_DIR/$ISADIR/VBoxClient" "$@"
+  ;;
+  VBoxService)
+    exec "$INSTALL_DIR/$ISADIR/VBoxService" "$@"
+  ;;
+  VBoxControl)
+    exec "$INSTALL_DIR/$ISADIR/VBoxControl" "$@"
+  ;;
+  *)
+    echo "Unknown application - $APP"
+  ;;
+esac
+
diff -urN VirtualBox-2.0.0/src/VBox/Additions/solaris/Makefile.kmk vbox/src/VBox/Additions/solaris/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/Additions/solaris/Makefile.kmk	2008-09-08 10:06:27.000000000 +0200
+++ vbox/src/VBox/Additions/solaris/Makefile.kmk	2008-09-08 10:07:15.000000000 +0200
@@ -39,8 +39,8 @@
 PKGINFO_REVSTAMP = $(date %Y.%m.%d.%H.%M)
 VBOX_PATH_SOLARIS_ADDITION_INSTALLER := $(PATH_SUB_CURRENT)/Installer
 VBOX_PATH_X11_ADDITION_INSTALLER     := $(PATH_ROOT)/src/VBox/Additions/x11/installer
-SOLARIS_INST_DIR  := $(PATH_TARGET)/install
-SOLARIS_TEMP_DIR  := $(PATH_TARGET)/tempinstall
+SOLARIS_INST_DIR   := $(PATH_TARGET)/install
+SOLARIS64_INST_DIR := $(SOLARIS_INST_DIR)/amd64
 
 ifeq ($(KBUILD_TYPE),debug)
  BIN_COPY         := $(CP) -f
@@ -68,28 +68,39 @@
 		$(VBOX_PATH_X11_ADDITION_INSTALLER)/x11restore.pl \
 		$(VBOX_PATH_X11_ADDITION_INSTALLER)/solaris_xorg.conf \
 		$(VBOX_PATH_X11_ADDITION_INSTALLER)/VBoxRandR.sh \
-		$(PATH_BIN)/additions/vboxguest \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxguest \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxguest \
 		$(PATH_ROOT)/src/VBox/Additions/common/VBoxGuest/VBoxGuest-solaris.conf \
 		$(if $(VBOX_OSE),,$(PATH_ROOT)/doc/License.txt) \
-		$(PATH_BIN)/additions/VBoxClient \
-		$(PATH_BIN)/additions/VBoxService \
-		$(PATH_BIN)/additions/VBoxControl \
-		$(PATH_BIN)/additions/vboxvideo_drv_13.so \
-		$(PATH_BIN)/additions/vboxvideo_drv_14.so \
-		$(PATH_BIN)/additions/vboxvideo_drv_70.so \
-		$(PATH_BIN)/additions/vboxvideo_drv_71.so \
-		$(PATH_BIN)/additions/vboxmouse_drv_14.so \
-		$(PATH_BIN)/additions/vboxmouse_drv_70.so \
-		$(PATH_BIN)/additions/vboxmouse_drv_71.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/VBoxClient \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/VBoxService \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/VBoxControl \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_13.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_14.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_70.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_71.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_14.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_70.so \
+		$(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_71.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/VBoxClient \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/VBoxService \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/VBoxControl \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_13.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_14.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_70.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_71.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_14.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_70.so \
+		$(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_71.so \
 		$(VBOX_PATH_SOLARIS_ADDITION_INSTALLER)/vboxdevlink.sed \
+		$(VBOX_PATH_SOLARIS_ADDITION_INSTALLER)/VBox.sh \
 		$(PATH_SUB_CURRENT)/solaris/Makefile.kmk
 	$(call MSG_L1,Installing guest additions)
 	@# Clear out the existing package files if needed
 	$(QUIET)rm -rf $(SOLARIS_INST_DIR)
-	$(QUIET)rm -rf $(SOLARIS_TEMP_DIR)
 	$(QUIET)$(MKDIR) -p $(SOLARIS_INST_DIR)
+	$(QUIET)$(MKDIR) -p $(SOLARIS64_INST_DIR)
 	$(QUIET)$(MKDIR) -p $(SOLARIS_INST_DIR)/etc
-	$(QUIET)$(MKDIR) -p $(SOLARIS_TEMP_DIR)
 	$(QUIET)$(SED) \
 		-e "s/@VBOX_VERSION_STRING@/$(VBOX_VERSION_STRING)/g" \
 		-e "s/@VBOX_VERSION_REVSTAMP@/$(PKGINFO_REVSTAMP)/g" \
@@ -110,20 +121,32 @@
 	$(QUIET)$(INSTALL) -m 0644 $(VBOX_PATH_X11_ADDITION_INSTALLER)/solaris_xorg.conf                    $(SOLARIS_INST_DIR)/solaris_xorg.conf
 	$(QUIET)$(INSTALL) -m 0755 $(VBOX_PATH_X11_ADDITION_INSTALLER)/VBoxRandR.sh                         $(SOLARIS_INST_DIR)/VBoxRandR.sh
 	$(QUIET)$(INSTALL) -m 0644 $(PATH_ROOT)/src/VBox/Additions/common/VBoxGuest/VBoxGuest-solaris.conf  $(SOLARIS_INST_DIR)/vboxguest.conf
-	$(QUIET)$(INSTALL) -m 0644 $(PATH_BIN)/additions/vboxguest                                          $(SOLARIS_INST_DIR)/vboxguest
+	$(QUIET)$(INSTALL) -m 0644 $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxguest      $(SOLARIS_INST_DIR)/vboxguest
+	$(QUIET)$(INSTALL) -m 0644 $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxguest    $(SOLARIS64_INST_DIR)/vboxguest
 	@#$(QUIET)$(if $(VBOX_DO_STRIP),strip $(SOLARIS_INST_DIR)/vboxguest,)
-	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_BIN)/additions/VBoxClient                                      $(SOLARIS_INST_DIR)/VBoxClient
-	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_BIN)/additions/VBoxService                                     $(SOLARIS_INST_DIR)/VBoxService
-	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_BIN)/additions/VBoxControl                                     $(SOLARIS_INST_DIR)/VBoxControl
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxvideo_drv_13.so                                       $(SOLARIS_INST_DIR)/vboxvideo_drv_13.so
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxvideo_drv_14.so                                       $(SOLARIS_INST_DIR)/vboxvideo_drv_14.so
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxvideo_drv_70.so                                       $(SOLARIS_INST_DIR)/vboxvideo_drv_70.so
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxvideo_drv_71.so                                       $(SOLARIS_INST_DIR)/vboxvideo_drv_71.so
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxmouse_drv_14.so                                       $(SOLARIS_INST_DIR)/vboxmouse_drv_14.so
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxmouse_drv_70.so                                       $(SOLARIS_INST_DIR)/vboxmouse_drv_70.so
-	$(QUIET)$(BIN_COPY) $(PATH_BIN)/additions/vboxmouse_drv_71.so                                       $(SOLARIS_INST_DIR)/vboxmouse_drv_71.so
+	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/VBoxClient  $(SOLARIS_INST_DIR)/VBoxClient
+	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/VBoxService $(SOLARIS_INST_DIR)/VBoxService
+	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/VBoxControl $(SOLARIS_INST_DIR)/VBoxControl
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_13.so   $(SOLARIS_INST_DIR)/vboxvideo_drv_13.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_14.so   $(SOLARIS_INST_DIR)/vboxvideo_drv_14.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_70.so   $(SOLARIS_INST_DIR)/vboxvideo_drv_70.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_71.so   $(SOLARIS_INST_DIR)/vboxvideo_drv_71.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_14.so   $(SOLARIS_INST_DIR)/vboxmouse_drv_14.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_70.so   $(SOLARIS_INST_DIR)/vboxmouse_drv_70.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.x86/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_71.so   $(SOLARIS_INST_DIR)/vboxmouse_drv_71.so
+	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/VBoxClient    $(SOLARIS64_INST_DIR)/VBoxClient
+	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/VBoxService   $(SOLARIS64_INST_DIR)/VBoxService
+	$(QUIET)$(INSTALL) -s -m 0755 $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/VBoxControl   $(SOLARIS64_INST_DIR)/VBoxControl
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_13.so $(SOLARIS64_INST_DIR)/vboxvideo_drv_13.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_14.so $(SOLARIS64_INST_DIR)/vboxvideo_drv_14.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_70.so $(SOLARIS64_INST_DIR)/vboxvideo_drv_70.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxvideo_drv_71.so $(SOLARIS64_INST_DIR)/vboxvideo_drv_71.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_14.so $(SOLARIS64_INST_DIR)/vboxmouse_drv_14.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_70.so $(SOLARIS64_INST_DIR)/vboxmouse_drv_70.so
+	$(QUIET)$(BIN_COPY) $(PATH_OUT_BASE)/solaris.amd64/$(KBUILD_TYPE)/bin/additions/vboxmouse_drv_71.so $(SOLARIS64_INST_DIR)/vboxmouse_drv_71.so
 	$(QUIET)$(INSTALL) -m 0644 $(VBOX_PATH_SOLARIS_ADDITION_INSTALLER)/vboxdevlink.sed                  $(SOLARIS_INST_DIR)/etc/devlink.tab
+	$(QUIET)$(INSTALL) -m 0644 $(VBOX_PATH_SOLARIS_ADDITION_INSTALLER)/VBox.sh                          $(SOLARIS_INST_DIR)/VBox.sh
 	$(call MSG_L1,Creating install package: $@)
-	$(QUIET)$(SOLARIS_INST_DIR)/makepackage.sh $(SOLARIS_INST_DIR) $(PKGFILENAME) $(KBUILD_TARGET_ARCH)
+	$(QUIET)$(SOLARIS_INST_DIR)/makepackage.sh $(SOLARIS_INST_DIR) $(PKGFILENAME)
 	$(QUIET)$(INSTALL) -m 0644 $(SOLARIS_INST_DIR)/$(PKGFILENAME) $(PATH_BIN)/additions/$(PKGFILENAME)
 
diff -urN VirtualBox-2.0.0/src/VBox/Additions/WINNT/VBoxGuest/VBoxGuest.cpp vbox/src/VBox/Additions/WINNT/VBoxGuest/VBoxGuest.cpp
--- VirtualBox-2.0.0/src/VBox/Additions/WINNT/VBoxGuest/VBoxGuest.cpp	2008-09-08 10:06:27.000000000 +0200
+++ vbox/src/VBox/Additions/WINNT/VBoxGuest/VBoxGuest.cpp	2008-09-08 10:07:16.000000000 +0200
@@ -1005,11 +1005,13 @@
 #ifdef VBOX_WITH_VRDP_SESSION_HANDLING
         case VBOXGUEST_IOCTL_ENABLE_VRDP_SESSION:
         {
+            LogRel(("VRDP_SESSION: Enable. Currently: %sabled\n", pDevExt->fVRDPEnabled? "en": "dis"));
             if (!pDevExt->fVRDPEnabled)
             {
                 KUSER_SHARED_DATA *pSharedUserData = (KUSER_SHARED_DATA *)KI_USER_SHARED_DATA;
 
                 pDevExt->fVRDPEnabled            = TRUE;
+                LogRel(("VRDP_SESSION: Current active console id: 0x%08X\n", pSharedUserData->ActiveConsoleId));
                 pDevExt->ulOldActiveConsoleId    = pSharedUserData->ActiveConsoleId;
                 pSharedUserData->ActiveConsoleId = 2;
             }
@@ -1018,11 +1020,13 @@
 
         case VBOXGUEST_IOCTL_DISABLE_VRDP_SESSION:
         {
+            LogRel(("VRDP_SESSION: Disable. Currently: %sabled\n", pDevExt->fVRDPEnabled? "en": "dis"));
             if (pDevExt->fVRDPEnabled)
             {
                 KUSER_SHARED_DATA *pSharedUserData = (KUSER_SHARED_DATA *)KI_USER_SHARED_DATA;
 
                 pDevExt->fVRDPEnabled            = FALSE;
+                LogRel(("VRDP_SESSION: Current active console id: 0x%08X\n", pSharedUserData->ActiveConsoleId));
                 pSharedUserData->ActiveConsoleId = pDevExt->ulOldActiveConsoleId;
                 pDevExt->ulOldActiveConsoleId    = 0;
             }
diff -urN VirtualBox-2.0.0/src/VBox/Devices/Makefile.kmk vbox/src/VBox/Devices/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/Devices/Makefile.kmk	2008-09-08 10:06:32.000000000 +0200
+++ vbox/src/VBox/Devices/Makefile.kmk	2008-09-08 10:07:20.000000000 +0200
@@ -77,13 +77,10 @@
 	Storage/VBoxHDD-new.cpp \
 	Storage/VDICore.cpp \
 	Storage/VDIHDDCore.cpp \
+	Storage/VHDHDDCore.cpp \
 	Storage/VmdkHDDCore.cpp \
 	Storage/RawHDDCore.cpp \
 	VBoxDDUDeps.cpp
-ifndef VBOX_OSE
-VBoxDDU_SOURCES         += \
-	Storage/VHDHDDCore.cpp
-endif
 ifdef VBOX_WITH_USB
  VBoxDDU_INCS.os2       += \
 	$(PATH_ROOT)/src/VBox/HostDrivers/VBoxUSB/os2
@@ -195,14 +192,6 @@
 VBoxDD_LDFLAGS.l4       = -Wl,--no-undefined
 
 
-ifneq ($(int-ge $(KMK_REVISION),1692),1) ## @todo remove this after updating kBuild the next time.
-ifeq ($(KBUILD_TARGET),win)
-$(PATH_LIB)/VBoxDD2.lib: $(PATH_BIN)/VBoxDD2.dll
-$(PATH_LIB)/VBoxDDU.lib: $(PATH_BIN)/VBoxDDU.dll
-endif
-endif
-
-
 #
 # VBoxDD2 (shared object)
 #
diff -urN VirtualBox-2.0.0/src/VBox/Devices/PC/DevPcBios.cpp vbox/src/VBox/Devices/PC/DevPcBios.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/PC/DevPcBios.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Devices/PC/DevPcBios.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -85,6 +85,10 @@
  *          0x50 - 0x57
  *     Fourth Sata HDD:
  *          0x58 - 0x5f
+ *     Number of CPUs:
+ *          0x60
+ *     RAM above 4G (in 64K units):
+ *          0x61 - 0x63
  */
 
 
diff -urN VirtualBox-2.0.0/src/VBox/Devices/Storage/DrvHostDVD.cpp vbox/src/VBox/Devices/Storage/DrvHostDVD.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/Storage/DrvHostDVD.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Devices/Storage/DrvHostDVD.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -542,7 +542,7 @@
             Log2(("%s: error status. rc=%Rrc\n", __FUNCTION__, rc));
         }
         else
-            *pbStat = 0;
+            *pbStat = SCSI_SENSE_NONE;
     }
     Log2(("%s: after ioctl: residual buflen=%d original buflen=%d\n", __FUNCTION__, usc.uscsi_resid, usc.uscsi_buflen));
 
@@ -595,7 +595,7 @@
         if (cbReturned > RT_OFFSETOF(struct _REQ, aSense))
             *pbStat = Req.aSense[2] & 0x0f;
         else
-            *pbStat = 0;
+            *pbStat = SCSI_SENSE_NONE;
         /* Windows shares the property of not properly reflecting the actually
          * transferred data size. See above. Assume that everything worked ok. */
         rc = VINF_SUCCESS;
diff -urN VirtualBox-2.0.0/src/VBox/Devices/Storage/RawHDDCore.cpp vbox/src/VBox/Devices/Storage/RawHDDCore.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/Storage/RawHDDCore.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Devices/Storage/RawHDDCore.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -394,7 +394,8 @@
     if (pIfProgress)
     {
         pCbProgress = VDGetInterfaceProgress(pIfProgress);
-        pfnProgress = pCbProgress->pfnProgress;
+        if (pCbProgress)
+            pfnProgress = pCbProgress->pfnProgress;
         pvUser = pIfProgress->pvUser;
     }
 
diff -urN VirtualBox-2.0.0/src/VBox/Devices/Storage/VBoxHDD-new.cpp vbox/src/VBox/Devices/Storage/VBoxHDD-new.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/Storage/VBoxHDD-new.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Devices/Storage/VBoxHDD-new.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -121,9 +121,7 @@
 extern VBOXHDDBACKEND g_RawBackend;
 extern VBOXHDDBACKEND g_VmdkBackend;
 extern VBOXHDDBACKEND g_VDIBackend;
-#ifndef VBOX_OSE
 extern VBOXHDDBACKEND g_VhdBackend;
-#endif
 #ifdef VBOX_WITH_ISCSI
 extern VBOXHDDBACKEND g_ISCSIBackend;
 #endif
@@ -133,9 +131,7 @@
     &g_RawBackend,
     &g_VmdkBackend,
     &g_VDIBackend,
-#ifndef VBOX_OSE
     &g_VhdBackend,
-#endif
 #ifdef VBOX_WITH_ISCSI
     &g_ISCSIBackend,
 #endif
@@ -1508,7 +1504,7 @@
         }
     }
 
-    if (RT_SUCCESS(rc) && pCbProgress->pfnProgress)
+    if (RT_SUCCESS(rc) && pCbProgress && pCbProgress->pfnProgress)
         pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */, 100,
                                  pIfProgress->pvUser);
 
@@ -1703,7 +1699,7 @@
         }
     }
 
-    if (RT_SUCCESS(rc) && pCbProgress->pfnProgress)
+    if (RT_SUCCESS(rc) && pCbProgress && pCbProgress->pfnProgress)
         pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */, 100,
                                  pIfProgress->pvUser);
 
@@ -1829,7 +1825,7 @@
                 uOffset += cbThisRead;
                 cbRemaining -= cbThisRead;
 
-                if (pCbProgress->pfnProgress)
+                if (pCbProgress && pCbProgress->pfnProgress)
                 {
                     rc = pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */,
                                                   uOffset * 99 / cbSize,
@@ -1878,7 +1874,7 @@
                 uOffset += cbThisRead;
                 cbRemaining -= cbThisRead;
 
-                if (pCbProgress->pfnProgress)
+                if (pCbProgress && pCbProgress->pfnProgress)
                 {
                     rc = pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */,
                                                   uOffset * 99 / cbSize,
@@ -1946,7 +1942,7 @@
     if (pvBuf)
         RTMemTmpFree(pvBuf);
 
-    if (RT_SUCCESS(rc) && pCbProgress->pfnProgress)
+    if (RT_SUCCESS(rc) && pCbProgress && pCbProgress->pfnProgress)
         pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */, 100,
                                  pIfProgress->pvUser);
 
@@ -2150,7 +2146,7 @@
             uOffset += cbThisRead;
             cbRemaining -= cbThisRead;
 
-            if (pCbProgress->pfnProgress)
+            if (pCbProgress && pCbProgress->pfnProgress)
             {
                 rc = pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */,
                                               uOffset * 99 / cbSize,
@@ -2215,7 +2211,7 @@
 
     if (RT_SUCCESS(rc))
     {
-        if (pCbProgress->pfnProgress)
+        if (pCbProgress && pCbProgress->pfnProgress)
             pCbProgress->pfnProgress(NULL /* WARNING! pVM=NULL */, 100,
                                      pIfProgress->pvUser);
         if (pDstCbProgress->pfnProgress)
diff -urN VirtualBox-2.0.0/src/VBox/Devices/Storage/VDIHDDCore.cpp vbox/src/VBox/Devices/Storage/VDIHDDCore.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/Storage/VDIHDDCore.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Devices/Storage/VDIHDDCore.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -833,7 +833,8 @@
     if (pIfProgress)
     {
         pCbProgress = VDGetInterfaceProgress(pIfProgress);
-        pfnProgress = pCbProgress->pfnProgress;
+        if (pCbProgress)
+            pfnProgress = pCbProgress->pfnProgress;
         pvUser = pIfProgress->pvUser;
     }
 
diff -urN VirtualBox-2.0.0/src/VBox/Devices/Storage/VHDHDDCore.cpp vbox/src/VBox/Devices/Storage/VHDHDDCore.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/Storage/VHDHDDCore.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vbox/src/VBox/Devices/Storage/VHDHDDCore.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -0,0 +1,1866 @@
+/** @file
+ * VHD Disk image, Core Code.
+ */
+
+/*
+ * Copyright (C) 2006-2008 Sun Microsystems, Inc.
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 USA or visit http://www.sun.com if you need
+ * additional information or have any questions.
+ */
+
+/*******************************************************************************
+*   Header Files                                                               *
+*******************************************************************************/
+#define LOG_GROUP LOG_GROUP_VD_VHD
+#include "VBoxHDD-newInternal.h"
+#include <VBox/err.h>
+
+#include <VBox/log.h>
+#include <VBox/version.h>
+#include <iprt/cdefs.h>
+#include <iprt/assert.h>
+#include <iprt/alloc.h>
+#include <iprt/uuid.h>
+#include <iprt/file.h>
+#include <iprt/path.h>
+#include <iprt/string.h>
+#include <iprt/rand.h>
+
+#define VHD_RELATIVE_MAX_PATH 512
+#define VHD_ABSOLUTE_MAX_PATH 512
+
+#define VHD_SECTOR_SIZE 512
+#define VHD_BLOCK_SIZE  0x00200000
+
+/* This is common to all VHD disk types and is located at the end of the image */
+#pragma pack(1)
+typedef struct VHDFooter {
+    char     Cookie[8];
+    uint32_t Features;
+    uint32_t Version;
+    uint64_t DataOffset;
+    uint32_t TimeStamp;
+    uint8_t  CreatorApp[4];
+    uint32_t CreatorVer;
+    uint32_t CreatorOS;
+    uint64_t OrigSize;
+    uint64_t CurSize;
+    uint16_t DiskGeometryCylinder;
+    uint8_t  DiskGeometryHeads;
+    uint8_t  DiskGeometrySectors;
+    uint32_t DiskType;
+    uint32_t Checksum;
+    char     UniqueID[16];
+    uint8_t  SavedState;
+    uint8_t  Reserved[427];
+} VHDFooter;
+#pragma pack()
+
+#define VHD_FOOTER_COOKIE "conectix"
+#define VHD_FOOTER_COOKIE_SIZE 8
+
+#define VHD_FOOTER_FEATURES_NOT_ENABLED   0
+#define VHD_FOOTER_FEATURES_TEMPORARY     1
+#define VHD_FOOTER_FEATURES_RESERVED      2
+
+#define VHD_FOOTER_FILE_FORMAT_VERSION    0x00010000
+#define VHD_FOOTER_DATA_OFFSET_FIXED      UINT64_C(0xffffffffffffffff)
+#define VHD_FOOTER_DISK_TYPE_FIXED        2
+#define VHD_FOOTER_DISK_TYPE_DYNAMIC      3
+#define VHD_FOOTER_DISK_TYPE_DIFFERENCING 4
+
+#define VHD_MAX_LOCATOR_ENTRIES           8
+#define VHD_PLATFORM_CODE_NONE            0
+#define VHD_PLATFORM_CODE_WI2R            0x57693272
+#define VHD_PLATFORM_CODE_WI2K            0x5769326B
+#define VHD_PLATFORM_CODE_W2RU            0x57327275
+#define VHD_PLATFORM_CODE_W2KU            0x57326B75
+#define VHD_PLATFORM_CODE_MAC             0x4D163220
+#define VHD_PLATFORM_CODE_MACX            0x4D163258
+
+/* Header for expanding disk images. */
+#pragma pack(1)
+typedef struct VHDParentLocatorEntry
+{
+    uint32_t u32Code;
+    uint32_t u32DataSpace;
+    uint32_t u32DataLength;
+    uint32_t u32Reserved;
+    uint64_t u64DataOffset;
+} VHDPLE, *PVHDPLE;
+
+typedef struct VHDDynamicDiskHeader
+{
+    char     Cookie[8];
+    uint64_t DataOffset;
+    uint64_t TableOffset;
+    uint32_t HeaderVersion;
+    uint32_t MaxTableEntries;
+    uint32_t BlockSize;
+    uint32_t Checksum;
+    uint8_t  ParentUuid[16];
+    uint32_t ParentTimeStamp;
+    uint32_t Reserved0;
+    uint8_t  ParentUnicodeName[512];
+    VHDPLE   ParentLocatorEntry[VHD_MAX_LOCATOR_ENTRIES];
+    uint8_t  Reserved1[256];
+} VHDDynamicDiskHeader;
+#pragma pack()
+
+#define VHD_DYNAMIC_DISK_HEADER_COOKIE "cxsparse"
+#define VHD_DYNAMIC_DISK_HEADER_COOKIE_SIZE 8
+#define VHD_DYNAMIC_DISK_HEADER_VERSION 0x00010000
+
+/**
+ * Complete VHD image data structure.
+ */
+typedef struct VHDIMAGE
+{
+    /** Base image name. */
+    const char      *pszFilename;
+    /** Descriptor file if applicable. */
+    RTFILE          File;
+
+    /** Pointer to the per-disk VD interface list. */
+    PVDINTERFACE      pVDIfsDisk;
+    /** Error interface. */
+    PVDINTERFACE      pInterfaceError;
+    /** Error interface callback table. */
+    PVDINTERFACEERROR pInterfaceErrorCallbacks;
+
+    /** Open flags passed by VBoxHD layer. */
+    unsigned        uOpenFlags;
+    /** Image type. */
+    VDIMAGETYPE     enmImageType;
+    /** Image flags defined during creation or determined during open. */
+    unsigned        uImageFlags;
+    /** Total size of the image. */
+    uint64_t        cbSize;
+    /** Original size of the image. */
+    uint64_t        cbOrigSize;
+    /** Physical geometry of this image. */
+    PDMMEDIAGEOMETRY    PCHSGeometry;
+    /** Logical geometry of this image. */
+    PDMMEDIAGEOMETRY    LCHSGeometry;
+    /** Image UUID. */
+    RTUUID          ImageUuid;
+    /** Parent image UUID. */
+    RTUUID          ParentUuid;
+    /** Parent's time stamp at the time of image creation. */
+    uint32_t        u32ParentTimeStamp;
+    /** Relative path to the parent image. */
+    char            *pszParentFilename;
+    /** File size on the host disk (including all headers). */
+    uint64_t        FileSize;
+    /** The Block Allocation Table. */
+    uint32_t        *pBlockAllocationTable;
+    /** Number of entries in the table. */
+    uint32_t        cBlockAllocationTableEntries;
+    /** Size of one data block. */
+    uint32_t        cbDataBlock;
+    /** Sectors per data block. */
+    uint32_t        cSectorsPerDataBlock;
+    /** Length of the sector bitmap in bytes. */
+    uint32_t        cbDataBlockBitmap;
+    /** A copy of the disk footer. */
+    VHDFooter       vhdFooterCopy;
+    /** Current end offset of the file (without the disk footer). */
+    uint64_t        uCurrentEndOfFile;
+    /** Start offset of data blocks. */
+    uint64_t        uDataBlockStart;
+    /** Size of the data block bitmap in sectors. */
+    uint32_t        cDataBlockBitmapSectors;
+    /** Start of the block allocation table. */
+    uint64_t        uBlockAllocationTableOffset;
+    /** Buffer to hold block's bitmap for bit search operations. */
+    void            *pvBitmap;
+    /** Offset to the next data structure (dynamic disk header). */
+    uint64_t        u64DataOffset;
+    /** Flag to force dynamic disk header update. */
+    bool            fDynHdrNeedsUpdate;
+} VHDIMAGE, *PVHDIMAGE;
+
+/*******************************************************************************
+*   Static Variables                                                           *
+*******************************************************************************/
+
+/** NULL-terminated array of supported file extensions. */
+static const char *const s_apszVhdFileExtensions[] =
+{
+    "vhd",
+    NULL
+};
+
+/*******************************************************************************
+*   Internal Functions                                                         *
+*******************************************************************************/
+
+static int vhdFlush(void *pBackendData);
+static int vhdLoadDynamicDisk(PVHDIMAGE pImage, uint64_t uDynamicDiskHeaderOffset);
+
+/* 946684800 is a number of seconds between 1/1/1970 and 1/1/2000 */
+#define VHD_TO_UNIX_EPOCH_SECONDS UINT64_C(946684800)
+
+static uint32_t vhdRtTime2VhdTime(PCRTTIMESPEC pRtTimeStamp)
+{
+    uint64_t u64Seconds = RTTimeSpecGetSeconds(pRtTimeStamp);
+    return (uint32_t)(u64Seconds - VHD_TO_UNIX_EPOCH_SECONDS);
+}
+
+static void vhdTime2RtTime(PRTTIMESPEC pRtTimeStamp, uint32_t u32VhdTimeStamp)
+{
+    RTTimeSpecSetSeconds(pRtTimeStamp, VHD_TO_UNIX_EPOCH_SECONDS + u32VhdTimeStamp);
+}
+
+/**
+ * Internal: Compute and update header checksum.
+ */
+static uint32_t vhdChecksum(void *pHeader, uint32_t cbSize)
+{
+    uint32_t checksum = 0;
+    for (uint32_t i = 0; i < cbSize; i++)
+        checksum += ((unsigned char *)pHeader)[i];
+    return ~checksum;
+}
+
+static int vhdFilenameToUtf16(const char *pszFilename, void *pvBuf, uint32_t cbBufSize, uint32_t *pcbActualSize)
+{
+    int      rc;
+    PRTUTF16 tmp16 = NULL;
+    size_t   cTmp16Len;
+
+    rc = RTStrToUtf16(pszFilename, &tmp16);
+    if (RT_FAILURE(rc))
+        goto out;
+    cTmp16Len = RTUtf16Len(tmp16);
+    if (cTmp16Len * sizeof(*tmp16) > cbBufSize)
+    {
+        rc = VERR_FILENAME_TOO_LONG;
+        goto out;
+    }
+    memcpy(pvBuf, tmp16, cTmp16Len * sizeof(*tmp16));
+    if (pcbActualSize)
+        *pcbActualSize = cTmp16Len * sizeof(*tmp16);
+
+out:
+    if (tmp16)
+        RTUtf16Free(tmp16);
+    return rc;
+}
+
+/**
+ * Internal: Update one locator entry.
+ */
+static int vhdLocatorUpdate(PVHDIMAGE pImage, PVHDPLE pLocator, const char *pszFilename)
+{
+    int      rc;
+    uint32_t cb, cbMaxLen = RT_BE2H_U32(pLocator->u32DataSpace) * VHD_SECTOR_SIZE;
+    void     *pvBuf = RTMemTmpAllocZ(cbMaxLen);
+    char     *pszTmp;
+
+    if (!pvBuf)
+    {
+        rc = VERR_NO_MEMORY;
+        goto out;
+    }
+
+    switch (RT_BE2H_U32(pLocator->u32Code))
+    {
+        case VHD_PLATFORM_CODE_WI2R:
+            /* Update plain relative name. */
+            cb = strlen(pszFilename);
+            if (cb > cbMaxLen)
+            {
+                rc = VERR_FILENAME_TOO_LONG;
+                goto out;
+            }
+            memcpy(pvBuf, pszFilename, cb);
+            pLocator->u32DataLength = RT_H2BE_U32(cb);
+            break;
+        case VHD_PLATFORM_CODE_WI2K:
+            /* Update plain absolute name. */
+            rc = RTPathAbs(pszFilename, (char *)pvBuf, cbMaxLen);
+            if (RT_FAILURE(rc))
+                goto out;
+            pLocator->u32DataLength = RT_H2BE_U32(strlen((char *)pvBuf));
+            break;
+        case VHD_PLATFORM_CODE_W2RU:
+            /* Update unicode relative name. */
+            rc = vhdFilenameToUtf16(pszFilename, pvBuf, cbMaxLen, &cb);
+            if (RT_FAILURE(rc))
+                goto out;
+            pLocator->u32DataLength = RT_H2BE_U32(cb);
+            break;
+        case VHD_PLATFORM_CODE_W2KU:
+            /* Update unicode absolute name. */
+            pszTmp = (char*)RTMemTmpAllocZ(cbMaxLen);
+            if (!pvBuf)
+            {
+                rc = VERR_NO_MEMORY;
+                goto out;
+            }
+            rc = RTPathAbs(pszFilename, pszTmp, cbMaxLen);
+            if (RT_FAILURE(rc))
+            {
+                RTMemTmpFree(pszTmp);
+                goto out;
+            }
+            rc = vhdFilenameToUtf16(pszTmp, pvBuf, cbMaxLen, &cb);
+            RTMemTmpFree(pszTmp);
+            if (RT_FAILURE(rc))
+                goto out;
+            pLocator->u32DataLength = RT_H2BE_U32(cb);
+            break;
+        default:
+            rc = VERR_NOT_IMPLEMENTED;
+            goto out;
+    }
+    rc = RTFileWriteAt(pImage->File, RT_BE2H_U64(pLocator->u64DataOffset), pvBuf,
+        RT_BE2H_U32(pLocator->u32DataSpace) * VHD_SECTOR_SIZE, NULL);
+
+out:
+    if (pvBuf)
+        RTMemTmpFree(pvBuf);
+    return rc;
+}
+
+/**
+ * Internal: Update dynamic disk header from VHDIMAGE.
+ */
+static int vhdDynamicHeaderUpdate(PVHDIMAGE pImage)
+{
+    VHDDynamicDiskHeader ddh;
+    int rc, i;
+
+    if (!pImage)
+        return VERR_VDI_NOT_OPENED;
+
+    rc = RTFileReadAt(pImage->File, pImage->u64DataOffset, &ddh, sizeof(ddh), NULL);
+    if (RT_FAILURE(rc))
+        return rc;
+    if (memcmp(ddh.Cookie, VHD_DYNAMIC_DISK_HEADER_COOKIE, VHD_DYNAMIC_DISK_HEADER_COOKIE_SIZE) != 0)
+    {
+        return VERR_VDI_INVALID_HEADER;
+    }
+    uint32_t u32Checksum = RT_BE2H_U32(ddh.Checksum);
+    ddh.Checksum = 0;
+    if (u32Checksum != vhdChecksum(&ddh, sizeof(ddh)))
+    {
+        return VERR_VDI_INVALID_HEADER;
+    }
+    /* Update parent's timestamp. */
+    ddh.ParentTimeStamp = RT_H2BE_U32(pImage->u32ParentTimeStamp);
+    /* Update parent's filename. */
+    rc = vhdFilenameToUtf16(RTPathFilename(pImage->pszParentFilename),
+        ddh.ParentUnicodeName, sizeof(ddh.ParentUnicodeName) - 1, NULL);
+    if (RT_FAILURE(rc))
+        return rc;
+    /* Update parent's locators. */
+    for (i = 0; i < VHD_MAX_LOCATOR_ENTRIES; i++)
+    {
+        /* Skip empty locators */
+        if (ddh.ParentLocatorEntry[i].u32Code != RT_H2BE_U32(VHD_PLATFORM_CODE_NONE))
+        {
+            rc = vhdLocatorUpdate(pImage, &ddh.ParentLocatorEntry[i], pImage->pszParentFilename);
+            if (RT_FAILURE(rc))
+                goto out;
+        }
+    }
+    /* Update parent's UUID */
+    memcpy(ddh.ParentUuid, pImage->ParentUuid.au8, sizeof(ddh.ParentUuid));
+    ddh.Checksum = 0;
+    ddh.Checksum = RT_H2BE_U32(vhdChecksum(&ddh, sizeof(ddh)));
+    rc = RTFileWriteAt(pImage->File, pImage->u64DataOffset, &ddh, sizeof(ddh), NULL);
+
+out:
+    return rc;
+}
+
+
+static int vhdOpenImage(PVHDIMAGE pImage, unsigned uOpenFlags)
+{
+    RTFILE File;
+    uint64_t FileSize;
+    VHDFooter vhdFooter;
+
+    if (uOpenFlags & VD_OPEN_FLAGS_ASYNC_IO)
+        return VERR_NOT_SUPPORTED;
+
+    pImage->uOpenFlags = uOpenFlags;
+
+    pImage->pInterfaceError = VDInterfaceGet(pImage->pVDIfsDisk, VDINTERFACETYPE_ERROR);
+    if (pImage->pInterfaceError)
+        pImage->pInterfaceErrorCallbacks = VDGetInterfaceError(pImage->pInterfaceError);
+
+    /*
+     * Open the image.
+     */
+    int rc = RTFileOpen(&File, pImage->pszFilename, uOpenFlags & VD_OPEN_FLAGS_READONLY
+                    ? RTFILE_O_READ      | RTFILE_O_OPEN | RTFILE_O_DENY_NONE
+                    : RTFILE_O_READWRITE | RTFILE_O_OPEN | RTFILE_O_DENY_WRITE);
+    if (RT_FAILURE(rc))
+    {
+        /* Do NOT signal an appropriate error here, as the VD layer has the
+         * choice of retrying the open if it failed. */
+        return rc;
+    }
+    pImage->File = File;
+
+    rc = RTFileGetSize(File, &FileSize);
+    pImage->FileSize = FileSize;
+    pImage->uCurrentEndOfFile = FileSize - sizeof(VHDFooter);
+
+    rc = RTFileReadAt(File, pImage->uCurrentEndOfFile, &vhdFooter, sizeof(VHDFooter), NULL);
+    if (memcmp(vhdFooter.Cookie, VHD_FOOTER_COOKIE, VHD_FOOTER_COOKIE_SIZE) != 0) {
+        return VERR_VDI_INVALID_HEADER;
+    }
+
+    switch (RT_BE2H_U32(vhdFooter.DiskType))
+    {
+        case VHD_FOOTER_DISK_TYPE_FIXED:
+            {
+                pImage->enmImageType = VD_IMAGE_TYPE_FIXED;
+            }
+            break;
+        case VHD_FOOTER_DISK_TYPE_DYNAMIC:
+            {
+                pImage->enmImageType = VD_IMAGE_TYPE_NORMAL;
+            }
+            break;
+        case VHD_FOOTER_DISK_TYPE_DIFFERENCING:
+            {
+                pImage->enmImageType = VD_IMAGE_TYPE_DIFF;
+            }
+            break;
+        default:
+            return VERR_NOT_IMPLEMENTED;
+    }
+
+    pImage->cbSize       = RT_BE2H_U64(vhdFooter.CurSize);
+    pImage->LCHSGeometry.cCylinders   = 0;
+    pImage->LCHSGeometry.cHeads       = 0;
+    pImage->LCHSGeometry.cSectors     = 0;
+    pImage->PCHSGeometry.cCylinders   = RT_BE2H_U16(vhdFooter.DiskGeometryCylinder);
+    pImage->PCHSGeometry.cHeads       = vhdFooter.DiskGeometryHeads;
+    pImage->PCHSGeometry.cSectors     = vhdFooter.DiskGeometrySectors;
+
+    /*
+     * Copy of the disk footer.
+     * If we allocate new blocks in differencing disks on write access
+     * the footer is overwritten. We need to write it at the end of the file.
+     */
+    memcpy(&pImage->vhdFooterCopy, &vhdFooter, sizeof(VHDFooter));
+
+    /*
+     * Is there a better way?
+     */
+    memcpy(&pImage->ImageUuid, &vhdFooter.UniqueID, 16);
+
+    pImage->u64DataOffset = RT_BE2H_U64(vhdFooter.DataOffset);
+    LogFlow(("%s: DataOffset=%llu\n", __FUNCTION__, pImage->u64DataOffset));
+
+    if (pImage->enmImageType == VD_IMAGE_TYPE_NORMAL || pImage->enmImageType == VD_IMAGE_TYPE_DIFF)
+        rc = vhdLoadDynamicDisk(pImage, pImage->u64DataOffset);
+
+    return rc;
+}
+
+static int vhdOpen(const char *pszFilename, unsigned uOpenFlags,
+                   PVDINTERFACE pVDIfsDisk, PVDINTERFACE pVDIfsImage,
+                   void **ppvBackendData)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage;
+
+    /* Check open flags. All valid flags are supported. */
+    if (uOpenFlags & ~VD_OPEN_FLAGS_MASK)
+    {
+        rc = VERR_INVALID_PARAMETER;
+        return rc;
+    }
+
+    pImage = (PVHDIMAGE)RTMemAllocZ(sizeof(VHDIMAGE));
+    if (!pImage)
+    {
+        rc = VERR_NO_MEMORY;
+        return rc;
+    }
+    pImage->pszFilename = pszFilename;
+    pImage->File = NIL_RTFILE;
+    pImage->pVDIfsDisk = pVDIfsDisk;
+
+    rc = vhdOpenImage(pImage, uOpenFlags);
+    if (RT_SUCCESS(rc))
+        *ppvBackendData = pImage;
+    return rc;
+}
+
+static int vhdLoadDynamicDisk(PVHDIMAGE pImage, uint64_t uDynamicDiskHeaderOffset)
+{
+    VHDDynamicDiskHeader vhdDynamicDiskHeader;
+    int rc = VINF_SUCCESS;
+    uint32_t *pBlockAllocationTable;
+    uint64_t uBlockAllocationTableOffset;
+    unsigned i = 0;
+
+    Log(("Open a dynamic disk.\n"));
+
+    /*
+     * Read the dynamic disk header.
+     */
+    rc = RTFileReadAt(pImage->File, uDynamicDiskHeaderOffset, &vhdDynamicDiskHeader, sizeof(VHDDynamicDiskHeader), NULL);
+    if (memcmp(vhdDynamicDiskHeader.Cookie, VHD_DYNAMIC_DISK_HEADER_COOKIE, VHD_DYNAMIC_DISK_HEADER_COOKIE_SIZE) != 0)
+        return VERR_INVALID_PARAMETER;
+
+    pImage->cbDataBlock = RT_BE2H_U32(vhdDynamicDiskHeader.BlockSize);
+    LogFlow(("%s: BlockSize=%u\n", __FUNCTION__, pImage->cbDataBlock));
+    pImage->cBlockAllocationTableEntries = RT_BE2H_U32(vhdDynamicDiskHeader.MaxTableEntries);
+    LogFlow(("%s: MaxTableEntries=%lu\n", __FUNCTION__, pImage->cBlockAllocationTableEntries));
+    AssertMsg(!(pImage->cbDataBlock % 512), ("%s: Data block size is not a multiple of 512!!\n", __FUNCTION__));
+
+    pImage->cSectorsPerDataBlock = pImage->cbDataBlock / 512;
+    LogFlow(("%s: SectorsPerDataBlock=%u\n", __FUNCTION__, pImage->cSectorsPerDataBlock));
+
+    /*
+     * Every block starts with a bitmap indicating which sectors are valid and which are not.
+     * We store the size of it to be able to calculate the real offset.
+     */
+    pImage->cbDataBlockBitmap = pImage->cSectorsPerDataBlock / 8;
+    pImage->cDataBlockBitmapSectors = pImage->cbDataBlockBitmap / 512;
+    LogFlow(("%s: cbDataBlockBitmap=%u\n", __FUNCTION__, pImage->cbDataBlockBitmap));
+
+    pImage->pvBitmap = RTMemAllocZ(pImage->cbDataBlockBitmap);
+    if (!pImage->pvBitmap)
+        return VERR_NO_MEMORY;
+
+    pBlockAllocationTable = (uint32_t *)RTMemAllocZ(pImage->cBlockAllocationTableEntries * sizeof(uint32_t));
+    if (!pBlockAllocationTable)
+        return VERR_NO_MEMORY;
+
+    /*
+     * Read the table.
+     */
+    uBlockAllocationTableOffset = RT_BE2H_U64(vhdDynamicDiskHeader.TableOffset);
+    LogFlow(("%s: uBlockAllocationTableOffset=%llu\n", __FUNCTION__, uBlockAllocationTableOffset));
+    pImage->uBlockAllocationTableOffset = uBlockAllocationTableOffset;
+    rc = RTFileReadAt(pImage->File, uBlockAllocationTableOffset, pBlockAllocationTable, pImage->cBlockAllocationTableEntries * sizeof(uint32_t), NULL);
+    pImage->uDataBlockStart = uBlockAllocationTableOffset + pImage->cBlockAllocationTableEntries * sizeof(uint32_t);
+    LogFlow(("%s: uDataBlockStart=%llu\n", __FUNCTION__, pImage->uDataBlockStart));
+
+    /*
+     * Because the offset entries inside the allocation table are stored big endian
+     * we need to convert them into host endian.
+     */
+    pImage->pBlockAllocationTable = (uint32_t *)RTMemAllocZ(pImage->cBlockAllocationTableEntries * sizeof(uint32_t));
+    if (!pImage->pBlockAllocationTable)
+        return VERR_NO_MEMORY;
+
+    for (i = 0; i < pImage->cBlockAllocationTableEntries; i++)
+    {
+        pImage->pBlockAllocationTable[i] = RT_BE2H_U32(pBlockAllocationTable[i]);
+    }
+
+    RTMemFree(pBlockAllocationTable);
+
+    if (pImage->enmImageType == VD_IMAGE_TYPE_DIFF)
+        memcpy(pImage->ParentUuid.au8, vhdDynamicDiskHeader.ParentUuid, sizeof(pImage->ParentUuid));
+
+    return rc;
+}
+
+static int vhdCheckIfValid(const char *pszFilename)
+{
+    int rc = VINF_SUCCESS;
+    RTFILE File;
+    uint64_t cbFile;
+    VHDFooter vhdFooter;
+
+    rc = RTFileOpen(&File, pszFilename, RTFILE_O_READ | RTFILE_O_OPEN);
+    if (RT_FAILURE(rc))
+        return VERR_VDI_INVALID_HEADER;
+
+    rc = RTFileGetSize(File, &cbFile);
+    if (RT_FAILURE(rc))
+    {
+        RTFileClose(File);
+        return VERR_VDI_INVALID_HEADER;
+    }
+
+    rc = RTFileReadAt(File, cbFile - sizeof(VHDFooter), &vhdFooter, sizeof(VHDFooter), NULL);
+    if (RT_FAILURE(rc) || (memcmp(vhdFooter.Cookie, VHD_FOOTER_COOKIE, VHD_FOOTER_COOKIE_SIZE) != 0))
+    {
+        RTFileClose(File);
+        return VERR_VDI_INVALID_HEADER;
+    }
+
+    /* If we are here the file seems to be valid. */
+    RTFileClose(File);
+
+    return VINF_SUCCESS;
+}
+
+static unsigned vhdGetVersion(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+
+    Assert(pImage);
+
+    if (pImage)
+        return 1; /**< @todo use correct version */
+    else
+        return 0;
+}
+
+static int vhdGetImageType(void *pBackendData, PVDIMAGETYPE penmImageType)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc = VINF_SUCCESS;
+
+    Assert(pImage);
+    Assert(penmImageType);
+
+    if (pImage)
+        *penmImageType = pImage->enmImageType;
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+    return rc;
+}
+
+static int vhdGetPCHSGeometry(void *pBackendData, PPDMMEDIAGEOMETRY pPCHSGeometry)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        if (pImage->PCHSGeometry.cCylinders)
+        {
+            *pPCHSGeometry = pImage->PCHSGeometry;
+            rc = VINF_SUCCESS;
+        }
+        else
+            rc = VERR_VDI_GEOMETRY_NOT_SET;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+    LogFlow(("%s: returned %Rrc (CHS=%u/%u/%u)\n", __FUNCTION__, rc,
+             pImage->PCHSGeometry.cCylinders, pImage->PCHSGeometry.cHeads, pImage->PCHSGeometry.cSectors));
+    return rc;
+}
+
+static int vhdSetPCHSGeometry(void *pBackendData, PCPDMMEDIAGEOMETRY pPCHSGeometry)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        if (pImage->uOpenFlags & VD_OPEN_FLAGS_READONLY)
+        {
+            rc = VERR_VDI_IMAGE_READ_ONLY;
+            goto out;
+        }
+
+        pImage->PCHSGeometry = *pPCHSGeometry;
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+out:
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetLCHSGeometry(void *pBackendData, PPDMMEDIAGEOMETRY pLCHSGeometry)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        if (pImage->LCHSGeometry.cCylinders)
+        {
+            *pLCHSGeometry = pImage->LCHSGeometry;
+            rc = VINF_SUCCESS;
+        }
+        else
+            rc = VERR_VDI_GEOMETRY_NOT_SET;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+    LogFlow(("%s: returned %Rrc (CHS=%u/%u/%u)\n", __FUNCTION__, rc,
+             pImage->LCHSGeometry.cCylinders, pImage->LCHSGeometry.cHeads, pImage->LCHSGeometry.cSectors));
+    return rc;
+}
+
+static int vhdSetLCHSGeometry(void *pBackendData, PCPDMMEDIAGEOMETRY pLCHSGeometry)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        if (pImage->uOpenFlags & VD_OPEN_FLAGS_READONLY)
+        {
+            rc = VERR_VDI_IMAGE_READ_ONLY;
+            goto out;
+        }
+
+        pImage->LCHSGeometry = *pLCHSGeometry;
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+out:
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static unsigned vhdGetImageFlags(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    unsigned uImageFlags;
+
+    Assert(pImage);
+
+    if (pImage)
+        uImageFlags = pImage->uImageFlags;
+    else
+        uImageFlags = 0;
+
+    LogFlow(("%s: returned %#x\n", __FUNCTION__, uImageFlags));
+    return uImageFlags;
+}
+
+static unsigned vhdGetOpenFlags(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    unsigned uOpenFlags;
+
+    Assert(pImage);
+
+    if (pImage)
+        uOpenFlags = pImage->uOpenFlags;
+    else
+        uOpenFlags = 0;
+
+    LogFlow(("%s: returned %d\n", __FUNCTION__, uOpenFlags));
+    return uOpenFlags;
+}
+
+static int vhdSetOpenFlags(void *pBackendData, unsigned uOpenFlags)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    /* Image must be opened and the new flags must be valid. Just readonly flag
+     * is supported. */
+    if (!pImage || uOpenFlags & ~VD_OPEN_FLAGS_READONLY)
+    {
+        rc = VERR_INVALID_PARAMETER;
+        goto out;
+    }
+
+    rc = vhdFlush(pImage);
+    if (RT_FAILURE(rc))
+        goto out;
+    RTFileClose(pImage->File);
+    pImage->uOpenFlags = uOpenFlags;
+    rc = RTFileOpen(&pImage->File, pImage->pszFilename, uOpenFlags & VD_OPEN_FLAGS_READONLY
+            ? RTFILE_O_READ      | RTFILE_O_OPEN | RTFILE_O_DENY_NONE
+            : RTFILE_O_READWRITE | RTFILE_O_OPEN | RTFILE_O_DENY_WRITE);
+
+out:
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdRename(void *pBackendData, const char *pszFilename)
+{
+    return VERR_NOT_IMPLEMENTED;
+}
+
+static int vhdFreeImage(PVHDIMAGE pImage)
+{
+    int rc = VINF_SUCCESS;
+
+    /* Freeing a never allocated image (e.g. because the open failed) is
+     * not signalled as an error. After all nothing bad happens. */
+    if (pImage) {
+        vhdFlush(pImage);
+        RTFileClose(pImage->File);
+        RTMemFree(pImage);
+    }
+
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdClose(void *pBackendData, bool fDelete)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc = VINF_SUCCESS;
+
+    /* Freeing a never allocated image (e.g. because the open failed) is
+     * not signalled as an error. After all nothing bad happens. */
+    if (pImage) {
+        if (pImage->pvBitmap)
+        {
+            RTMemFree(pImage->pvBitmap);
+            pImage->pvBitmap = NULL;
+        }
+        if (fDelete)
+        {
+            /* No point in updating the file that is deleted anyway. */
+            RTFileClose(pImage->File);
+            RTFileDelete(pImage->pszFilename);
+        }
+        else
+            rc = vhdFreeImage(pImage);
+        if (pImage->pszParentFilename)
+            RTStrFree(pImage->pszParentFilename);
+    }
+
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdRead(void *pBackendData, uint64_t uOffset, void *pvBuf, size_t cbRead, size_t *pcbActuallyRead)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc = VINF_SUCCESS;
+
+    LogFlow(("%s: pBackendData=%p uOffset=%llu pvBuf=%p cbRead=%u pcbActuallyRead=%p\n", __FUNCTION__, pBackendData, uOffset, pvBuf, cbRead, pcbActuallyRead));
+
+    if (uOffset + cbRead > pImage->cbSize)
+        return VERR_INVALID_PARAMETER;
+
+    /*
+     * If we have a dynamic disk image, we need to find the data block and sector to read.
+     */
+    if (pImage->pBlockAllocationTable)
+    {
+        /*
+         * Get the data block first.
+         */
+        uint32_t cBlockAllocationTableEntry = (uOffset / 512) / pImage->cSectorsPerDataBlock;
+        uint32_t cBATEntryIndex = (uOffset / 512) % pImage->cSectorsPerDataBlock;
+        uint64_t uVhdOffset;
+
+        LogFlow(("%s: cBlockAllocationTableEntry=%u cBatEntryIndex=%u\n", __FUNCTION__, cBlockAllocationTableEntry, cBATEntryIndex));
+        LogFlow(("%s: BlockAllocationEntry=%u\n", __FUNCTION__, pImage->pBlockAllocationTable[cBlockAllocationTableEntry]));
+
+        /*
+         * If the block is not allocated the content of the entry is ~0
+         */
+        if (pImage->pBlockAllocationTable[cBlockAllocationTableEntry] == ~0U)
+            return VERR_VDI_BLOCK_FREE;
+
+        uVhdOffset = (pImage->pBlockAllocationTable[cBlockAllocationTableEntry] +  pImage->cDataBlockBitmapSectors + cBATEntryIndex) * 512;
+        Log(("%s: uVhdOffset=%llu cbRead=%u\n", __FUNCTION__, uVhdOffset, cbRead));
+
+        /*
+         * Clip read range to remain in this data block.
+         */
+        cbRead = RT_MIN(cbRead, (pImage->cbDataBlock - (cBATEntryIndex * 512)));
+
+        /* Read in the block's bitmap. */
+        rc = RTFileReadAt(pImage->File,
+            pImage->pBlockAllocationTable[cBlockAllocationTableEntry] * VHD_SECTOR_SIZE,
+            pImage->pvBitmap, pImage->cbDataBlockBitmap, NULL);
+        if (RT_SUCCESS(rc))
+        {
+            int cSectors;
+            if (ASMBitTest(pImage->pvBitmap, cBATEntryIndex))
+            {
+                /*
+                 * The first sector being read is marked dirty, read as much as we
+                 * can from child. Note that only sectors that are marked dirty
+                 * must be read from child.
+                 */
+                cSectors = ASMBitNextClear(pImage->pvBitmap, pImage->cSectorsPerDataBlock, cBATEntryIndex);
+                if (cSectors != -1)
+                    cbRead = RT_MIN(cbRead, (cSectors - cBATEntryIndex) * VHD_SECTOR_SIZE);
+                rc = RTFileReadAt(pImage->File, uVhdOffset, pvBuf, cbRead, NULL);
+            }
+            else
+            {
+                /*
+                 * The first sector being read is marked clean, so we should read from
+                 * our parent instead, but only as much as there are the following
+                 * clean sectors, because the block may still contain durty sectors
+                 * further on. We just need to compute the number of clean sectors
+                 * and pass it to our caller along with the notification that they
+                 * should be read from the parent.
+                 */
+                cSectors = ASMBitNextSet(pImage->pvBitmap, pImage->cSectorsPerDataBlock, cBATEntryIndex);
+                if (cSectors != -1)
+                    cbRead = RT_MIN(cbRead, (cSectors - cBATEntryIndex) * VHD_SECTOR_SIZE);
+                rc = VERR_VDI_BLOCK_FREE;
+            }
+        }
+
+    }
+    else
+    {
+        rc = RTFileReadAt(pImage->File, uOffset, pvBuf, cbRead, NULL);
+    }
+
+    if (pcbActuallyRead)
+        *pcbActuallyRead = cbRead;
+
+    return rc;
+}
+
+static int vhdWrite(void *pBackendData, uint64_t uOffset, const void *pvBuf, size_t cbWrite, size_t *pcbWriteProcess, size_t *pcbPreRead, size_t *pcbPostRead, unsigned fWrite)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc = VINF_SUCCESS;
+
+    Assert(uOffset % 512 == 0);
+    Assert(cbWrite % 512 == 0);
+
+    if (pImage->pBlockAllocationTable)
+    {
+        /*
+         * Get the data block first.
+         */
+        uint32_t cSector = uOffset / 512;
+        uint32_t cBlockAllocationTableEntry = cSector / pImage->cSectorsPerDataBlock;
+        uint32_t cBATEntryIndex = cSector % pImage->cSectorsPerDataBlock;
+        uint64_t uVhdOffset;
+
+        /*
+         * If the block is not allocated the content of the entry is ~0
+         * and we need to allocate a new block.
+         */
+        if (pImage->pBlockAllocationTable[cBlockAllocationTableEntry] == ~0U)
+        {
+            size_t  cbNewBlock = (pImage->cbDataBlock + pImage->cbDataBlockBitmap) * sizeof(uint8_t);
+            uint8_t *pNewBlock = (uint8_t *)RTMemAllocZ(cbNewBlock);
+
+            if (!pNewBlock)
+                return VERR_NO_MEMORY;
+
+            /*
+             * Write the new block at the current end of the file.
+             */
+            rc = RTFileWriteAt(pImage->File, pImage->uCurrentEndOfFile, pNewBlock, cbNewBlock, NULL);
+
+            /*
+             * Set the new end of the file and link the new block into the BAT.
+             */
+            pImage->pBlockAllocationTable[cBlockAllocationTableEntry] = pImage->uCurrentEndOfFile / 512;
+            pImage->uCurrentEndOfFile += cbNewBlock;
+            RTMemFree(pNewBlock);
+        }
+
+        /*
+         * Calculate the real offset in the file.
+         */
+        uVhdOffset = (pImage->pBlockAllocationTable[cBlockAllocationTableEntry] + pImage->cDataBlockBitmapSectors + cBATEntryIndex) * 512;
+
+        /*
+         * Clip write range.
+         */
+        cbWrite = RT_MIN(cbWrite, (pImage->cbDataBlock - (cBATEntryIndex * 512)));
+        RTFileWriteAt(pImage->File, uVhdOffset, pvBuf, cbWrite, NULL);
+
+        /* Read in the block's bitmap. */
+        rc = RTFileReadAt(pImage->File,
+            pImage->pBlockAllocationTable[cBlockAllocationTableEntry] * VHD_SECTOR_SIZE,
+            pImage->pvBitmap, pImage->cbDataBlockBitmap, NULL);
+        if (RT_SUCCESS(rc))
+        {
+            /* Set the bits for all sectors having been written. */
+            ASMBitSetRange(pImage->pvBitmap, cBATEntryIndex, cBATEntryIndex + (cbWrite / VHD_SECTOR_SIZE));
+            /* Write the bitmap back. */
+            rc = RTFileWriteAt(pImage->File,
+                pImage->pBlockAllocationTable[cBlockAllocationTableEntry] * VHD_SECTOR_SIZE,
+                pImage->pvBitmap, pImage->cbDataBlockBitmap, NULL);
+        }
+    }
+    else
+    {
+        rc = RTFileWriteAt(pImage->File, uOffset, pvBuf, cbWrite, NULL);
+    }
+
+    if (pcbWriteProcess)
+        *pcbWriteProcess = cbWrite;
+
+    return rc;
+}
+
+static int vhdFlush(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+
+    if (pImage->uOpenFlags & VD_OPEN_FLAGS_READONLY)
+        return VINF_SUCCESS;
+
+    if (pImage->pBlockAllocationTable)
+    {
+        /*
+         * This is an expanding image. Write the BAT and copy of the disk footer.
+         */
+        size_t   cbBlockAllocationTableToWrite = pImage->cBlockAllocationTableEntries * sizeof(uint32_t);
+        uint32_t *pBlockAllocationTableToWrite = (uint32_t *)RTMemAllocZ(cbBlockAllocationTableToWrite);
+
+        if (!pBlockAllocationTableToWrite)
+            return VERR_NO_MEMORY;
+
+        /*
+         * The BAT entries have to be stored in big endian format.
+         */
+        unsigned i = 0;
+        for (i = 0; i < pImage->cBlockAllocationTableEntries; i++)
+        {
+            pBlockAllocationTableToWrite[i] = RT_H2BE_U32(pImage->pBlockAllocationTable[i]);
+        }
+
+        /*
+         * Write the block allocation table after the copy of the disk footer and the dynamic disk header.
+         */
+        RTFileWriteAt(pImage->File, pImage->uBlockAllocationTableOffset, pBlockAllocationTableToWrite, cbBlockAllocationTableToWrite, NULL);
+        RTFileWriteAt(pImage->File, pImage->uCurrentEndOfFile, &pImage->vhdFooterCopy, sizeof(VHDFooter), NULL);
+        if (pImage->fDynHdrNeedsUpdate)
+            vhdDynamicHeaderUpdate(pImage);
+    }
+
+    int rc = RTFileFlush(pImage->File);
+
+    return rc;
+}
+
+static uint64_t vhdGetSize(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+
+    Assert(pImage);
+
+    if (pImage)
+        return pImage->cbSize;
+    else
+        return 0;
+}
+
+static uint64_t vhdGetFileSize(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        uint64_t cb;
+        int rc = RTFileGetSize(pImage->File, &cb);
+        if (RT_SUCCESS(rc))
+            return cb;
+        else
+            return 0;
+    }
+    else
+        return 0;
+}
+
+static int vhdGetUuid(void *pBackendData, PRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        *pUuid = pImage->ImageUuid;
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc (%RTuuid)\n", __FUNCTION__, rc, pUuid));
+    return rc;
+}
+
+static int vhdSetUuid(void *pBackendData, PCRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    LogFlow(("%s: %RTuuid\n", pUuid));
+    Assert(pImage);
+
+    if (pImage)
+    {
+        pImage->ImageUuid = *pUuid;
+        /**@todo: implement */
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetComment(void *pBackendData, char *pszComment, size_t cbComment)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        rc = VERR_VDI_VALUE_NOT_FOUND;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+    LogFlow(("%s: returned %Rrc comment='%s'\n", __FUNCTION__, rc, pszComment));
+    return rc;
+}
+
+static int vhdSetComment(void *pBackendData, const char *pszComment)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    LogFlow(("%s: comment '%s'\n", pszComment));
+    Assert(pImage);
+
+    if (pImage)
+    {
+        /**@todo: implement */
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetModificationUuid(void *pBackendData, PRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        rc = VERR_VDI_VALUE_NOT_FOUND;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc (%RTuuid)\n", __FUNCTION__, rc, pUuid));
+    return rc;
+}
+
+static int vhdSetModificationUuid(void *pBackendData, PCRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    LogFlow(("%s: %RTuuid\n", pUuid));
+    Assert(pImage);
+
+    if (pImage)
+    {
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetParentUuid(void *pBackendData, PRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        *pUuid = pImage->ParentUuid;
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc (%RTuuid)\n", __FUNCTION__, rc, pUuid));
+    return rc;
+}
+
+static int vhdSetParentUuid(void *pBackendData, PCRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc = VINF_SUCCESS;
+
+    LogFlow(("%s: %RTuuid\n", pUuid));
+    Assert(pImage);
+
+    if (pImage && pImage->File != NIL_RTFILE)
+    {
+        if (pImage->enmImageType != VD_IMAGE_TYPE_FIXED)
+        {
+            pImage->ParentUuid = *pUuid;
+            pImage->fDynHdrNeedsUpdate = true;
+        }
+        else
+            rc = VERR_NOT_SUPPORTED;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetParentModificationUuid(void *pBackendData, PRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    Assert(pImage);
+
+    if (pImage)
+    {
+        rc = VERR_VDI_VALUE_NOT_FOUND;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc (%RTuuid)\n", __FUNCTION__, rc, pUuid));
+    return rc;
+}
+
+static int vhdSetParentModificationUuid(void *pBackendData, PCRTUUID pUuid)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+    int rc;
+
+    LogFlow(("%s: %RTuuid\n", pUuid));
+    Assert(pImage);
+
+    if (pImage)
+    {
+        rc = VINF_SUCCESS;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+/**
+ * Internal: Derive drive geometry from its size.
+ */
+static void vhdSetDiskGeometry(PVHDIMAGE pImage, uint64_t cbSize)
+{
+    uint64_t u64TotalSectors = cbSize / 512;
+    uint32_t u32CylinderTimesHeads, u32Heads, u32SectorsPerTrack;
+
+    if (u64TotalSectors > 65535 * 16 * 255)
+    {
+        /* ATA disks limited to 127 GB. */
+        u64TotalSectors = 65535 * 16 * 255;
+    }
+
+    if (u64TotalSectors >= 65535 * 16 * 63)
+    {
+        u32SectorsPerTrack    = 255;
+        u32Heads              = 16;
+        u32CylinderTimesHeads = u64TotalSectors / u32SectorsPerTrack;
+    }
+    else
+    {
+        u32SectorsPerTrack    = 17;
+        u32CylinderTimesHeads = u64TotalSectors / u32SectorsPerTrack;
+
+        u32Heads = (u32CylinderTimesHeads + 1023) / 1024;
+
+        if (u32Heads < 4)
+        {
+            u32Heads = 4;
+        }
+        if (u32CylinderTimesHeads >= (u32Heads * 1024) || u32Heads > 16)
+        {
+            u32SectorsPerTrack    = 31;
+            u32Heads              = 16;
+            u32CylinderTimesHeads = u64TotalSectors / u32SectorsPerTrack;
+        }
+        if (u32CylinderTimesHeads >= (u32Heads * 1024))
+        {
+            u32SectorsPerTrack    = 63;
+            u32Heads              = 16;
+            u32CylinderTimesHeads = u64TotalSectors / u32SectorsPerTrack;
+        }
+    }
+    pImage->PCHSGeometry.cCylinders = u32CylinderTimesHeads / u32Heads;
+    pImage->PCHSGeometry.cHeads     = u32Heads;
+    pImage->PCHSGeometry.cSectors   = u32SectorsPerTrack;
+    pImage->LCHSGeometry.cCylinders = 0;
+    pImage->LCHSGeometry.cHeads     = 0;
+    pImage->LCHSGeometry.cSectors   = 0;
+}
+
+
+/**
+ * Internal: signal an error to the frontend.
+ */
+DECLINLINE(int) vhdError(PVHDIMAGE pImage, int rc, RT_SRC_POS_DECL,
+                         const char *pszFormat, ...)
+{
+    va_list va;
+    va_start(va, pszFormat);
+    if (pImage->pInterfaceError && pImage->pInterfaceErrorCallbacks)
+        pImage->pInterfaceErrorCallbacks->pfnError(pImage->pInterfaceError->pvUser, rc, RT_SRC_POS_ARGS,
+                                                   pszFormat, va);
+    va_end(va);
+    return rc;
+}
+
+static uint32_t vhdAllocateParentLocators(PVHDIMAGE pImage, VHDDynamicDiskHeader *pDDH, uint64_t u64Offset)
+{
+    PVHDPLE pLocator = pDDH->ParentLocatorEntry;
+    /* Relative Windows path. */
+    pLocator->u32Code = RT_H2BE_U32(VHD_PLATFORM_CODE_WI2R);
+    pLocator->u32DataSpace = RT_H2BE_U32(VHD_RELATIVE_MAX_PATH / VHD_SECTOR_SIZE);
+    pLocator->u64DataOffset = RT_H2BE_U64(u64Offset);
+    u64Offset += VHD_RELATIVE_MAX_PATH;
+    pLocator++;
+    /* Absolute Windows path. */
+    pLocator->u32Code = RT_H2BE_U32(VHD_PLATFORM_CODE_WI2K);
+    pLocator->u32DataSpace = RT_H2BE_U32(VHD_ABSOLUTE_MAX_PATH / VHD_SECTOR_SIZE);
+    pLocator->u64DataOffset = RT_H2BE_U64(u64Offset);
+    u64Offset += VHD_ABSOLUTE_MAX_PATH;
+    pLocator++;
+    /* Unicode relative Windows path. */
+    pLocator->u32Code = RT_H2BE_U32(VHD_PLATFORM_CODE_W2RU);
+    pLocator->u32DataSpace = RT_H2BE_U32(VHD_RELATIVE_MAX_PATH * sizeof(RTUTF16) / VHD_SECTOR_SIZE);
+    pLocator->u64DataOffset = RT_H2BE_U64(u64Offset);
+    u64Offset += VHD_RELATIVE_MAX_PATH * sizeof(RTUTF16);
+    pLocator++;
+    /* Unicode absolute Windows path. */
+    pLocator->u32Code = RT_H2BE_U32(VHD_PLATFORM_CODE_W2KU);
+    pLocator->u32DataSpace = RT_H2BE_U32(VHD_ABSOLUTE_MAX_PATH * sizeof(RTUTF16) / VHD_SECTOR_SIZE);
+    pLocator->u64DataOffset = RT_H2BE_U64(u64Offset);
+    return u64Offset + VHD_ABSOLUTE_MAX_PATH * sizeof(RTUTF16);
+}
+
+/**
+ * Internal: Additional code for dynamic VHD image creation.
+ */
+static int vhdCreateDynamicImage(PVHDIMAGE pImage, uint64_t cbSize)
+{
+    int rc;
+    VHDDynamicDiskHeader DynamicDiskHeader;
+    uint32_t u32BlockAllocationTableSectors;
+
+    memset(&DynamicDiskHeader, 0, sizeof(DynamicDiskHeader));
+
+    pImage->u64DataOffset           = sizeof(VHDFooter);
+    pImage->cbDataBlock             = VHD_BLOCK_SIZE; /* 2 MB */
+    pImage->cSectorsPerDataBlock    = pImage->cbDataBlock / VHD_SECTOR_SIZE;
+    pImage->cbDataBlockBitmap       = pImage->cSectorsPerDataBlock / 8;
+    pImage->cDataBlockBitmapSectors = pImage->cbDataBlockBitmap / VHD_SECTOR_SIZE;
+    pImage->pvBitmap = RTMemAllocZ(pImage->cbDataBlockBitmap);
+    if (!pImage->pvBitmap)
+        return vhdError(pImage, VERR_NO_MEMORY, RT_SRC_POS, N_("VHD: cannot allocate memory for bitmap storage"));
+
+    /* Initialize BAT. */
+    pImage->uBlockAllocationTableOffset = (uint64_t)sizeof(VHDFooter) + sizeof(VHDDynamicDiskHeader);
+    pImage->cBlockAllocationTableEntries = (uint32_t)(cbSize / pImage->cbDataBlock);
+    u32BlockAllocationTableSectors = (pImage->cBlockAllocationTableEntries * sizeof(uint32_t) + VHD_SECTOR_SIZE - 1) / VHD_SECTOR_SIZE;
+    pImage->pBlockAllocationTable = (uint32_t *)RTMemAllocZ(pImage->cBlockAllocationTableEntries * sizeof(uint32_t));
+    if (!pImage->pBlockAllocationTable)
+        return vhdError(pImage, VERR_NO_MEMORY, RT_SRC_POS, N_("VHD: cannot allocate memory for BAT"));
+
+    for (unsigned i = 0; i < pImage->cBlockAllocationTableEntries; i++)
+    {
+        pImage->pBlockAllocationTable[i] = 0xFFFFFFFF; /* It is actually big endian. */
+    }
+    /* Round up to the sector size. */
+    pImage->uCurrentEndOfFile = vhdAllocateParentLocators(pImage, &DynamicDiskHeader,
+        pImage->uBlockAllocationTableOffset + u32BlockAllocationTableSectors * VHD_SECTOR_SIZE);
+
+    rc = RTFileSetSize(pImage->File, pImage->uCurrentEndOfFile + sizeof(VHDFooter));
+    if (RT_FAILURE(rc))
+        return vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot set the file size for '%s'"), pImage->pszFilename);
+
+    /* Initialize and write the dynamic disk header. */
+    memcpy(DynamicDiskHeader.Cookie, VHD_DYNAMIC_DISK_HEADER_COOKIE, sizeof(DynamicDiskHeader.Cookie));
+    DynamicDiskHeader.DataOffset      = UINT64_C(0xFFFFFFFFFFFFFFFF); /* Initially the disk has no data. */
+    DynamicDiskHeader.TableOffset     = RT_H2BE_U64(pImage->uBlockAllocationTableOffset);
+    DynamicDiskHeader.HeaderVersion   = RT_H2BE_U32(VHD_DYNAMIC_DISK_HEADER_VERSION);
+    DynamicDiskHeader.BlockSize       = RT_H2BE_U32(pImage->cbDataBlock);
+    DynamicDiskHeader.MaxTableEntries = RT_H2BE_U32(pImage->cBlockAllocationTableEntries);
+    /* Compute and update checksum. */
+    DynamicDiskHeader.Checksum = 0;
+    DynamicDiskHeader.Checksum = RT_H2BE_U32(vhdChecksum(&DynamicDiskHeader, sizeof(DynamicDiskHeader)));
+
+    rc = RTFileWriteAt(pImage->File, sizeof(VHDFooter), &DynamicDiskHeader, sizeof(DynamicDiskHeader), NULL);
+    if (RT_FAILURE(rc))
+        return vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot write dynamic disk header to image '%s'"), pImage->pszFilename);
+
+    /* Write BAT. */
+    rc = RTFileWriteAt(pImage->File, pImage->uBlockAllocationTableOffset, pImage->pBlockAllocationTable,
+                       pImage->cBlockAllocationTableEntries * sizeof(uint32_t), NULL);
+    if (RT_FAILURE(rc))
+        return vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot write BAT to image '%s'"), pImage->pszFilename);
+
+    return rc;
+}
+
+/**
+ * Internal: The actual code for VHD image creation, both fixed and dynamic.
+ */
+static int vhdCreateImage(PVHDIMAGE pImage, VDIMAGETYPE enmType,
+                          uint64_t cbSize, unsigned uImageFlags,
+                          const char *pszComment,
+                          PCPDMMEDIAGEOMETRY pPCHSGeometry,
+                          PCPDMMEDIAGEOMETRY pLCHSGeometry, PCRTUUID pUuid,
+                          unsigned uOpenFlags,
+                          PFNVMPROGRESS pfnProgress, void *pvUser,
+                          unsigned uPercentStart, unsigned uPercentSpan)
+{
+    int rc;
+    RTFILE File;
+    VHDFooter Footer;
+    RTTIMESPEC now;
+
+    pImage->uOpenFlags = uOpenFlags;
+
+    pImage->pInterfaceError = VDInterfaceGet(pImage->pVDIfsDisk, VDINTERFACETYPE_ERROR);
+    if (pImage->pInterfaceError)
+        pImage->pInterfaceErrorCallbacks = VDGetInterfaceError(pImage->pInterfaceError);
+
+    /* Create image file. */
+    rc = RTFileOpen(&File, pImage->pszFilename,
+                    RTFILE_O_READWRITE | RTFILE_O_CREATE | RTFILE_O_DENY_ALL);
+    if (RT_FAILURE(rc))
+        return vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot create image '%s'"), pImage->pszFilename);
+    pImage->File = File;
+
+    pImage->enmImageType = enmType;
+    pImage->cbSize = cbSize;
+    pImage->ImageUuid = *pUuid;
+    RTUuidClear(&pImage->ParentUuid);
+    vhdSetDiskGeometry(pImage, cbSize);
+
+    /* Initialize the footer. */
+    memset(&Footer, 0, sizeof(Footer));
+    memcpy(Footer.Cookie, VHD_FOOTER_COOKIE, sizeof(Footer.Cookie));
+    Footer.Features = RT_H2BE_U32(0x2);
+    Footer.Version  = RT_H2BE_U32(VHD_FOOTER_FILE_FORMAT_VERSION);
+    Footer.TimeStamp = RT_H2BE_U32(vhdRtTime2VhdTime(RTTimeNow(&now)));
+    memcpy(Footer.CreatorApp, "vbox", sizeof(Footer.CreatorApp));
+    Footer.CreatorVer = RT_H2BE_U32(VBOX_VERSION);
+#ifdef RT_OS_DARWIN
+    Footer.CreatorOS  = RT_H2BE_U32(0x4D616320); /* "Mac " */
+#else /* Virtual PC supports only two platforms atm, so everything else will be Wi2k. */
+    Footer.CreatorOS  = RT_H2BE_U32(0x5769326B); /* "Wi2k" */
+#endif
+    Footer.OrigSize   = RT_H2BE_U64(cbSize);
+    Footer.CurSize    = Footer.OrigSize;
+    Footer.DiskGeometryCylinder = RT_H2BE_U16(pImage->PCHSGeometry.cCylinders);
+    Footer.DiskGeometryHeads    = pImage->PCHSGeometry.cHeads;
+    Footer.DiskGeometrySectors  = pImage->PCHSGeometry.cSectors;
+    memcpy(Footer.UniqueID, pImage->ImageUuid.au8, sizeof(Footer.UniqueID));
+    Footer.SavedState = 0;
+
+    switch (enmType)
+    {
+        case VD_IMAGE_TYPE_FIXED:
+            Footer.DiskType   = RT_H2BE_U32(VHD_FOOTER_DISK_TYPE_FIXED);
+            /*
+             * Initialize fixed image.
+             * "The size of the entire file is the size of the hard disk in
+             * the guest operating system plus the size of the footer."
+             */
+            pImage->u64DataOffset     = VHD_FOOTER_DATA_OFFSET_FIXED;
+            pImage->uCurrentEndOfFile = cbSize;
+            rc = RTFileSetSize(File, pImage->uCurrentEndOfFile + sizeof(VHDFooter));
+            if (RT_FAILURE(rc))
+            {
+                vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot set the file size for '%s'"), pImage->pszFilename);
+                goto out;
+            }
+            break;
+        case VD_IMAGE_TYPE_NORMAL:
+        case VD_IMAGE_TYPE_DIFF:
+            /*
+             * Initialize dynamic image.
+             *
+             * The overall structure of dynamic disk is:
+             *
+             * [Copy of hard disk footer (512 bytes)]
+             * [Dynamic disk header (1024 bytes)]
+             * [BAT (Block Allocation Table)]
+             * [Parent Locators]
+             * [Data block 1]
+             * [Data block 2]
+             * ...
+             * [Data block N]
+             * [Hard disk footer (512 bytes)]
+             */
+            Footer.DiskType   = enmType == VD_IMAGE_TYPE_DIFF ?
+                RT_H2BE_U32(VHD_FOOTER_DISK_TYPE_DIFFERENCING) :
+                RT_H2BE_U32(VHD_FOOTER_DISK_TYPE_DYNAMIC);
+            /* We are half way thourgh with creation of image, let the caller know. */
+            if (pfnProgress)
+                pfnProgress(NULL /* WARNING! pVM=NULL  */, (uPercentStart + uPercentSpan) / 2, pvUser);
+
+            rc = vhdCreateDynamicImage(pImage, cbSize);
+            if (RT_FAILURE(rc))
+                goto out;
+
+            break;
+        default:
+            /* Unknown/invalid image type. */
+            rc = VERR_NOT_IMPLEMENTED;
+            break;
+    }
+
+    Footer.DataOffset = RT_H2BE_U64(pImage->u64DataOffset);
+    pImage->vhdFooterCopy = Footer;
+
+    /* Compute and update the footer checksum. */
+    Footer.Checksum = 0;
+    Footer.Checksum = RT_H2BE_U32(vhdChecksum(&Footer, sizeof(Footer)));
+
+    /* Store the footer */
+    rc = RTFileWriteAt(File, pImage->uCurrentEndOfFile, &Footer, sizeof(Footer), NULL);
+    if (RT_FAILURE(rc))
+    {
+        vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot write footer to image '%s'"), pImage->pszFilename);
+        goto out;
+    }
+
+    /* Dynamic images contain a copy of the footer at the very beginning of the file. */
+    if (enmType == VD_IMAGE_TYPE_NORMAL || enmType == VD_IMAGE_TYPE_DIFF)
+    {
+        /* Write the copy of the footer. */
+        rc = RTFileWriteAt(File, 0, &Footer, sizeof(Footer), NULL);
+        if (RT_FAILURE(rc))
+        {
+            vhdError(pImage, rc, RT_SRC_POS, N_("VHD: cannot write a copy of footer to image '%s'"), pImage->pszFilename);
+            goto out;
+        }
+    }
+
+    if (pfnProgress)
+        pfnProgress(NULL /* WARNING! pVM=NULL  */, uPercentStart + uPercentSpan, pvUser);
+
+out:
+    return rc;
+}
+
+static int vhdCreate(const char *pszFilename, VDIMAGETYPE enmType,
+                     uint64_t cbSize, unsigned uImageFlags,
+                     const char *pszComment,
+                     PCPDMMEDIAGEOMETRY pPCHSGeometry,
+                     PCPDMMEDIAGEOMETRY pLCHSGeometry, PCRTUUID pUuid,
+                     unsigned uOpenFlags, unsigned uPercentStart,
+                     unsigned uPercentSpan, PVDINTERFACE pVDIfsDisk,
+                     PVDINTERFACE pVDIfsImage, PVDINTERFACE pVDIfsOperation,
+                     void **ppvBackendData)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage;
+
+    PFNVMPROGRESS pfnProgress = NULL;
+    void *pvUser = NULL;
+    PVDINTERFACE pIfProgress = VDInterfaceGet(pVDIfsOperation,
+                                              VDINTERFACETYPE_PROGRESS);
+    PVDINTERFACEPROGRESS pCbProgress = NULL;
+    if (pIfProgress)
+    {
+        pCbProgress = VDGetInterfaceProgress(pIfProgress);
+        if (pCbProgress)
+            pfnProgress = pCbProgress->pfnProgress;
+        pvUser = pIfProgress->pvUser;
+    }
+
+    /* Check open flags. All valid flags are supported. */
+    if (uOpenFlags & ~VD_OPEN_FLAGS_MASK)
+    {
+        rc = VERR_INVALID_PARAMETER;
+        return rc;
+    }
+
+    /* @todo Check the values of other params */
+
+    pImage = (PVHDIMAGE)RTMemAllocZ(sizeof(VHDIMAGE));
+    if (!pImage)
+    {
+        rc = VERR_NO_MEMORY;
+        return rc;
+    }
+    pImage->pszFilename = pszFilename;
+    pImage->File = NIL_RTFILE;
+    pImage->pVDIfsDisk = NULL;
+
+    rc = vhdCreateImage(pImage, enmType, cbSize, uImageFlags, pszComment,
+                        pPCHSGeometry, pLCHSGeometry, pUuid, uOpenFlags,
+                        pfnProgress, pvUser, uPercentStart, uPercentSpan);
+
+    if (RT_SUCCESS(rc))
+    {
+        /* So far the image is opened in read/write mode. Make sure the
+         * image is opened in read-only mode if the caller requested that. */
+        if (uOpenFlags & VD_OPEN_FLAGS_READONLY)
+        {
+            vhdClose(pImage, false);
+            rc = vhdOpenImage(pImage, uOpenFlags);
+            if (RT_FAILURE(rc))
+                goto out;
+        }
+        *ppvBackendData = pImage;
+    }
+out:
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static void vhdDump(void *pBackendData)
+{
+    PVHDIMAGE pImage = (PVHDIMAGE)pBackendData;
+
+    Assert(pImage);
+    if (pImage)
+    {
+        /** @todo this is just a stub */
+    }
+}
+
+
+static int vhdGetTimeStamp(void *pvBackendData, PRTTIMESPEC pTimeStamp)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage = (PVHDIMAGE)pvBackendData;
+
+    Assert(pImage);
+    if (pImage)
+    {
+        RTFSOBJINFO info;
+
+        rc = RTFileQueryInfo(pImage->File, &info, RTFSOBJATTRADD_NOTHING);
+        *pTimeStamp = info.ModificationTime;
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetParentTimeStamp(void *pvBackendData, PRTTIMESPEC pTimeStamp)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage = (PVHDIMAGE)pvBackendData;
+
+    Assert(pImage);
+    if (pImage)
+        vhdTime2RtTime(pTimeStamp, pImage->u32ParentTimeStamp);
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdSetParentTimeStamp(void *pvBackendData, PCRTTIMESPEC pTimeStamp)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage = (PVHDIMAGE)pvBackendData;
+
+    Assert(pImage);
+    if (pImage)
+    {
+        if (pImage->uOpenFlags & VD_OPEN_FLAGS_READONLY)
+            rc = VERR_VDI_IMAGE_READ_ONLY;
+        else
+        {
+            pImage->u32ParentTimeStamp = vhdRtTime2VhdTime(pTimeStamp);
+            pImage->fDynHdrNeedsUpdate = true;
+        }
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdGetParentFilename(void *pvBackendData, char **ppszParentFilename)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage = (PVHDIMAGE)pvBackendData;
+
+    Assert(pImage);
+    if (pImage)
+        *ppszParentFilename = RTStrDup(pImage->pszParentFilename);
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static int vhdSetParentFilename(void *pvBackendData, const char *pszParentFilename)
+{
+    int rc = VINF_SUCCESS;
+    PVHDIMAGE pImage = (PVHDIMAGE)pvBackendData;
+
+    Assert(pImage);
+    if (pImage)
+    {
+        if (pImage->uOpenFlags & VD_OPEN_FLAGS_READONLY)
+            rc = VERR_VDI_IMAGE_READ_ONLY;
+        else
+        {
+            if (pImage->pszParentFilename)
+                RTStrFree(pImage->pszParentFilename);
+            pImage->pszParentFilename = RTStrDup(pszParentFilename);
+            if (!pImage->pszParentFilename)
+                rc = VERR_NO_MEMORY;
+            else
+                pImage->fDynHdrNeedsUpdate = true;
+        }
+    }
+    else
+        rc = VERR_VDI_NOT_OPENED;
+    LogFlow(("%s: returned %Rrc\n", __FUNCTION__, rc));
+    return rc;
+}
+
+static bool vhdIsAsyncIOSupported(void *pvBackendData)
+{
+    return false;
+}
+
+static int vhdAsyncRead(void *pvBackendData, uint64_t uOffset, size_t cbRead,
+                        PPDMDATASEG paSeg, unsigned cSeg, void *pvUser)
+{
+    int rc = VERR_NOT_IMPLEMENTED;
+    LogFlowFunc(("returns %Rrc\n", rc));
+    return rc;
+}
+
+static int vhdAsyncWrite(void *pvBackendData, uint64_t uOffset, size_t cbWrite,
+                         PPDMDATASEG paSeg, unsigned cSeg, void *pvUser)
+{
+    int rc = VERR_NOT_IMPLEMENTED;
+    LogFlowFunc(("returns %Rrc\n", rc));
+    return rc;
+}
+
+
+VBOXHDDBACKEND g_VhdBackend =
+{
+    /* pszBackendName */
+    "VHD",
+    /* cbSize */
+    sizeof(VBOXHDDBACKEND),
+    /* uBackendCaps */
+    VD_CAP_UUID | VD_CAP_DIFF | VD_CAP_FILE,
+    /* papszFileExtensions */
+    s_apszVhdFileExtensions,
+    /* paConfigInfo */
+    NULL,
+    /* pfnCheckIfValid */
+    vhdCheckIfValid,
+    /* pfnOpen */
+    vhdOpen,
+    /* pfnCreate */
+    vhdCreate,
+    /* pfnRename */
+    vhdRename,
+    /* pfnClose */
+    vhdClose,
+    /* pfnRead */
+    vhdRead,
+    /* pfnWrite */
+    vhdWrite,
+    /* pfnFlush */
+    vhdFlush,
+    /* pfnGetVersion */
+    vhdGetVersion,
+    /* pfnGetImageType */
+    vhdGetImageType,
+    /* pfnGetSize */
+    vhdGetSize,
+    /* pfnGetFileSize */
+    vhdGetFileSize,
+    /* pfnGetPCHSGeometry */
+    vhdGetPCHSGeometry,
+    /* pfnSetPCHSGeometry */
+    vhdSetPCHSGeometry,
+    /* pfnGetLCHSGeometry */
+    vhdGetLCHSGeometry,
+    /* pfnSetLCHSGeometry */
+    vhdSetLCHSGeometry,
+    /* pfnGetImageFlags */
+    vhdGetImageFlags,
+    /* pfnGetOpenFlags */
+    vhdGetOpenFlags,
+    /* pfnSetOpenFlags */
+    vhdSetOpenFlags,
+    /* pfnGetComment */
+    vhdGetComment,
+    /* pfnSetComment */
+    vhdSetComment,
+    /* pfnGetUuid */
+    vhdGetUuid,
+    /* pfnSetUuid */
+    vhdSetUuid,
+    /* pfnGetModificationUuid */
+    vhdGetModificationUuid,
+    /* pfnSetModificationUuid */
+    vhdSetModificationUuid,
+    /* pfnGetParentUuid */
+    vhdGetParentUuid,
+    /* pfnSetParentUuid */
+    vhdSetParentUuid,
+    /* pfnGetParentModificationUuid */
+    vhdGetParentModificationUuid,
+    /* pfnSetParentModificationUuid */
+    vhdSetParentModificationUuid,
+    /* pfnDump */
+    vhdDump,
+    /* pfnGetTimeStamp */
+    vhdGetTimeStamp,
+    /* pfnGetParentTimeStamp */
+    vhdGetParentTimeStamp,
+    /* pfnSetParentTimeStamp */
+    vhdSetParentTimeStamp,
+    /* pfnGetParentFilename */
+    vhdGetParentFilename,
+    /* pfnSetParentFilename */
+    vhdSetParentFilename,
+    /* pfnIsAsyncIOSupported */
+    vhdIsAsyncIOSupported,
+    /* pfnAsyncRead */
+    vhdAsyncRead,
+    /* pfnAsyncWrite */
+    vhdAsyncWrite
+};
diff -urN VirtualBox-2.0.0/src/VBox/Devices/VMMDev/VBoxDev.cpp vbox/src/VBox/Devices/VMMDev/VBoxDev.cpp
--- VirtualBox-2.0.0/src/VBox/Devices/VMMDev/VBoxDev.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Devices/VMMDev/VBoxDev.cpp	2008-09-08 10:07:20.000000000 +0200
@@ -260,15 +260,16 @@
     PPDMDEVINS pDevIns = VMMDEVSTATE_2_DEVINS(pVMMDevState);
     PVM pVM = PDMDevHlpGetVM(pDevIns);
     int rc;
-    PVMREQ pReq;
 
     Log3(("VMMDevNotifyGuest: u32EventMask = 0x%08X.\n", u32EventMask));
 
-    rc = VMR3ReqCallVoid (pVM, &pReq, RT_INDEFINITE_WAIT,
-                          (PFNRT) vmmdevNotifyGuest_EMT,
-                          2, pVMMDevState, u32EventMask);
-    AssertReleaseRC (rc);
-    VMR3ReqFree (pReq);
+    /* No need to wait for the completion of this request. It is a notification
+     * about something, which has already happened.
+     */
+    rc = VMR3ReqCallEx(pVM, NULL, 0, VMREQFLAGS_NO_WAIT | VMREQFLAGS_VOID,
+                       (PFNRT) vmmdevNotifyGuest_EMT,
+                       2, pVMMDevState, u32EventMask);
+    AssertRC(rc);
 }
 
 /**
diff -urN VirtualBox-2.0.0/src/VBox/Disassembler/testcase/tstDisasm-2.cpp vbox/src/VBox/Disassembler/testcase/tstDisasm-2.cpp
--- VirtualBox-2.0.0/src/VBox/Disassembler/testcase/tstDisasm-2.cpp	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Disassembler/testcase/tstDisasm-2.cpp	2008-09-08 10:07:17.000000000 +0200
@@ -725,6 +725,43 @@
     return rcRet;
 }
 
+/**
+ * Converts a hex char to a number.
+ *
+ * @returns 0..15 on success, -1 on failure.
+ * @param   ch      The character.
+ */
+static int HexDigitToNum(char ch)
+{
+    switch (ch)
+    {
+        case '0': return 0;
+        case '1': return 1;
+        case '2': return 2;
+        case '3': return 3;
+        case '4': return 4;
+        case '5': return 5;
+        case '6': return 6;
+        case '7': return 7;
+        case '8': return 8;
+        case '9': return 9;
+        case 'A':
+        case 'a': return 0xa;
+        case 'B':
+        case 'b': return 0xb;
+        case 'C':
+        case 'c': return 0xc;
+        case 'D':
+        case 'd': return 0xd;
+        case 'E':
+        case 'e': return 0xe;
+        case 'F':
+        case 'f': return 0xf;
+        default:
+            RTPrintf("error: Invalid hex digig '%c'\n", ch);
+            return -1;
+    }
+}
 
 /**
  * Prints usage info.
@@ -736,6 +773,7 @@
 {
     RTStrmPrintf(g_pStdErr,
 "usage: %s [options] <file1> [file2..fileN]\n"
+"   or: %s [options] <-x|--hex-bytes> <hex byte> [more hex..]\n"
 "   or: %s <--help|-h>\n"
 "\n"
 "Options:\n"
@@ -771,6 +809,7 @@
     DISCPUMODE enmCpuMode = CPUMODE_32BIT;
     RTFOFF off = 0;
     RTFOFF cbMax = _1G;
+    bool fHexBytes = false;
 
     /*
      * Parse arguments.
@@ -779,13 +818,14 @@
     {
         { "--address",      'a', RTGETOPT_REQ_UINT64 },
         { "--cpumode",      'c', RTGETOPT_REQ_UINT32 },
-        { "--help",         'h', 0 },
+        { "--help",         'h', RTGETOPT_REQ_NOTHING },
         { "--bytes",        'b', RTGETOPT_REQ_INT64 },
-        { "--listing",      'l', 0 },
-        { "--no-listing",   'L', 0 },
+        { "--listing",      'l', RTGETOPT_REQ_NOTHING },
+        { "--no-listing",   'L', RTGETOPT_REQ_NOTHING },
         { "--offset",       'o', RTGETOPT_REQ_INT64 },
         { "--style",        's', RTGETOPT_REQ_STRING },
         { "--undef-op",     'u', RTGETOPT_REQ_STRING },
+        { "--hex-bytes",    'x', RTGETOPT_REQ_NOTHING },
     };
 
     int ch;
@@ -864,6 +904,10 @@
                 }
                 break;
 
+            case 'x':
+                fHexBytes = true;
+                break;
+
             default:
                 RTStrmPrintf(g_pStdErr, "%s: syntax error: %Rrc\n", argv0, ch);
                 return 1;
@@ -872,30 +916,85 @@
     if (iArg >= argc)
         return Usage(argv0);
 
-    /*
-     * Process the files.
-     */
+
     int rc = VINF_SUCCESS;
-    for ( ; iArg < argc; iArg++)
+    if (fHexBytes)
     {
         /*
-         * Read the file into memory.
+         * Convert the remaining arguments from a hex byte string into
+         * a buffer that we disassemble.
          */
-        void   *pvFile;
-        size_t  cbFile;
-        rc = RTFileReadAllEx(argv[iArg], off, cbMax, 0, &pvFile, &cbFile);
-        if (RT_FAILURE(rc))
+        size_t      cb = 0;
+        uint8_t    *pb = NULL;
+        for ( ; iArg < argc; iArg++)
         {
-            RTStrmPrintf(g_pStdErr, "%s: %s: %Rrc\n", argv0, argv[iArg], rc);
-            break;
+            const char *psz = argv[iArg];
+            while (*psz)
+            {
+                /** @todo this stuff belongs in IPRT, same stuff as mac address reading. Could be reused for IPv6 with a different item size.*/
+                /* skip white space */
+                while (isspace(*psz))
+                    psz++;
+                if (!*psz)
+                    break;
+
+                /* one digit followed by a space or EOS, or two digits. */
+                int iNum = HexDigitToNum(*psz++);
+                if (iNum == -1)
+                    return 1;
+                if (!isspace(*psz) && *psz)
+                {
+                    int iDigit = HexDigitToNum(*psz++);
+                    if (iDigit == -1)
+                        return 1;
+                    iNum = iNum * 16 + iDigit;
+                }
+
+                /* add the byte */
+                if (!(cb % 4 /*64*/))
+                {
+                    pb = (uint8_t *)RTMemRealloc(pb, cb + 64);
+                    if (!pb)
+                    {
+                        RTPrintf("%s: error: RTMemRealloc failed\n", argv[0]);
+                        return 1;
+                    }
+                }
+                pb[cb++] = (uint8_t)iNum;
+            }
         }
 
         /*
          * Disassemble it.
          */
-        rc = MyDisasmBlock(argv0, enmCpuMode, uAddress, (uint8_t *)pvFile, cbFile, enmStyle, fListing, enmUndefOp);
-        if (RT_FAILURE(rc))
-            break;
+        rc = MyDisasmBlock(argv0, enmCpuMode, uAddress, pb, cb, enmStyle, fListing, enmUndefOp);
+    }
+    else
+    {
+        /*
+         * Process the files.
+         */
+        for ( ; iArg < argc; iArg++)
+        {
+            /*
+             * Read the file into memory.
+             */
+            void   *pvFile;
+            size_t  cbFile;
+            rc = RTFileReadAllEx(argv[iArg], off, cbMax, 0, &pvFile, &cbFile);
+            if (RT_FAILURE(rc))
+            {
+                RTStrmPrintf(g_pStdErr, "%s: %s: %Rrc\n", argv0, argv[iArg], rc);
+                break;
+            }
+
+            /*
+             * Disassemble it.
+             */
+            rc = MyDisasmBlock(argv0, enmCpuMode, uAddress, (uint8_t *)pvFile, cbFile, enmStyle, fListing, enmUndefOp);
+            if (RT_FAILURE(rc))
+                break;
+        }
     }
 
     return RT_SUCCESS(rc) ? 0 : 1;
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VBoxManage/VBoxManage.cpp vbox/src/VBox/Frontends/VBoxManage/VBoxManage.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VBoxManage/VBoxManage.cpp	2008-09-08 10:06:24.000000000 +0200
+++ vbox/src/VBox/Frontends/VBoxManage/VBoxManage.cpp	2008-09-08 10:07:11.000000000 +0200
@@ -424,7 +424,8 @@
                      "                            [-vrdpport default|<port>]\n"
                      "                            [-vrdpaddress <host>]\n"
                      "                            [-vrdpauthtype null|external|guest]\n"
-                     "                            [-vrdpmulticon on|off]\n");
+                     "                            [-vrdpmulticon on|off]\n"
+                     "                            [-vrdpreusecon on|off]\n");
         }
         RTPrintf("                            [-usb on|off]\n"
                  "                            [-usbehci on|off]\n"
@@ -1647,6 +1648,8 @@
             vrdpServer->COMGETTER(NetAddress)(address.asOutParam());
             BOOL fMultiCon;
             vrdpServer->COMGETTER(AllowMultiConnection)(&fMultiCon);
+            BOOL fReuseCon;
+            vrdpServer->COMGETTER(ReuseSingleConnection)(&fReuseCon);
             VRDPAuthType_T vrdpAuthType;
             const char *strAuthType;
             vrdpServer->COMGETTER(AuthType)(&vrdpAuthType);
@@ -1672,12 +1675,13 @@
                 RTPrintf("vrdpaddress=\"%lS\"\n", address.raw());
                 RTPrintf("vrdpauthtype=\"%s\"\n", strAuthType);
                 RTPrintf("vrdpmulticon=\"%s\"\n", fMultiCon ? "on" : "off");
+                RTPrintf("vrdpreusecon=\"%s\"\n", fReuseCon ? "on" : "off");
             }
             else
             {
                 if (address.isEmpty())
                     address = "0.0.0.0";
-                RTPrintf("VRDP:            enabled (Address %lS, Port %d, MultiConn: %s, Authentication type: %s)\n", address.raw(), port, fMultiCon ? "on" : "off", strAuthType);
+                RTPrintf("VRDP:            enabled (Address %lS, Port %d, MultiConn: %s, ReuseSingleConn: %s, Authentication type: %s)\n", address.raw(), port, fMultiCon ? "on" : "off", fReuseCon ? "on" : "off", strAuthType);
             }
         }
         else
@@ -3793,6 +3797,7 @@
     char *vrdpaddress = NULL;
     char *vrdpauthtype = NULL;
     char *vrdpmulticon = NULL;
+    char *vrdpreusecon = NULL;
 #endif
     int   fUsbEnabled = -1;
     int   fUsbEhciEnabled = -1;
@@ -4246,6 +4251,13 @@
             i++;
             vrdpmulticon = argv[i];
         }
+        else if (strcmp(argv[i], "-vrdpreusecon") == 0)
+        {
+            if (argc <= i + 1)
+                return errorArgument("Missing argument to '%s'", argv[i]);
+            i++;
+            vrdpreusecon = argv[i];
+        }
 #endif /* VBOX_WITH_VRDP */
         else if (strcmp(argv[i], "-usb") == 0)
         {
@@ -5333,7 +5345,7 @@
             break;
 
 #ifdef VBOX_WITH_VRDP
-        if (vrdp || (vrdpport != UINT16_MAX) || vrdpaddress || vrdpauthtype || vrdpmulticon)
+        if (vrdp || (vrdpport != UINT16_MAX) || vrdpaddress || vrdpauthtype || vrdpmulticon || vrdpreusecon)
         {
             ComPtr<IVRDPServer> vrdpServer;
             machine->COMGETTER(VRDPServer)(vrdpServer.asOutParam());
@@ -5403,6 +5415,23 @@
                         break;
                     }
                 }
+                if (vrdpreusecon)
+                {
+                    if (strcmp(vrdpreusecon, "on") == 0)
+                    {
+                        CHECK_ERROR(vrdpServer, COMSETTER(ReuseSingleConnection)(true));
+                    }
+                    else if (strcmp(vrdpreusecon, "off") == 0)
+                    {
+                        CHECK_ERROR(vrdpServer, COMSETTER(ReuseSingleConnection)(false));
+                    }
+                    else
+                    {
+                        errorArgument("Invalid -vrdpreusecon argument '%s'", vrdpreusecon);
+                        rc = E_FAIL;
+                        break;
+                    }
+                }
             }
         }
 #endif /* VBOX_WITH_VRDP */
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/include/VBoxCloseVMDlg.h vbox/src/VBox/Frontends/VirtualBox4/include/VBoxCloseVMDlg.h
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/include/VBoxCloseVMDlg.h	2008-09-08 10:06:21.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/include/VBoxCloseVMDlg.h	2008-09-08 10:07:09.000000000 +0200
@@ -27,7 +27,7 @@
 #include "QIWithRetranslateUI.h"
 #include "QIDialog.h"
 
-class VBoxCloseVMDlg : public QIWithRetranslateUI2<QIDialog>,
+class VBoxCloseVMDlg : public QIWithRetranslateUI<QIDialog>,
                        public Ui::VBoxCloseVMDlg
 {
     Q_OBJECT;
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/include/VBoxConsoleView.h vbox/src/VBox/Frontends/VirtualBox4/include/VBoxConsoleView.h
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/include/VBoxConsoleView.h	2008-09-08 10:06:21.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/include/VBoxConsoleView.h	2008-09-08 10:07:09.000000000 +0200
@@ -80,6 +80,8 @@
     CConsole &console() { return mConsole; }
 
     bool pause (bool on);
+    bool isPaused() { return mLastState == KMachineState_Paused; }
+    const QPixmap& pauseShot() const { return mPausedShot; }
 
     void setMouseIntegrationEnabled (bool enabled);
 
@@ -202,7 +204,6 @@
 
     void setPointerShape (MousePointerChangeEvent *me);
 
-    bool isPaused() { return mLastState == KMachineState_Paused; }
     bool isRunning() { return mLastState == KMachineState_Running; }
 
     static void dimImage (QImage &img);
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/Makefile.kmk vbox/src/VBox/Frontends/VirtualBox4/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/Makefile.kmk	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/Makefile.kmk	2008-09-08 10:07:09.000000000 +0200
@@ -607,7 +607,7 @@
   VirtualBox4_SOURCES += \
   	src/VBoxLicenseViewer.cpp
  else
-  VirtualBox4_SOURCES_NLS += \
+  VirtualBox4_VBOX_EXTRA_NLS_SOURCES += \
     include/VBoxLicenseViewer.h \
   	src/VBoxLicenseViewer.cpp
  endif
@@ -615,7 +615,7 @@
  	src/linux/XKeyboard-new.cpp \
 	src/VBoxX11Helper.cpp
 else
- VirtualBox4_SOURCES_NLS += \
+ VirtualBox4_VBOX_EXTRA_NLS_SOURCES += \
     include/VBoxLicenseViewer.h \
   	src/VBoxLicenseViewer.cpp
 endif
@@ -834,7 +834,7 @@
 # languages and should never be actually translated or installed.
 #
 updatenls:: \
-		$(filter-out %.qrc,$(VirtualBox4_SOURCES) $(VirtualBox4_SOURCES_NLS)) \
+		$(filter-out %.qrc,$(VirtualBox4_SOURCES) $(VirtualBox4_VBOX_EXTRA_NLS_SOURCES)) \
 		$(wildcard include/*.h)
 	$(call MSG_L1,lupdate all languages (nls/*.ts))
 	$(QUIET)$(TOOL_QT4_LUPDATE) \
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/QIMessageBox.cpp vbox/src/VBox/Frontends/VirtualBox4/src/QIMessageBox.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/QIMessageBox.cpp	2008-09-08 10:06:21.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/QIMessageBox.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -26,6 +26,9 @@
 #include "QIMessageBox.h"
 #include "QILabel.h"
 #include "QIDialogButtonBox.h"
+#ifdef Q_WS_MAC
+# include "VBoxConsoleWnd.h"
+#endif /* Q_WS_MAC */
 
 /* Qt includes */
 #include <QHBoxLayout>
@@ -46,9 +49,20 @@
                             Icon aIcon, int aButton0, int aButton1, int aButton2,
                             QWidget *aParent, const char *aName, bool aModal)
     : QIDialog (aParent,
-                Qt::Window | Qt::Sheet | 
+                Qt::Window | 
                 Qt::MSWindowsFixedSizeDialogHint | Qt::WindowTitleHint | Qt::WindowSystemMenuHint)
 {
+#ifdef Q_WS_MAC
+    /* Sheets are broken if the window is in fullscreen mode. So make it a
+     * normal window in that case. */
+    VBoxConsoleWnd *cwnd = qobject_cast<VBoxConsoleWnd*> (aParent);
+    if (cwnd == NULL ||
+        (!cwnd->isTrueFullscreen() &&
+         !cwnd->isTrueSeamless()))
+        setWindowFlags (windowFlags() | Qt::Sheet);
+#endif /* Q_WS_MAC */
+
+
     setWindowTitle (aCaption);
     /* Necessary to later find some of the message boxes */
     setObjectName (aName);
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxCloseVMDlg.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxCloseVMDlg.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxCloseVMDlg.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxCloseVMDlg.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -22,13 +22,26 @@
 
 #include "VBoxCloseVMDlg.h"
 #include "VBoxProblemReporter.h"
+#ifdef Q_WS_MAC
+# include "VBoxConsoleWnd.h"
+#endif /* Q_WS_MAC */
 
 /* Qt includes */
 #include <QPushButton>
 
 VBoxCloseVMDlg::VBoxCloseVMDlg (QWidget *aParent)
-    : QIWithRetranslateUI2<QIDialog> (aParent, Qt::Sheet)
+    : QIWithRetranslateUI<QIDialog> (aParent)
 {
+#ifdef Q_WS_MAC
+    /* Sheets are broken if the window is in fullscreen mode. So make it a
+     * normal window in that case. */
+    VBoxConsoleWnd *cwnd = qobject_cast<VBoxConsoleWnd*> (aParent);
+    if (cwnd == NULL ||
+        (!cwnd->isTrueFullscreen() &&
+         !cwnd->isTrueSeamless()))
+        setWindowFlags (Qt::Sheet);
+#endif /* Q_WS_MAC */
+
     /* Apply UI decorations */
     Ui::VBoxCloseVMDlg::setupUi (this);
 
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleView.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleView.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleView.cpp	2008-09-08 10:06:21.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleView.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -3022,23 +3022,30 @@
         return;
     }
 
-    /* we have a snapshot for the paused state */
-    QRect r = pe->rect().intersect (viewport()->rect());
-    /* We have to disable paint on screen if we are using the regular painter */
-    bool paintOnScreen = viewport()->testAttribute (Qt::WA_PaintOnScreen);
-    viewport()->setAttribute (Qt::WA_PaintOnScreen, false);
-    QPainter pnt (viewport());
-    pnt.drawPixmap (r.x(), r.y(), mPausedShot,
-                    r.x() + contentsX(), r.y() + contentsY(),
-                    r.width(), r.height());
-    /* Restore the attribute to its previous state */
-    viewport()->setAttribute (Qt::WA_PaintOnScreen, paintOnScreen);
-
+#ifdef VBOX_GUI_USE_QUARTZ2D
+    if (mode == VBoxDefs::Quartz2DMode)
+        mFrameBuf->paintEvent (pe);
+    else
+#endif
+    {
+        /* we have a snapshot for the paused state */
+        QRect r = pe->rect().intersect (viewport()->rect());
+        /* We have to disable paint on screen if we are using the regular painter */
+        bool paintOnScreen = viewport()->testAttribute (Qt::WA_PaintOnScreen);
+        viewport()->setAttribute (Qt::WA_PaintOnScreen, false);
+        QPainter pnt (viewport());
+        pnt.drawPixmap (r.x(), r.y(), mPausedShot,
+                        r.x() + contentsX(), r.y() + contentsY(),
+                        r.width(), r.height());
+        /* Restore the attribute to its previous state */
+        viewport()->setAttribute (Qt::WA_PaintOnScreen, paintOnScreen);
 #ifdef Q_WS_MAC
-    ::darwinUpdateDockPreview (::darwinToCGImageRef (&mPausedShot),
-                               mVirtualBoxLogo,
-                               mMainWnd->dockImageState());
+        ::darwinUpdateDockPreview (::darwinToCGImageRef (&mPausedShot),
+                                   mVirtualBoxLogo,
+                                   mMainWnd->dockImageState());
 #endif
+    }
+
 }
 
 /**
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleWnd.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleWnd.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleWnd.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxConsoleWnd.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -218,6 +218,7 @@
         VBoxGlobal::iconSet (":/acpi_16px.png", ":/acpi_disabled_16px.png"));
 
     vmCloseAction = new QAction (this);
+    vmCloseAction->setMenuRole (QAction::QuitRole);
     vmCloseAction->setIcon (VBoxGlobal::iconSet (":/exit_16px.png"));
 
     vmTakeSnapshotAction = new QAction (mRunningOrPausedActions);
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxDiskImageManagerDlg.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxDiskImageManagerDlg.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxDiskImageManagerDlg.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxDiskImageManagerDlg.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -1245,6 +1245,7 @@
                     VBoxMedia::Error;
                 vboxGlobal().updateMedia (media);
             }
+            break;
         }
         /* If it is a floppy sub-item: */
         case VBoxDefs::FD:
@@ -1266,6 +1267,7 @@
                     VBoxMedia::Error;
                 vboxGlobal().updateMedia (media);
             }
+            break;
         }
         default:
             AssertMsgFailed (("Selected tree should be equal to one item in VBoxDefs::DiskType.\n"));
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxFBQuartz2D.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxFBQuartz2D.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxFBQuartz2D.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxFBQuartz2D.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -155,7 +155,7 @@
 
     Assert (mImage);
 
-    QWidget *main = vboxGlobal().mainWindow();
+    VBoxConsoleWnd *main = qobject_cast <VBoxConsoleWnd *> (vboxGlobal().mainWindow());
     Assert (VALID_PTR (main));
     QWidget* viewport = mView->viewport();
     Assert (VALID_PTR (viewport));
@@ -169,14 +169,18 @@
     CGContextRef ctx = ::darwinToCGContextRef (viewport);
     Assert (VALID_PTR (ctx));
     /* We handle the seamless mode as a special case. */
-    if (qobject_cast <VBoxConsoleWnd *> (main)->isTrueSeamless())
+    if (main->isTrueSeamless())
     {
         /* Here we paint the windows without any wallpaper.
          * So the background would be set transparently. */
 
         /* Create a subimage of the current view.
          * Currently this subimage is the whole screen. */
-        CGImageRef subImage = CGImageCreateWithImageInRect (mImage, CGRectMake (mView->contentsX(), mView->contentsY(), mView->visibleWidth(), mView->visibleHeight()));
+        CGImageRef subImage;
+        if (mView->isPaused())
+            subImage = CGImageCreateWithImageInRect (::darwinToCGImageRef (&mView->pauseShot()), CGRectMake (mView->contentsX(), mView->contentsY(), mView->visibleWidth(), mView->visibleHeight()));
+        else
+            subImage = CGImageCreateWithImageInRect (mImage, CGRectMake (mView->contentsX(), mView->contentsY(), mView->visibleWidth(), mView->visibleHeight()));
         Assert (VALID_PTR (subImage));
         /* Clear the background (Make the rect fully transparent) */
         CGContextClearRect (ctx, viewRect);
@@ -219,7 +223,11 @@
          * of the bounding box of the current paint event */
         QRect ir = aEvent->rect();
         QRect is = QRect (ir.x() + mView->contentsX(), ir.y() + mView->contentsY(), ir.width(), ir.height());
-        CGImageRef subImage = CGImageCreateWithImageInRect (mImage, ::darwinToHIRect (is));
+        CGImageRef subImage;
+        if (mView->isPaused())
+            subImage = CGImageCreateWithImageInRect (::darwinToCGImageRef (&mView->pauseShot()), ::darwinToHIRect (is));
+        else
+            subImage = CGImageCreateWithImageInRect (mImage, ::darwinToHIRect (is));
         Assert (VALID_PTR (subImage));
         /* Ok, for more performance we set a clipping path of the
          * regions given by this paint event. */
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxNewHDWzd.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxNewHDWzd.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxNewHDWzd.cpp	2008-09-08 10:06:21.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxNewHDWzd.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -201,10 +201,10 @@
             "<tr><td><nobr>%5:&nbsp;</nobr></td><td><nobr>%6&nbsp;(%7&nbsp;%8)</nobr></td></tr>"
             "</table>"
         )
-            .arg (tr ("Type", "summary"), type)
-            .arg (tr ("Location", "summary"), composeFullFileName (imageFileName()))
-            .arg (tr ("Size", "summary"), VBoxGlobal::formatSize (sizeB))
-            .arg (sizeB).arg (tr ("Bytes", "summary"), sizeB);
+            .arg (tr ("Type", "summary")).arg (type)
+            .arg (tr ("Location", "summary")).arg (composeFullFileName (imageFileName()))
+            .arg (tr ("Size", "summary")).arg (VBoxGlobal::formatSize (sizeB))
+            .arg (sizeB).arg (tr ("Bytes", "summary"));
 
         mTeSummary->setText (summary);
     }
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxProblemReporter.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxProblemReporter.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxProblemReporter.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxProblemReporter.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -216,6 +216,7 @@
     updateAction->setIcon (VBoxGlobal::iconSet (":/refresh_16px.png",
                                                 ":/refresh_disabled_16px.png"));
     aboutAction = new QAction (aParent);
+    aboutAction->setMenuRole (QAction::AboutRole);
     aboutAction->setIcon (VBoxGlobal::iconSet (":/about_16px.png"));
 
     QObject::connect (contentsAction, SIGNAL (triggered()),
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxSelectorWnd.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxSelectorWnd.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxSelectorWnd.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxSelectorWnd.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -400,8 +400,10 @@
     fileDiskMgrAction = new QAction (this);
     fileDiskMgrAction->setIcon (VBoxGlobal::iconSet (":/diskim_16px.png"));
     fileSettingsAction = new QAction(this);
+    fileSettingsAction->setMenuRole (QAction::PreferencesRole);
     fileSettingsAction->setIcon (VBoxGlobal::iconSet (":/global_settings_16px.png"));
     fileExitAction = new QAction (this);
+    fileExitAction->setMenuRole (QAction::QuitRole);
     fileExitAction->setIcon (VBoxGlobal::iconSet (":/exit_16px.png"));
 
     vmNewAction = new QAction (this);
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsHD.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsHD.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsHD.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsHD.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -675,16 +675,17 @@
         /* Try to select unique vdi */
         editor->tryToChooseUniqueVdi (vdis);
 
+        /* Ask the user for method to add new vdi */
+        int result = mModel->rowCount() - 1 > editor->count() ?
+            vboxProblem().confirmRunNewHDWzdOrVDM (this) :
+            QIMessageBox::Cancel;
+
         /* Move the focus to the other than attachment table location.
          * This will close the temporary editor of this table to prevent
          * influencing the media enumeration mechanism to model data. */
         mCbSATA->setFocus();
         qApp->processEvents();
 
-        /* Ask the user for method to add new vdi */
-        int result = mModel->rowCount() - 1 > editor->count() ?
-            vboxProblem().confirmRunNewHDWzdOrVDM (this) :
-            QIMessageBox::Cancel;
         if (result == QIMessageBox::Yes)
         {
             /* Run new HD wizard */
diff -urN VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsUSB.cpp vbox/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsUSB.cpp
--- VirtualBox-2.0.0/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsUSB.cpp	2008-09-08 10:06:22.000000000 +0200
+++ vbox/src/VBox/Frontends/VirtualBox4/src/VBoxVMSettingsUSB.cpp	2008-09-08 10:07:09.000000000 +0200
@@ -177,13 +177,16 @@
     mMachine = aMachine;
 
     CUSBController ctl = aMachine.GetUSBController();
-    mGbUSB->setChecked (ctl.GetEnabled());
-    mCbUSB2->setChecked (ctl.GetEnabledEhci());
+    mGbUSB->setChecked (!ctl.isNull() && ctl.GetEnabled());
+    mCbUSB2->setChecked (!ctl.isNull() && ctl.GetEnabledEhci());
     usbAdapterToggled (mGbUSB->isChecked());
 
-    CUSBDeviceFilterEnumerator en = ctl.GetDeviceFilters().Enumerate();
-    while (en.HasMore())
-        addUSBFilter (en.GetNext(), false /* isNew */);
+    if (!ctl.isNull())
+    {
+        CUSBDeviceFilterEnumerator en = ctl.GetDeviceFilters().Enumerate();
+        while (en.HasMore())
+            addUSBFilter (en.GetNext(), false /* isNew */);
+    }
 
     mTwFilters->setCurrentItem (mTwFilters->topLevelItem (0));
     currentChanged (mTwFilters->currentItem());
@@ -191,27 +194,28 @@
 
 void VBoxVMSettingsUSB::putBackTo()
 {
-    CUSBController ctl = mMachine.GetUSBController();
-
-    ctl.SetEnabled (mGbUSB->isChecked());
-    ctl.SetEnabledEhci (mCbUSB2->isChecked());
-
-    if (mUSBFilterListModified)
+    CUSBController ctl = mMachine.GetUSBController(); 
+    if (!ctl.isNull())
     {
-        /* First, remove all old filters */
-        for (ulong count = ctl.GetDeviceFilters().GetCount(); count; -- count)
-            ctl.RemoveDeviceFilter (0);
+        ctl.SetEnabled (mGbUSB->isChecked());
+        ctl.SetEnabledEhci (mCbUSB2->isChecked());
 
-        /* Then add all new filters */
-        for (int i = 0; i < mFilters.size(); ++ i)
+        if (mUSBFilterListModified)
         {
-            CUSBDeviceFilter filter = mFilters [i];
-            filter.SetActive (mTwFilters->topLevelItem (i)->
-                checkState (0) == Qt::Checked);
-            ctl.InsertDeviceFilter (~0, filter);
+            /* First, remove all old filters */
+            for (ulong count = ctl.GetDeviceFilters().GetCount(); count; -- count)
+                ctl.RemoveDeviceFilter (0);
+
+            /* Then add all new filters */
+            for (int i = 0; i < mFilters.size(); ++ i)
+            {
+                CUSBDeviceFilter filter = mFilters [i];
+                filter.SetActive (mTwFilters->topLevelItem (i)->
+                    checkState (0) == Qt::Checked);
+                ctl.InsertDeviceFilter (~0, filter);
+            }
         }
     }
-
     mUSBFilterListModified = false;
 }
 
@@ -322,8 +326,10 @@
     }
     else if (mType == MachineType)
     {
-        filter = mMachine.GetUSBController()
-            .CreateDeviceFilter (mUSBFilterName.arg (maxFilterIndex + 1));
+        CUSBController ctl = mMachine.GetUSBController();
+        if (ctl.isNull())
+            return;
+        filter = ctl.CreateDeviceFilter (mUSBFilterName.arg (maxFilterIndex + 1));
     }
     else
     {
@@ -361,8 +367,10 @@
     }
     else if (mType == MachineType)
     {
-        filter = mMachine.GetUSBController()
-            .CreateDeviceFilter (vboxGlobal().details (usb));
+        CUSBController ctl = mMachine.GetUSBController();
+        if (ctl.isNull())
+            return;
+        filter = ctl.CreateDeviceFilter (vboxGlobal().details (usb));
     }
     else
     {
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/linux/files_vboxdrv vbox/src/VBox/HostDrivers/Support/linux/files_vboxdrv
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/linux/files_vboxdrv	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/linux/files_vboxdrv	2008-09-08 10:07:22.000000000 +0200
@@ -67,6 +67,9 @@
     ${PATH_ROOT}/src/VBox/Runtime/common/alloc/heapsimple.cpp=>alloc/heapsimple.c \
     ${PATH_ROOT}/src/VBox/Runtime/common/err/RTErrConvertFromErrno.cpp=>common/err/RTErrConvertFromErrno.c \
     ${PATH_ROOT}/src/VBox/Runtime/common/log/log.cpp=>common/log/log.c \
+    ${PATH_ROOT}/src/VBox/Runtime/common/log/logellipsis.cpp=>common/log/logellipsis.c \
+    ${PATH_ROOT}/src/VBox/Runtime/common/log/logrel.cpp=>common/log/logrel.c \
+    ${PATH_ROOT}/src/VBox/Runtime/common/log/logrelellipsis.cpp=>common/log/logrelellipsis.c \
     ${PATH_ROOT}/src/VBox/Runtime/common/log/logcom.cpp=>common/log/logcom.c \
     ${PATH_ROOT}/src/VBox/Runtime/common/log/logformat.cpp=>common/log/logformat.c \
     ${PATH_ROOT}/src/VBox/Runtime/common/math/gcc/divdi3.c=>math/gcc/divdi3.c \
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/linux/Makefile vbox/src/VBox/HostDrivers/Support/linux/Makefile
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/linux/Makefile	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/linux/Makefile	2008-09-08 10:07:22.000000000 +0200
@@ -102,6 +102,9 @@
 
 ifeq ($(BUILD_TYPE),debug)
 OBJS += common/log/log.o \
+	common/log/logellipsis.o \
+	common/log/logrel.o \
+	common/log/logrelellipsis.o \
 	common/log/logcom.o \
 	common/log/logformat.o \
 	common/string/strformat.o \
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c vbox/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/linux/SUPDrv-linux.c	2008-09-08 10:07:22.000000000 +0200
@@ -682,7 +682,7 @@
     PSUPDRVSESSION      pSession;
     Log(("VBoxDrvLinuxCreate: pFilp=%p pid=%d/%d %s\n", pFilp, RTProcSelf(), current->pid, current->comm));
 
-#if 0 /** @todo test this: #ifdef VBOX_WITH_HARDENING */
+#ifdef VBOX_WITH_HARDENING
     /*
      * Only root is allowed to access the device, enforce it!
      */
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/Makefile.kmk vbox/src/VBox/HostDrivers/Support/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/Makefile.kmk	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/Makefile.kmk	2008-09-08 10:07:22.000000000 +0200
@@ -100,16 +100,16 @@
 -include $(PATH_TARGET)/vboxmod-1.dep
 $(PATH_BIN)/src/Makefile: \
 		$(PATH_SUB_CURRENT)/linux/Makefile \
-		$$(if $$(eq $$(Support/linux/Makefile_HARDENED),$$(VBOX_WITH_HARDENING)),,FORCE) \
+		$$(if $$(eq $$(Support/linux/Makefile_VBOX_HARDENED),$$(VBOX_WITH_HARDENING)),,FORCE) \
 		| $(call DIRDEP,$(PATH_TARGET))
 	$(call MSG_TOOL,Creating,,$@)
-ifdef VBOX_WITH_HARDENING
+ifndef VBOX_WITH_HARDENING
 	$(QUIET)$(SED) -e "s;-DVBOX_WITH_HARDENING;;g" --output $@ $<
 else
 	$(QUIET)$(CP) -f $< $@
 endif
 	%$(QUIET2)$(RM) -f -- $(PATH_TARGET)/vboxmod-1.dep
-	%$(QUIET2)$(APPEND) '$(PATH_TARGET)/vboxmod-1.dep' 'Support/linux/Makefile_HARDENED=$(VBOX_WITH_HARDENING)'
+	%$(QUIET2)$(APPEND) '$(PATH_TARGET)/vboxmod-1.dep' 'Support/linux/Makefile_VBOX_HARDENED=$(VBOX_WITH_HARDENING)'
 
 
 #
@@ -214,7 +214,7 @@
 ifdef VBOX_WITH_IDT_PATCHING
  VBoxDrv_DEFS        += VBOX_WITH_IDT_PATCHING
 endif
-#VBoxDrv_DEFS         += SUPDRV_WITH_UNWIND_HACK - post 2.0, need to wrap more APIs and entry functions.
+VBoxDrv_DEFS.amd64    = SUPDRV_WITH_UNWIND_HACK
 VBoxDrv_SDKS          = W2K3DDK WINPSDKINCS
 VBoxDrv_INCS         := $(PATH_SUB_CURRENT)
 VBoxDrv_SOURCES       = \
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPDrv.c vbox/src/VBox/HostDrivers/Support/SUPDrv.c
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPDrv.c	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/SUPDrv.c	2008-09-08 10:07:22.000000000 +0200
@@ -114,6 +114,156 @@
 # define VBOX_SVN_REV 0
 #endif
 
+/*******************************************************************************
+*   Internal Functions                                                         *
+*******************************************************************************/
+static int      supdrvMemAdd(PSUPDRVMEMREF pMem, PSUPDRVSESSION pSession);
+static int      supdrvMemRelease(PSUPDRVSESSION pSession, RTHCUINTPTR uPtr, SUPDRVMEMREFTYPE eType);
+#ifdef VBOX_WITH_IDT_PATCHING
+static int      supdrvIOCtl_IdtInstall(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPIDTINSTALL pReq);
+static PSUPDRVPATCH supdrvIdtPatchOne(PSUPDRVDEVEXT pDevExt, PSUPDRVPATCH pPatch);
+static int      supdrvIOCtl_IdtRemoveAll(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession);
+static void     supdrvIdtRemoveOne(PSUPDRVDEVEXT pDevExt, PSUPDRVPATCH pPatch);
+static void     supdrvIdtWrite(volatile void *pvIdtEntry, const SUPDRVIDTE *pNewIDTEntry);
+#endif /* VBOX_WITH_IDT_PATCHING */
+static int      supdrvIOCtl_LdrOpen(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDROPEN pReq);
+static int      supdrvIOCtl_LdrLoad(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDRLOAD pReq);
+static int      supdrvIOCtl_LdrFree(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDRFREE pReq);
+static int      supdrvIOCtl_LdrGetSymbol(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDRGETSYMBOL pReq);
+static int      supdrvIDC_LdrGetSymbol(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPDRVIDCREQGETSYM pReq);
+static int      supdrvLdrSetR0EP(PSUPDRVDEVEXT pDevExt, void *pvVMMR0, void *pvVMMR0EntryInt, void *pvVMMR0EntryFast, void *pvVMMR0EntryEx);
+static void     supdrvLdrUnsetR0EP(PSUPDRVDEVEXT pDevExt);
+static int      supdrvLdrAddUsage(PSUPDRVSESSION pSession, PSUPDRVLDRIMAGE pImage);
+static void     supdrvLdrFree(PSUPDRVDEVEXT pDevExt, PSUPDRVLDRIMAGE pImage);
+static SUPPAGINGMODE supdrvIOCtl_GetPagingMode(void);
+static SUPGIPMODE supdrvGipDeterminTscMode(PSUPDRVDEVEXT pDevExt);
+#ifdef RT_OS_WINDOWS
+static int      supdrvPageGetPhys(PSUPDRVSESSION pSession, RTR3PTR pvR3, uint32_t cPages, PRTHCPHYS paPages);
+static bool     supdrvPageWasLockedByPageAlloc(PSUPDRVSESSION pSession, RTR3PTR pvR3);
+#endif /* RT_OS_WINDOWS */
+static int      supdrvGipCreate(PSUPDRVDEVEXT pDevExt);
+static void     supdrvGipDestroy(PSUPDRVDEVEXT pDevExt);
+static DECLCALLBACK(void) supdrvGipSyncTimer(PRTTIMER pTimer, void *pvUser, uint64_t iTick);
+static DECLCALLBACK(void) supdrvGipAsyncTimer(PRTTIMER pTimer, void *pvUser, uint64_t iTick);
+static DECLCALLBACK(void) supdrvGipMpEvent(RTMPEVENT enmEvent, RTCPUID idCpu, void *pvUser);
+
+#ifdef SUPDRV_WITH_UNWIND_HACK
+DECLASM(int)    supdrvNtWrapVMMR0EntryEx(PFNRT pfnVMMR0EntryEx, PVM pVM, unsigned uOperation, PSUPVMMR0REQHDR pReq, uint64_t u64Arg, PSUPDRVSESSION pSession);
+DECLASM(int)    supdrvNtWrapVMMR0EntryFast(PFNRT pfnVMMR0EntryFast, PVM pVM, unsigned uOperation);
+DECLASM(void)   supdrvNtWrapObjDestructor(PFNRT pfnDestruction, void *pvObj, void *pvUser1, void *pvUser2);
+DECLASM(void *) supdrvNtWrapQueryFactoryInterface(PFNRT pfnQueryFactoryInterface, struct SUPDRVFACTORY const *pSupDrvFactory, PSUPDRVSESSION pSession, const char *pszInterfaceUuid);
+DECLASM(int)    supdrvNtWrapModuleInit(PFNRT pfnModuleInit);
+DECLASM(void)   supdrvNtWrapModuleTerm(PFNRT pfnModuleTerm);
+
+DECLASM(int)    UNWIND_WRAP(SUPR0ComponentRegisterFactory)(PSUPDRVSESSION pSession, PCSUPDRVFACTORY pFactory);
+DECLASM(int)    UNWIND_WRAP(SUPR0ComponentDeregisterFactory)(PSUPDRVSESSION pSession, PCSUPDRVFACTORY pFactory);
+DECLASM(int)    UNWIND_WRAP(SUPR0ComponentQueryFactory)(PSUPDRVSESSION pSession, const char *pszName, const char *pszInterfaceUuid, void **ppvFactoryIf);
+DECLASM(void *) UNWIND_WRAP(SUPR0ObjRegister)(PSUPDRVSESSION pSession, SUPDRVOBJTYPE enmType, PFNSUPDRVDESTRUCTOR pfnDestructor, void *pvUser1, void *pvUser2);
+DECLASM(int)    UNWIND_WRAP(SUPR0ObjAddRef)(void *pvObj, PSUPDRVSESSION pSession);
+DECLASM(int)    UNWIND_WRAP(SUPR0ObjRelease)(void *pvObj, PSUPDRVSESSION pSession);
+DECLASM(int)    UNWIND_WRAP(SUPR0ObjVerifyAccess)(void *pvObj, PSUPDRVSESSION pSession, const char *pszObjName);
+DECLASM(int)    UNWIND_WRAP(SUPR0LockMem)(PSUPDRVSESSION pSession, RTR3PTR pvR3, uint32_t cPages, PRTHCPHYS paPages);
+DECLASM(int)    UNWIND_WRAP(SUPR0UnlockMem)(PSUPDRVSESSION pSession, RTR3PTR pvR3);
+DECLASM(int)    UNWIND_WRAP(SUPR0ContAlloc)(PSUPDRVSESSION pSession, uint32_t cPages, PRTR0PTR ppvR0, PRTR3PTR ppvR3, PRTHCPHYS pHCPhys);
+DECLASM(int)    UNWIND_WRAP(SUPR0ContFree)(PSUPDRVSESSION pSession, RTHCUINTPTR uPtr);
+DECLASM(int)    UNWIND_WRAP(SUPR0LowAlloc)(PSUPDRVSESSION pSession, uint32_t cPages, PRTR0PTR ppvR0, PRTR3PTR ppvR3, PRTHCPHYS paPages);
+DECLASM(int)    UNWIND_WRAP(SUPR0LowFree)(PSUPDRVSESSION pSession, RTHCUINTPTR uPtr);
+DECLASM(int)    UNWIND_WRAP(SUPR0MemAlloc)(PSUPDRVSESSION pSession, uint32_t cb, PRTR0PTR ppvR0, PRTR3PTR ppvR3);
+DECLASM(int)    UNWIND_WRAP(SUPR0MemGetPhys)(PSUPDRVSESSION pSession, RTHCUINTPTR uPtr, PSUPPAGE paPages);
+DECLASM(int)    UNWIND_WRAP(SUPR0MemFree)(PSUPDRVSESSION pSession, RTHCUINTPTR uPtr);
+DECLASM(int)    UNWIND_WRAP(SUPR0PageAlloc)(PSUPDRVSESSION pSession, uint32_t cPages, PRTR3PTR ppvR3, PRTHCPHYS paPages);
+DECLASM(int)    UNWIND_WRAP(SUPR0PageFree)(PSUPDRVSESSION pSession, RTR3PTR pvR3);
+//DECLASM(int)    UNWIND_WRAP(SUPR0Printf)(const char *pszFormat, ...);
+DECLASM(void *) UNWIND_WRAP(RTMemAlloc)(size_t cb) RT_NO_THROW;
+DECLASM(void *) UNWIND_WRAP(RTMemAllocZ)(size_t cb) RT_NO_THROW;
+DECLASM(void)   UNWIND_WRAP(RTMemFree)(void *pv) RT_NO_THROW;
+DECLASM(void *) UNWIND_WRAP(RTMemDup)(const void *pvSrc, size_t cb) RT_NO_THROW;
+DECLASM(void *) UNWIND_WRAP(RTMemDupEx)(const void *pvSrc, size_t cbSrc, size_t cbExtra) RT_NO_THROW;
+DECLASM(void *) UNWIND_WRAP(RTMemRealloc)(void *pvOld, size_t cbNew) RT_NO_THROW;
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjAllocLow)(PRTR0MEMOBJ pMemObj, size_t cb, bool fExecutable);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjAllocPage)(PRTR0MEMOBJ pMemObj, size_t cb, bool fExecutable);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjAllocPhys)(PRTR0MEMOBJ pMemObj, size_t cb, RTHCPHYS PhysHighest);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjAllocPhysNC)(PRTR0MEMOBJ pMemObj, size_t cb, RTHCPHYS PhysHighest);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjAllocCont)(PRTR0MEMOBJ pMemObj, size_t cb, bool fExecutable);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjLockUser)(PRTR0MEMOBJ pMemObj, RTR3PTR R3Ptr, size_t cb, RTR0PROCESS R0Process);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjMapKernel)(PRTR0MEMOBJ pMemObj, RTR0MEMOBJ MemObjToMap, void *pvFixed, size_t uAlignment, unsigned fProt);
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjMapUser)(PRTR0MEMOBJ pMemObj, RTR0MEMOBJ MemObjToMap, RTR3PTR R3PtrFixed, size_t uAlignment, unsigned fProt, RTR0PROCESS R0Process);
+/*DECLASM(void *) UNWIND_WRAP(RTR0MemObjAddress)(RTR0MEMOBJ MemObj); - not necessary */
+/*DECLASM(RTR3PTR) UNWIND_WRAP(RTR0MemObjAddressR3)(RTR0MEMOBJ MemObj); - not necessary */
+/*DECLASM(size_t) UNWIND_WRAP(RTR0MemObjSize)(RTR0MEMOBJ MemObj); - not necessary */
+/*DECLASM(bool)   UNWIND_WRAP(RTR0MemObjIsMapping)(RTR0MEMOBJ MemObj); - not necessary */
+/*DECLASM(RTHCPHYS) UNWIND_WRAP(RTR0MemObjGetPagePhysAddr)(RTR0MEMOBJ MemObj, size_t iPage); - not necessary */
+DECLASM(int)    UNWIND_WRAP(RTR0MemObjFree)(RTR0MEMOBJ MemObj, bool fFreeMappings);
+/* RTProcSelf             - not necessary */
+/* RTR0ProcHandleSelf     - not necessary */
+DECLASM(int)    UNWIND_WRAP(RTSemFastMutexCreate)(PRTSEMFASTMUTEX pMutexSem);
+DECLASM(int)    UNWIND_WRAP(RTSemFastMutexDestroy)(RTSEMFASTMUTEX MutexSem);
+DECLASM(int)    UNWIND_WRAP(RTSemFastMutexRequest)(RTSEMFASTMUTEX MutexSem);
+DECLASM(int)    UNWIND_WRAP(RTSemFastMutexRelease)(RTSEMFASTMUTEX MutexSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventCreate)(PRTSEMEVENT pEventSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventSignal)(RTSEMEVENT EventSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventWait)(RTSEMEVENT EventSem, unsigned cMillies);
+DECLASM(int)    UNWIND_WRAP(RTSemEventWaitNoResume)(RTSEMEVENT EventSem, unsigned cMillies);
+DECLASM(int)    UNWIND_WRAP(RTSemEventDestroy)(RTSEMEVENT EventSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventMultiCreate)(PRTSEMEVENTMULTI pEventMultiSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventMultiSignal)(RTSEMEVENTMULTI EventMultiSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventMultiReset)(RTSEMEVENTMULTI EventMultiSem);
+DECLASM(int)    UNWIND_WRAP(RTSemEventMultiWait)(RTSEMEVENTMULTI EventMultiSem, unsigned cMillies);
+DECLASM(int)    UNWIND_WRAP(RTSemEventMultiWaitNoResume)(RTSEMEVENTMULTI EventMultiSem, unsigned cMillies);
+DECLASM(int)    UNWIND_WRAP(RTSemEventMultiDestroy)(RTSEMEVENTMULTI EventMultiSem);
+DECLASM(int)    UNWIND_WRAP(RTSpinlockCreate)(PRTSPINLOCK pSpinlock);
+DECLASM(int)    UNWIND_WRAP(RTSpinlockDestroy)(RTSPINLOCK Spinlock);
+DECLASM(void)   UNWIND_WRAP(RTSpinlockAcquire)(RTSPINLOCK Spinlock, PRTSPINLOCKTMP pTmp);
+DECLASM(void)   UNWIND_WRAP(RTSpinlockRelease)(RTSPINLOCK Spinlock, PRTSPINLOCKTMP pTmp);
+DECLASM(void)   UNWIND_WRAP(RTSpinlockAcquireNoInts)(RTSPINLOCK Spinlock, PRTSPINLOCKTMP pTmp);
+DECLASM(void)   UNWIND_WRAP(RTSpinlockReleaseNoInts)(RTSPINLOCK Spinlock, PRTSPINLOCKTMP pTmp);
+/* RTTimeNanoTS           - not necessary */
+/* RTTimeMilliTS          - not necessary */
+/* RTTimeSystemNanoTS     - not necessary */
+/* RTTimeSystemMilliTS    - not necessary */
+/* RTThreadNativeSelf     - not necessary */
+DECLASM(int)    UNWIND_WRAP(RTThreadSleep)(unsigned cMillies);
+DECLASM(bool)   UNWIND_WRAP(RTThreadYield)(void);
+#if 0
+/* RTThreadSelf           - not necessary */
+DECLASM(int)    UNWIND_WRAP(RTThreadCreate)(PRTTHREAD pThread, PFNRTTHREAD pfnThread, void *pvUser, size_t cbStack,
+                                            RTTHREADTYPE enmType, unsigned fFlags, const char *pszName);
+DECLASM(RTNATIVETHREAD) UNWIND_WRAP(RTThreadGetNative)(RTTHREAD Thread);
+DECLASM(int)    UNWIND_WRAP(RTThreadWait)(RTTHREAD Thread, unsigned cMillies, int *prc);
+DECLASM(int)    UNWIND_WRAP(RTThreadWaitNoResume)(RTTHREAD Thread, unsigned cMillies, int *prc);
+DECLASM(const char *) UNWIND_WRAP(RTThreadGetName)(RTTHREAD Thread);
+DECLASM(const char *) UNWIND_WRAP(RTThreadSelfName)(void);
+DECLASM(RTTHREADTYPE) UNWIND_WRAP(RTThreadGetType)(RTTHREAD Thread);
+DECLASM(int)    UNWIND_WRAP(RTThreadUserSignal)(RTTHREAD Thread);
+DECLASM(int)    UNWIND_WRAP(RTThreadUserReset)(RTTHREAD Thread);
+DECLASM(int)    UNWIND_WRAP(RTThreadUserWait)(RTTHREAD Thread, unsigned cMillies);
+DECLASM(int)    UNWIND_WRAP(RTThreadUserWaitNoResume)(RTTHREAD Thread, unsigned cMillies);
+#endif
+/* RTLogDefaultInstance   - a bit of a gamble, but we do not want the overhead! */
+/* RTMpCpuId              - not necessary */
+/* RTMpCpuIdFromSetIndex  - not necessary */
+/* RTMpCpuIdToSetIndex    - not necessary */
+/* RTMpIsCpuPossible      - not necessary */
+/* RTMpGetCount           - not necessary */
+/* RTMpGetMaxCpuId        - not necessary */
+/* RTMpGetOnlineCount     - not necessary */
+/* RTMpGetOnlineSet       - not necessary */
+/* RTMpGetSet             - not necessary */
+/* RTMpIsCpuOnline        - not necessary */
+DECLASM(int)   UNWIND_WRAP(RTMpOnAll)(PFNRTMPWORKER pfnWorker, void *pvUser1, void *pvUser2);
+DECLASM(int)   UNWIND_WRAP(RTMpOnOthers)(PFNRTMPWORKER pfnWorker, void *pvUser1, void *pvUser2);
+DECLASM(int)   UNWIND_WRAP(RTMpOnSpecific)(RTCPUID idCpu, PFNRTMPWORKER pfnWorker, void *pvUser1, void *pvUser2);
+/* RTLogRelDefaultInstance - not necessary. */
+DECLASM(int)   UNWIND_WRAP(RTLogSetDefaultInstanceThread)(PRTLOGGER pLogger, uintptr_t uKey);
+/* RTLogLogger            - can't wrap this buster.  */
+/* RTLogLoggerEx          - can't wrap this buster. */
+DECLASM(void)  UNWIND_WRAP(RTLogLoggerExV)(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, va_list args);
+/* RTLogPrintf            - can't wrap this buster. */  /** @todo provide va_list log wrappers in RuntimeR0. */
+DECLASM(void)  UNWIND_WRAP(RTLogPrintfV)(const char *pszFormat, va_list args);
+DECLASM(void)  UNWIND_WRAP(AssertMsg1)(const char *pszExpr, unsigned uLine, const char *pszFile, const char *pszFunction);
+/* AssertMsg2             - can't wrap this buster. */
+#endif /* SUPDRV_WITH_UNWIND_HACK */
+
 
 /*******************************************************************************
 *   Global Variables                                                           *
@@ -124,44 +274,45 @@
 static SUPFUNC g_aFunctions[] =
 {
     /* name                                     function */
-    { "SUPR0ComponentRegisterFactory",          (void *)SUPR0ComponentRegisterFactory },
-    { "SUPR0ComponentDeregisterFactory",        (void *)SUPR0ComponentDeregisterFactory },
-    { "SUPR0ComponentQueryFactory",             (void *)SUPR0ComponentQueryFactory },
-    { "SUPR0ObjRegister",                       (void *)SUPR0ObjRegister },
-    { "SUPR0ObjAddRef",                         (void *)SUPR0ObjAddRef },
-    { "SUPR0ObjRelease",                        (void *)SUPR0ObjRelease },
-    { "SUPR0ObjVerifyAccess",                   (void *)SUPR0ObjVerifyAccess },
-    { "SUPR0LockMem",                           (void *)SUPR0LockMem },
-    { "SUPR0UnlockMem",                         (void *)SUPR0UnlockMem },
-    { "SUPR0ContAlloc",                         (void *)SUPR0ContAlloc },
-    { "SUPR0ContFree",                          (void *)SUPR0ContFree },
-    { "SUPR0LowAlloc",                          (void *)SUPR0LowAlloc },
-    { "SUPR0LowFree",                           (void *)SUPR0LowFree },
-    { "SUPR0MemAlloc",                          (void *)SUPR0MemAlloc },
-    { "SUPR0MemGetPhys",                        (void *)SUPR0MemGetPhys },
-    { "SUPR0MemFree",                           (void *)SUPR0MemFree },
-    { "SUPR0PageAlloc",                         (void *)SUPR0PageAlloc },
-    { "SUPR0PageFree",                          (void *)SUPR0PageFree },
-    { "SUPR0Printf",                            (void *)SUPR0Printf },
-    { "RTMemAlloc",                             (void *)RTMemAlloc },
-    { "RTMemAllocZ",                            (void *)RTMemAllocZ },
-    { "RTMemFree",                              (void *)RTMemFree },
-    /*{ "RTMemDup",                               (void *)RTMemDup },*/
-    { "RTMemRealloc",                           (void *)RTMemRealloc },
-    { "RTR0MemObjAllocLow",                     (void *)RTR0MemObjAllocLow },
-    { "RTR0MemObjAllocPage",                    (void *)RTR0MemObjAllocPage },
-    { "RTR0MemObjAllocPhys",                    (void *)RTR0MemObjAllocPhys },
-    { "RTR0MemObjAllocPhysNC",                  (void *)RTR0MemObjAllocPhysNC },
-    { "RTR0MemObjAllocCont",                    (void *)RTR0MemObjAllocCont },
-    { "RTR0MemObjLockUser",                     (void *)RTR0MemObjLockUser },
-    { "RTR0MemObjMapKernel",                    (void *)RTR0MemObjMapKernel },
-    { "RTR0MemObjMapUser",                      (void *)RTR0MemObjMapUser },
+    { "SUPR0ComponentRegisterFactory",          (void *)UNWIND_WRAP(SUPR0ComponentRegisterFactory) },
+    { "SUPR0ComponentDeregisterFactory",        (void *)UNWIND_WRAP(SUPR0ComponentDeregisterFactory) },
+    { "SUPR0ComponentQueryFactory",             (void *)UNWIND_WRAP(SUPR0ComponentQueryFactory) },
+    { "SUPR0ObjRegister",                       (void *)UNWIND_WRAP(SUPR0ObjRegister) },
+    { "SUPR0ObjAddRef",                         (void *)UNWIND_WRAP(SUPR0ObjAddRef) },
+    { "SUPR0ObjRelease",                        (void *)UNWIND_WRAP(SUPR0ObjRelease) },
+    { "SUPR0ObjVerifyAccess",                   (void *)UNWIND_WRAP(SUPR0ObjVerifyAccess) },
+    { "SUPR0LockMem",                           (void *)UNWIND_WRAP(SUPR0LockMem) },
+    { "SUPR0UnlockMem",                         (void *)UNWIND_WRAP(SUPR0UnlockMem) },
+    { "SUPR0ContAlloc",                         (void *)UNWIND_WRAP(SUPR0ContAlloc) },
+    { "SUPR0ContFree",                          (void *)UNWIND_WRAP(SUPR0ContFree) },
+    { "SUPR0LowAlloc",                          (void *)UNWIND_WRAP(SUPR0LowAlloc) },
+    { "SUPR0LowFree",                           (void *)UNWIND_WRAP(SUPR0LowFree) },
+    { "SUPR0MemAlloc",                          (void *)UNWIND_WRAP(SUPR0MemAlloc) },
+    { "SUPR0MemGetPhys",                        (void *)UNWIND_WRAP(SUPR0MemGetPhys) },
+    { "SUPR0MemFree",                           (void *)UNWIND_WRAP(SUPR0MemFree) },
+    { "SUPR0PageAlloc",                         (void *)UNWIND_WRAP(SUPR0PageAlloc) },
+    { "SUPR0PageFree",                          (void *)UNWIND_WRAP(SUPR0PageFree) },
+    { "SUPR0Printf",                            (void *)SUPR0Printf }, /** @todo needs wrapping? */
+    { "RTMemAlloc",                             (void *)UNWIND_WRAP(RTMemAlloc) },
+    { "RTMemAllocZ",                            (void *)UNWIND_WRAP(RTMemAllocZ) },
+    { "RTMemFree",                              (void *)UNWIND_WRAP(RTMemFree) },
+    /*{ "RTMemDup",                               (void *)UNWIND_WRAP(RTMemDup) },
+    { "RTMemDupEx",                             (void *)UNWIND_WRAP(RTMemDupEx) },*/
+    { "RTMemRealloc",                           (void *)UNWIND_WRAP(RTMemRealloc) },
+    { "RTR0MemObjAllocLow",                     (void *)UNWIND_WRAP(RTR0MemObjAllocLow) },
+    { "RTR0MemObjAllocPage",                    (void *)UNWIND_WRAP(RTR0MemObjAllocPage) },
+    { "RTR0MemObjAllocPhys",                    (void *)UNWIND_WRAP(RTR0MemObjAllocPhys) },
+    { "RTR0MemObjAllocPhysNC",                  (void *)UNWIND_WRAP(RTR0MemObjAllocPhysNC) },
+    { "RTR0MemObjAllocCont",                    (void *)UNWIND_WRAP(RTR0MemObjAllocCont) },
+    { "RTR0MemObjLockUser",                     (void *)UNWIND_WRAP(RTR0MemObjLockUser) },
+    { "RTR0MemObjMapKernel",                    (void *)UNWIND_WRAP(RTR0MemObjMapKernel) },
+    { "RTR0MemObjMapUser",                      (void *)UNWIND_WRAP(RTR0MemObjMapUser) },
     { "RTR0MemObjAddress",                      (void *)RTR0MemObjAddress },
     { "RTR0MemObjAddressR3",                    (void *)RTR0MemObjAddressR3 },
     { "RTR0MemObjSize",                         (void *)RTR0MemObjSize },
     { "RTR0MemObjIsMapping",                    (void *)RTR0MemObjIsMapping },
     { "RTR0MemObjGetPagePhysAddr",              (void *)RTR0MemObjGetPagePhysAddr },
-    { "RTR0MemObjFree",                         (void *)RTR0MemObjFree },
+    { "RTR0MemObjFree",                         (void *)UNWIND_WRAP(RTR0MemObjFree) },
 /* These don't work yet on linux - use fast mutexes!
     { "RTSemMutexCreate",                       (void *)RTSemMutexCreate },
     { "RTSemMutexRequest",                      (void *)RTSemMutexRequest },
@@ -170,51 +321,47 @@
 */
     { "RTProcSelf",                             (void *)RTProcSelf },
     { "RTR0ProcHandleSelf",                     (void *)RTR0ProcHandleSelf },
-    { "RTSemFastMutexCreate",                   (void *)RTSemFastMutexCreate },
-    { "RTSemFastMutexDestroy",                  (void *)RTSemFastMutexDestroy },
-    { "RTSemFastMutexRequest",                  (void *)RTSemFastMutexRequest },
-    { "RTSemFastMutexRelease",                  (void *)RTSemFastMutexRelease },
-    { "RTSemEventCreate",                       (void *)RTSemEventCreate },
-    { "RTSemEventSignal",                       (void *)RTSemEventSignal },
-    { "RTSemEventWait",                         (void *)RTSemEventWait },
-    { "RTSemEventWaitNoResume",                 (void *)RTSemEventWaitNoResume },
-    { "RTSemEventDestroy",                      (void *)RTSemEventDestroy },
-    { "RTSemEventMultiCreate",                  (void *)RTSemEventMultiCreate },
-    { "RTSemEventMultiSignal",                  (void *)RTSemEventMultiSignal },
-    { "RTSemEventMultiReset",                   (void *)RTSemEventMultiReset },
-    { "RTSemEventMultiWait",                    (void *)RTSemEventMultiWait },
-#ifdef SUPDRV_WITH_UNWIND_HACK
-    { "RTSemEventMultiWaitNoResume",            (void *)supdrvNtWrapRTSemEventMultiWaitNoResume },
-#else
-    { "RTSemEventMultiWaitNoResume",            (void *)RTSemEventMultiWaitNoResume },
-#endif
-    { "RTSemEventMultiDestroy",                 (void *)RTSemEventMultiDestroy },
-    { "RTSpinlockCreate",                       (void *)RTSpinlockCreate },
-    { "RTSpinlockDestroy",                      (void *)RTSpinlockDestroy },
-    { "RTSpinlockAcquire",                      (void *)RTSpinlockAcquire },
-    { "RTSpinlockRelease",                      (void *)RTSpinlockRelease },
-    { "RTSpinlockAcquireNoInts",                (void *)RTSpinlockAcquireNoInts },
-    { "RTSpinlockReleaseNoInts",                (void *)RTSpinlockReleaseNoInts },
+    { "RTSemFastMutexCreate",                   (void *)UNWIND_WRAP(RTSemFastMutexCreate) },
+    { "RTSemFastMutexDestroy",                  (void *)UNWIND_WRAP(RTSemFastMutexDestroy) },
+    { "RTSemFastMutexRequest",                  (void *)UNWIND_WRAP(RTSemFastMutexRequest) },
+    { "RTSemFastMutexRelease",                  (void *)UNWIND_WRAP(RTSemFastMutexRelease) },
+    { "RTSemEventCreate",                       (void *)UNWIND_WRAP(RTSemEventCreate) },
+    { "RTSemEventSignal",                       (void *)UNWIND_WRAP(RTSemEventSignal) },
+    { "RTSemEventWait",                         (void *)UNWIND_WRAP(RTSemEventWait) },
+    { "RTSemEventWaitNoResume",                 (void *)UNWIND_WRAP(RTSemEventWaitNoResume) },
+    { "RTSemEventDestroy",                      (void *)UNWIND_WRAP(RTSemEventDestroy) },
+    { "RTSemEventMultiCreate",                  (void *)UNWIND_WRAP(RTSemEventMultiCreate) },
+    { "RTSemEventMultiSignal",                  (void *)UNWIND_WRAP(RTSemEventMultiSignal) },
+    { "RTSemEventMultiReset",                   (void *)UNWIND_WRAP(RTSemEventMultiReset) },
+    { "RTSemEventMultiWait",                    (void *)UNWIND_WRAP(RTSemEventMultiWait) },
+    { "RTSemEventMultiWaitNoResume",            (void *)UNWIND_WRAP(RTSemEventMultiWaitNoResume) },
+    { "RTSemEventMultiDestroy",                 (void *)UNWIND_WRAP(RTSemEventMultiDestroy) },
+    { "RTSpinlockCreate",                       (void *)UNWIND_WRAP(RTSpinlockCreate) },
+    { "RTSpinlockDestroy",                      (void *)UNWIND_WRAP(RTSpinlockDestroy) },
+    { "RTSpinlockAcquire",                      (void *)UNWIND_WRAP(RTSpinlockAcquire) },
+    { "RTSpinlockRelease",                      (void *)UNWIND_WRAP(RTSpinlockRelease) },
+    { "RTSpinlockAcquireNoInts",                (void *)UNWIND_WRAP(RTSpinlockAcquireNoInts) },
+    { "RTSpinlockReleaseNoInts",                (void *)UNWIND_WRAP(RTSpinlockReleaseNoInts) },
     { "RTTimeNanoTS",                           (void *)RTTimeNanoTS },
     { "RTTimeMillieTS",                         (void *)RTTimeMilliTS },
     { "RTTimeSystemNanoTS",                     (void *)RTTimeSystemNanoTS },
     { "RTTimeSystemMillieTS",                   (void *)RTTimeSystemMilliTS },
     { "RTThreadNativeSelf",                     (void *)RTThreadNativeSelf },
-    { "RTThreadSleep",                          (void *)RTThreadSleep },
-    { "RTThreadYield",                          (void *)RTThreadYield },
+    { "RTThreadSleep",                          (void *)UNWIND_WRAP(RTThreadSleep) },
+    { "RTThreadYield",                          (void *)UNWIND_WRAP(RTThreadYield) },
 #if 0 /* Thread APIs, Part 2. */
-    { "RTThreadSelf",                           (void *)RTThreadSelf },
-    { "RTThreadCreate",                         (void *)RTThreadCreate },
-    { "RTThreadGetNative",                      (void *)RTThreadGetNative },
-    { "RTThreadWait",                           (void *)RTThreadWait },
-    { "RTThreadWaitNoResume",                   (void *)RTThreadWaitNoResume },
-    { "RTThreadGetName",                        (void *)RTThreadGetName },
-    { "RTThreadSelfName",                       (void *)RTThreadSelfName },
-    { "RTThreadGetType",                        (void *)RTThreadGetType },
-    { "RTThreadUserSignal",                     (void *)RTThreadUserSignal },
-    { "RTThreadUserReset",                      (void *)RTThreadUserReset },
-    { "RTThreadUserWait",                       (void *)RTThreadUserWait },
-    { "RTThreadUserWaitNoResume",               (void *)RTThreadUserWaitNoResume },
+    { "RTThreadSelf",                           (void *)UNWIND_WRAP(RTThreadSelf) },
+    { "RTThreadCreate",                         (void *)UNWIND_WRAP(RTThreadCreate) }, /** @todo need to wrap the callback */
+    { "RTThreadGetNative",                      (void *)UNWIND_WRAP(RTThreadGetNative) },
+    { "RTThreadWait",                           (void *)UNWIND_WRAP(RTThreadWait) },
+    { "RTThreadWaitNoResume",                   (void *)UNWIND_WRAP(RTThreadWaitNoResume) },
+    { "RTThreadGetName",                        (void *)UNWIND_WRAP(RTThreadGetName) },
+    { "RTThreadSelfName",                       (void *)UNWIND_WRAP(RTThreadSelfName) },
+    { "RTThreadGetType",                        (void *)UNWIND_WRAP(RTThreadGetType) },
+    { "RTThreadUserSignal",                     (void *)UNWIND_WRAP(RTThreadUserSignal) },
+    { "RTThreadUserReset",                      (void *)UNWIND_WRAP(RTThreadUserReset) },
+    { "RTThreadUserWait",                       (void *)UNWIND_WRAP(RTThreadUserWait) },
+    { "RTThreadUserWaitNoResume",               (void *)UNWIND_WRAP(RTThreadUserWaitNoResume) },
 #endif
     { "RTLogDefaultInstance",                   (void *)RTLogDefaultInstance },
     { "RTMpCpuId",                              (void *)RTMpCpuId },
@@ -227,55 +374,21 @@
     { "RTMpGetOnlineSet",                       (void *)RTMpGetOnlineSet },
     { "RTMpGetSet",                             (void *)RTMpGetSet },
     { "RTMpIsCpuOnline",                        (void *)RTMpIsCpuOnline },
-    { "RTMpOnAll",                              (void *)RTMpOnAll },
-    { "RTMpOnOthers",                           (void *)RTMpOnOthers },
-    { "RTMpOnSpecific",                         (void *)RTMpOnSpecific },
+    { "RTMpOnAll",                              (void *)UNWIND_WRAP(RTMpOnAll) },
+    { "RTMpOnOthers",                           (void *)UNWIND_WRAP(RTMpOnOthers) },
+    { "RTMpOnSpecific",                         (void *)UNWIND_WRAP(RTMpOnSpecific) },
     { "RTLogRelDefaultInstance",                (void *)RTLogRelDefaultInstance },
-    { "RTLogSetDefaultInstanceThread",          (void *)RTLogSetDefaultInstanceThread },
-    { "RTLogLogger",                            (void *)RTLogLogger },
-    { "RTLogLoggerEx",                          (void *)RTLogLoggerEx },
-    { "RTLogLoggerExV",                         (void *)RTLogLoggerExV },
-    { "RTLogPrintf",                            (void *)RTLogPrintf },
-    { "RTLogPrintfV",                           (void *)RTLogPrintfV },
-    { "AssertMsg1",                             (void *)AssertMsg1 },
-    { "AssertMsg2",                             (void *)AssertMsg2 },
+    { "RTLogSetDefaultInstanceThread",          (void *)UNWIND_WRAP(RTLogSetDefaultInstanceThread) },
+    { "RTLogLogger",                            (void *)RTLogLogger }, /** @todo remove this */
+    { "RTLogLoggerEx",                          (void *)RTLogLoggerEx }, /** @todo remove this */
+    { "RTLogLoggerExV",                         (void *)UNWIND_WRAP(RTLogLoggerExV) },
+    { "RTLogPrintf",                            (void *)RTLogPrintf }, /** @todo remove this */
+    { "RTLogPrintfV",                           (void *)UNWIND_WRAP(RTLogPrintfV) },
+    { "AssertMsg1",                             (void *)UNWIND_WRAP(AssertMsg1) },
+    { "AssertMsg2",                             (void *)AssertMsg2 }, /** @todo replace this by RTAssertMsg2V */
 };
 
 
-/*******************************************************************************
-*   Internal Functions                                                         *
-*******************************************************************************/
-static int      supdrvMemAdd(PSUPDRVMEMREF pMem, PSUPDRVSESSION pSession);
-static int      supdrvMemRelease(PSUPDRVSESSION pSession, RTHCUINTPTR uPtr, SUPDRVMEMREFTYPE eType);
-#ifdef VBOX_WITH_IDT_PATCHING
-static int      supdrvIOCtl_IdtInstall(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPIDTINSTALL pReq);
-static PSUPDRVPATCH supdrvIdtPatchOne(PSUPDRVDEVEXT pDevExt, PSUPDRVPATCH pPatch);
-static int      supdrvIOCtl_IdtRemoveAll(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession);
-static void     supdrvIdtRemoveOne(PSUPDRVDEVEXT pDevExt, PSUPDRVPATCH pPatch);
-static void     supdrvIdtWrite(volatile void *pvIdtEntry, const SUPDRVIDTE *pNewIDTEntry);
-#endif /* VBOX_WITH_IDT_PATCHING */
-static int      supdrvIOCtl_LdrOpen(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDROPEN pReq);
-static int      supdrvIOCtl_LdrLoad(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDRLOAD pReq);
-static int      supdrvIOCtl_LdrFree(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDRFREE pReq);
-static int      supdrvIOCtl_LdrGetSymbol(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPLDRGETSYMBOL pReq);
-static int      supdrvIDC_LdrGetSymbol(PSUPDRVDEVEXT pDevExt, PSUPDRVSESSION pSession, PSUPDRVIDCREQGETSYM pReq);
-static int      supdrvLdrSetR0EP(PSUPDRVDEVEXT pDevExt, void *pvVMMR0, void *pvVMMR0EntryInt, void *pvVMMR0EntryFast, void *pvVMMR0EntryEx);
-static void     supdrvLdrUnsetR0EP(PSUPDRVDEVEXT pDevExt);
-static int      supdrvLdrAddUsage(PSUPDRVSESSION pSession, PSUPDRVLDRIMAGE pImage);
-static void     supdrvLdrFree(PSUPDRVDEVEXT pDevExt, PSUPDRVLDRIMAGE pImage);
-static SUPPAGINGMODE supdrvIOCtl_GetPagingMode(void);
-static SUPGIPMODE supdrvGipDeterminTscMode(PSUPDRVDEVEXT pDevExt);
-#ifdef RT_OS_WINDOWS
-static int      supdrvPageGetPhys(PSUPDRVSESSION pSession, RTR3PTR pvR3, uint32_t cPages, PRTHCPHYS paPages);
-static bool     supdrvPageWasLockedByPageAlloc(PSUPDRVSESSION pSession, RTR3PTR pvR3);
-#endif /* RT_OS_WINDOWS */
-static int      supdrvGipCreate(PSUPDRVDEVEXT pDevExt);
-static void     supdrvGipDestroy(PSUPDRVDEVEXT pDevExt);
-static DECLCALLBACK(void) supdrvGipSyncTimer(PRTTIMER pTimer, void *pvUser, uint64_t iTick);
-static DECLCALLBACK(void) supdrvGipAsyncTimer(PRTTIMER pTimer, void *pvUser, uint64_t iTick);
-static DECLCALLBACK(void) supdrvGipMpEvent(RTMPEVENT enmEvent, RTCPUID idCpu, void *pvUser);
-
-
 /**
  * Initializes the device extentsion structure.
  *
@@ -568,7 +681,11 @@
                 Log(("supdrvCleanupSession: destroying %p/%d (%p/%p) cpid=%RTproc pid=%RTproc dtor=%p\n",
                      pObj, pObj->enmType, pObj->pvUser1, pObj->pvUser2, pObj->CreatorProcess, RTProcSelf(), pObj->pfnDestructor));
                 if (pObj->pfnDestructor)
+#ifdef SUPDRV_WITH_UNWIND_HACK
+                    supdrvNtWrapObjDestructor((PFNRT)pObj->pfnDestructor, pObj, pObj->pvUser1, pObj->pvUser2);
+#else
                     pObj->pfnDestructor(pObj, pObj->pvUser1, pObj->pvUser2);
+#endif
                 RTMemFree(pObj);
             }
 
@@ -728,13 +845,25 @@
         switch (uIOCtl)
         {
             case SUP_IOCTL_FAST_DO_RAW_RUN:
+#ifdef SUPDRV_WITH_UNWIND_HACK
+                supdrvNtWrapVMMR0EntryFast((PFNRT)pDevExt->pfnVMMR0EntryFast, pSession->pVM, SUP_VMMR0_DO_RAW_RUN);
+#else
                 pDevExt->pfnVMMR0EntryFast(pSession->pVM, SUP_VMMR0_DO_RAW_RUN);
+#endif
                 break;
             case SUP_IOCTL_FAST_DO_HWACC_RUN:
+#ifdef SUPDRV_WITH_UNWIND_HACK
+                supdrvNtWrapVMMR0EntryFast((PFNRT)pDevExt->pfnVMMR0EntryFast, pSession->pVM, SUP_VMMR0_DO_HWACC_RUN);
+#else
                 pDevExt->pfnVMMR0EntryFast(pSession->pVM, SUP_VMMR0_DO_HWACC_RUN);
+#endif
                 break;
             case SUP_IOCTL_FAST_DO_NOP:
+#ifdef SUPDRV_WITH_UNWIND_HACK
+                supdrvNtWrapVMMR0EntryFast((PFNRT)pDevExt->pfnVMMR0EntryFast, pSession->pVM, SUP_VMMR0_DO_NOP);
+#else
                 pDevExt->pfnVMMR0EntryFast(pSession->pVM, SUP_VMMR0_DO_NOP);
+#endif
                 break;
             default:
                 return VERR_INTERNAL_ERROR;
@@ -1708,7 +1837,11 @@
         Log(("SUPR0ObjRelease: destroying %p/%d (%p/%p) cpid=%RTproc pid=%RTproc dtor=%p\n",
              pObj, pObj->enmType, pObj->pvUser1, pObj->pvUser2, pObj->CreatorProcess, RTProcSelf(), pObj->pfnDestructor));
         if (pObj->pfnDestructor)
+#ifdef SUPDRV_WITH_UNWIND_HACK
+            supdrvNtWrapObjDestructor((PFNRT)pObj->pfnDestructor, pObj, pObj->pvUser1, pObj->pvUser2);
+#else
             pObj->pfnDestructor(pObj, pObj->pvUser1, pObj->pvUser2);
+#endif
         RTMemFree(pObj);
     }
 
@@ -2126,8 +2259,8 @@
                         )
                    )
                 {
-                    const unsigned cPages = RTR0MemObjSize(pBundle->aMem[i].MemObj) >> PAGE_SHIFT;
-                    unsigned iPage;
+                    const size_t cPages = RTR0MemObjSize(pBundle->aMem[i].MemObj) >> PAGE_SHIFT;
+                    size_t iPage;
                     for (iPage = 0; iPage < cPages; iPage++)
                     {
                         paPages[iPage].Phys = RTR0MemObjGetPagePhysAddr(pBundle->aMem[i].MemObj, iPage);
@@ -2303,8 +2436,9 @@
                     &&  pBundle->aMem[i].MapObjR3 != NIL_RTR0MEMOBJ
                     &&  RTR0MemObjAddressR3(pBundle->aMem[i].MapObjR3) == pvR3)
                 {
-                    uint32_t iPage = RTR0MemObjSize(pBundle->aMem[i].MemObj) >> PAGE_SHIFT;
-                    cPages = RT_MIN(iPage, cPages);
+                    uint32_t iPage;
+                    size_t cMaxPages = RTR0MemObjSize(pBundle->aMem[i].MemObj) >> PAGE_SHIFT;
+                    cPages = (uint32_t)RT_MIN(cMaxPages, cPages);
                     for (iPage = 0; iPage < cPages; iPage++)
                         paPages[iPage] = RTR0MemObjGetPagePhysAddr(pBundle->aMem[i].MemObj, iPage);
                     RTSpinlockRelease(pSession->Spinlock, &SpinlockTmp);
@@ -2680,7 +2814,11 @@
             if (    pCur->cchName == cchName
                 &&  !memcmp(pCur->pFactory->szName, pszName, cchName))
             {
+#ifdef SUPDRV_WITH_UNWIND_HACK
+                void *pvFactory = supdrvNtWrapQueryFactoryInterface((PFNRT)pCur->pFactory->pfnQueryFactoryInterface, pCur->pFactory, pSession, pszInterfaceUuid);
+#else
                 void *pvFactory = pCur->pFactory->pfnQueryFactoryInterface(pCur->pFactory, pSession, pszInterfaceUuid);
+#endif
                 if (pvFactory)
                 {
                     *ppvFactoryIf = pvFactory;
@@ -3557,6 +3695,10 @@
     pReq->u.Out.pvImageBase = pImage->pvImage;
     pReq->u.Out.fNeedsLoading = true;
     RTSemFastMutexRelease(pDevExt->mtxLdr);
+
+#if defined(RT_OS_WINDOWS) && defined(DEBUG)
+    SUPR0Printf("VBoxDrv: windbg> .reload /f %s=%#p\n", pImage->szName, pImage->pvImage);
+#endif
     return VINF_SUCCESS;
 }
 
@@ -3691,7 +3833,11 @@
     if (RT_SUCCESS(rc) && pImage->pfnModuleInit)
     {
         Log(("supdrvIOCtl_LdrLoad: calling pfnModuleInit=%p\n", pImage->pfnModuleInit));
+#ifdef SUPDRV_WITH_UNWIND_HACK
+        rc = supdrvNtWrapModuleInit((PFNRT)pImage->pfnModuleInit);
+#else
         rc = pImage->pfnModuleInit();
+#endif
         if (rc && pDevExt->pvVMMR0 == pImage->pvImage)
             supdrvLdrUnsetR0EP(pDevExt);
     }
@@ -4161,7 +4307,11 @@
         &&  pImage->uState == SUP_IOCTL_LDR_LOAD)
     {
         LogFlow(("supdrvIOCtl_LdrLoad: calling pfnModuleTerm=%p\n", pImage->pfnModuleTerm));
+#ifdef SUPDRV_WITH_UNWIND_HACK
+        supdrvNtWrapModuleTerm(pImage->pfnModuleTerm);
+#else
         pImage->pfnModuleTerm();
+#endif
     }
 
     /* free the image */
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPDrvInternal.h vbox/src/VBox/HostDrivers/Support/SUPDrvInternal.h
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPDrvInternal.h	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/SUPDrvInternal.h	2008-09-08 10:07:22.000000000 +0200
@@ -240,6 +240,21 @@
 #endif
 
 
+/** @def SUPDRV_WITH_UNWIND_HACK
+ * Changes a function name into the wrapped version if we've
+ * enabled the unwind hack.
+ *
+ * The unwind hack is for making the NT unwind procedures skip
+ * our dynamically loaded code when they try to walk the call
+ * stack. Needless to say, they kind of don't expect what
+ * we're doing here and get kind of confused and may BSOD. */
+#ifdef SUPDRV_WITH_UNWIND_HACK
+# define UNWIND_WRAP(Name)  supdrvNtWrap##Name
+#else
+# define UNWIND_WRAP(Name)  Name
+#endif
+
+
 /*
  * Error codes.
  */
@@ -669,12 +684,6 @@
 bool VBOXCALL   supdrvOSObjCanAccess(PSUPDRVOBJ pObj, PSUPDRVSESSION pSession, const char *pszObjName, int *prc);
 bool VBOXCALL   supdrvOSGetForcedAsyncTscMode(PSUPDRVDEVEXT pDevExt);
 
-#ifdef SUPDRV_WITH_UNWIND_HACK
-DECLASM(int) supdrvNtWrapVMMR0EntryEx(PFNRT pfnVMMR0EntryEx, PVM pVM, unsigned uOperation, PSUPVMMR0REQHDR pReq, uint64_t u64Arg, PSUPDRVSESSION pSession);
-DECLASM(int) supdrvNtWrapRTSemEventMultiWaitNoResume(RTSEMEVENTMULTI EventMultiSem, unsigned cMillies);
-#endif
-
-
 /*******************************************************************************
 *   Shared Functions                                                           *
 *******************************************************************************/
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPR0.def vbox/src/VBox/HostDrivers/Support/SUPR0.def
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPR0.def	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/SUPR0.def	2008-09-08 10:07:22.000000000 +0200
@@ -109,10 +109,7 @@
     RTLogDefaultInstance
     RTLogRelDefaultInstance
     RTLogSetDefaultInstanceThread
-    RTLogLogger
-    RTLogLoggerEx
     RTLogLoggerExV
-    RTLogPrintf
     RTLogPrintfV
     AssertMsg1
     AssertMsg2
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPR3HardenedMain.cpp vbox/src/VBox/HostDrivers/Support/SUPR3HardenedMain.cpp
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/SUPR3HardenedMain.cpp	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/SUPR3HardenedMain.cpp	2008-09-08 10:07:22.000000000 +0200
@@ -270,7 +270,7 @@
 
 /**
  * Returns the full path to the executable.
- * 
+ *
  * @returns IPRT status code.
  * @param   pszPath     Where to store it.
  * @param   cchPath     How big that buffer is.
@@ -320,7 +320,7 @@
 #else
 # error needs porting.
 #endif
-    
+
     /*
      * Strip off the filename part (RTPathStripFilename()).
      */
@@ -332,10 +332,10 @@
 #ifdef RT_OS_LINUX
 /**
  * Checks if we can read /proc/self/exe.
- * 
- * This is used on linux to see if we have to call init 
+ *
+ * This is used on linux to see if we have to call init
  * with program path or not.
- * 
+ *
  * @returns true / false.
  */
 static bool supR3HardenedMainIsProcSelfExeAccssible(void)
@@ -538,7 +538,7 @@
 #ifdef RT_OS_LINUX
     if (!supR3HardenedMainIsProcSelfExeAccssible())
         pszExePath = g_szSupLibHardenedExePath;
-#endif 
+#endif
     rc = pfnRTInitEx(0, pszExePath, !(fFlags & SUPSECMAIN_FLAGS_DONT_OPEN_DEV));
     if (RT_FAILURE(rc))
         supR3HardenedFatal("RTR3Init: Failed with rc=%d\n", rc);
@@ -634,8 +634,8 @@
         supR3HardenedFatal("SUPR3HardenedMain: effective uid is not root (euid=%d egid=%d uid=%d gid=%d)\n",
                            geteuid(), getegid(), uid, gid);
 
-# ifdef RT_OS_LINUX 
-    /* 
+# ifdef RT_OS_LINUX
+    /*
      * On linux we have to make sure the path is initialized because we
      * *might* not be able to access /proc/self/exe after the seteuid call.
      */
@@ -663,13 +663,63 @@
 #ifdef SUP_HARDENED_SUID
     /*
      * Drop any root privileges we might be holding.
+     *
+     * Try use setre[ug]id since this will clear the save uid/gid and thus
+     * leave fewer traces behind that libs like GTK+ may pick up.
      */
-    setegid(gid);
-    seteuid(uid);
-    if (    geteuid() != uid
-        ||  getegid() != gid)
-        supR3HardenedFatal("SUPR3HardenedMain: failed to drop root privileges! (euid=%d egid=%d; wanted %d and %d)\n",
-                           geteuid(), getegid(), uid, gid);
+    uid_t euid, ruid, suid;
+    gid_t egid, rgid, sgid;
+# if defined(RT_OS_DARWIN)
+    /* The really great thing here is that setreuid isn't available on
+       OS X 10.4, libc emulates it. While 10.4 have a sligtly different and
+       non-standard setuid implementation compared to 10.5, the following
+       works the same way with both version since we're super user (10.5 req).
+       The following will set all three variants of the group and user IDs. */
+    setgid(gid);
+    setuid(uid);
+    euid = geteuid();
+    ruid = suid = getuid();
+    egid = getegid();
+    rgid = sgid = getgid();
+
+# elif defined(RT_OS_SOLARIS)
+    /* Solaris doesn't have setresuid, but the setreuid interface is BSD
+       compatible and will set the saved uid to euid when we pass it a ruid
+       that isn't -1 (which we do). */
+    setregid(gid, gid);
+    setreuid(uid, uid);
+    euid = geteuid();
+    ruid = suid = getuid();
+    egid = getegid();
+    rgid = sgid = getgid();
+
+# else
+    /* This is the preferred one, full control no questions about semantics.
+       PORTME: If this isn't work, try join one of two other gangs above. */
+    setresgid(gid, gid, gid);
+    setresuid(uid, uid, gid);
+    if (getresuid(&ruid, &euid, &suid) != 0)
+    {
+        euid = geteuid();
+        ruid = suid = getuid();
+    }
+    if (getresgid(&rgid, &egid, &sgid) != 0)
+    {
+        egid = getegid();
+        rgid = sgid = getgid();
+    }
+# endif
+
+    /* Check that it worked out all right. */
+    if (    euid != uid
+        ||  ruid != uid
+        ||  suid != uid
+        ||  egid != gid
+        ||  rgid != gid
+        ||  sgid != gid)
+        supR3HardenedFatal("SUPR3HardenedMain: failed to drop root privileges!"
+                           " (euid=%d ruid=%d suid=%d  egid=%d rgid=%d sgid=%d; wanted uid=%d and gid=%d)\n",
+                           euid, ruid, suid, egid, rgid, sgid, uid, gid);
 #endif
 
     /*
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/Support/win/SUPDrvA-win.asm vbox/src/VBox/HostDrivers/Support/win/SUPDrvA-win.asm
--- VirtualBox-2.0.0/src/VBox/HostDrivers/Support/win/SUPDrvA-win.asm	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/Support/win/SUPDrvA-win.asm	2008-09-08 10:07:22.000000000 +0200
@@ -53,141 +53,546 @@
 
 
 %ifdef SUPDRV_WITH_UNWIND_HACK
- %if 0 ; def RT_ARCH_AMD64
+ %ifdef RT_ARCH_AMD64
+
 ;;
-; @cproto DECLASM(int) supdrvNtWrapVMMR0EntryEx(PFNRT pfnVMMR0EntryEx, PVM pVM, unsigned uOperation, PSUPVMMR0REQHDR pReq, uint64_t u64Arg, PSUPDRVSESSION pSession);
+; Common prolog, take the proc name as argument.
+; This creates a 0x80 byte stack frame.
 ;
-; @param    pfnVMMR0EntryEx     rcx
-; @param    pVM                 rdx
-; @param    uOperation          r8
-; @param    pReq                r9
-; @param    u64Arg              [rsp + 28h] / [rbp + 30h]
-; @param    pSession            [rsp + 30h] / [rbp + 38h]
-;
-BEGINPROC supdrvNtWrapVMMR0EntryEx
-[proc_frame supdrvNtWrapVMMR0EntryEx]
+%macro NtWrapProlog 1
+[proc_frame %1]
         push    rbp
         [pushreg rbp]
         mov     rbp, rsp
-        [setframe rbp,0]
-        sub     rsp, 80h
+        [setframe rbp, 0]
+        sub     rsp, 0x80
         [allocstack 0x80]
-        ;; @todo save more regs?
+
+        ; save rdi and load rbp into it
+        mov     [rbp - 8h], rdi
+        [savereg rdi, 0x78]
+        mov     rdi, rbp
 [endprolog]
+%endmacro
 
-        ;
-        ; Create a stack marker with the rbp. The marker is 32 byte big.
-        ; This is 32-byte aligned and 32 byte in size.
-        ;
+;;
+; Common epilog, take the proc name as argument.
+%macro NtWrapEpilog 1
+        ; restore rbp and rdi then return.
+        mov     rbp, rdi
+        mov     rdi, [rdi - 8h]
+        leave
+        ret
+[endproc_frame %1]
+%endmacro
+
+;;
+; Create a stack marker with the rbp. The marker is 32 byte big.
+; This is 32-byte aligned and 32 byte in size.
+;
+; Trashes r10
+%macro NtWrapCreateMarker 0
+        lea     r10, [rbp - 30h]
+        and     r10, ~1fh               ; 32-byte align it.
+        mov     dword [r10      ], 0x20080901
+        mov     dword [r10 + 04h], 0x20080902
+        mov     qword [r10 + 08h], rbp
+        mov     dword [r10 + 10h], 0x20080903
+        mov     dword [r10 + 14h], 0x20080904
+        mov     qword [r10 + 18h], rbp
+%endmacro
+
+;;
+; Destroys the stack marker.
+;
+; Trashes r10
+%macro NtWrapDestroyMarker 0
         lea     r10, [rbp - 30h]
         and     r10, ~1fh               ; 32-byte align it.
-        mov     dword [r10    ], 0x20080901
-        mov     dword [r10 + 4], 0x20080902
-        mov     qword [r10 + 8], rbp
-        mov     dword [r10 +16], 0x20080903
-        mov     dword [r10 +20], 0x20080904
-        mov     qword [r10 +24], rbp
+        mov     [r10      ], rbp
+        mov     [r10 + 08h], rbp
+        mov     [r10 + 10h], rbp
+        mov     [r10 + 18h], rbp
+%endmacro
+
+;;
+; Find the stack marker with the rbp of the entry frame.
+;
+; Search the current stack page inline, call a helper function
+; which does a safe search of any further stack pages.
+;
+; Trashes       rax, r10 and r11.
+; Modifies      rbp
+;
+%macro NtWrapLocateMarker 0
+        mov     rax, rbp
+        and     rax, ~1fh               ; 32-byte align it.
 
         ;
-        ; Forward the call.
+        ; Calc remainig space in the current page. If we're on a
+        ; page boundrary, we'll search the entire previous page.
         ;
-        mov     rax, rcx
-        mov     rcx, rdx
-        mov     rdx, r8

-        mov     r8, r9
-        mov     r9, [rbp + 30h]
-        mov     r11, [rbp + 38h]
-        mov     [rsp + 20h], r11
-        call    rax
+        mov     r10, rax
+        neg     r10
+        and     r10, 0fffh
+        inc     r10
+        shr     r10, 5                  ; /= 32 bytes
+        jz      %%not_found             ; If zero, take the slow path
 
         ;
-        ; Trash the stack marker.
+        ; The search loop.
         ;
-        lea     r10, [rbp - 30h]
-        and     r10, ~1fh               ; 32-byte align it.
-        mov     qword [r10    ], rax
-        mov     qword [r10 + 8], rax
-        mov     qword [r10 +16], rax
-        mov     qword [r10 +24], rax
+%%again:
+        dec     r10
+        lea     rax, [rax + 20h]
+        jz      %%not_found
+        cmp     dword [rax      ], 0x20080901
+        je      %%candidate
+        jmp     %%again
+
+%%not_found:
+        call    NAME(NtWrapLocateMarkerHelper)
+        jmp     %%done
+
+%%candidate:
+        cmp     dword [rax + 04h], 0x20080902
+        jne     %%again
+        cmp     dword [rax + 10h], 0x20080903
+        jne     %%again
+        cmp     dword [rax + 14h], 0x20080904
+        jne     %%again
+        mov     r11,  [rax + 08h]
+        cmp     r11,  [rax + 18h]
+        jne     %%again
 
-        leave
-        ret
-[endproc_frame supdrvNtWrapVMMR0EntryEx]
-ENDPROC   supdrvNtWrapVMMR0EntryEx
+        ; found it, change rbp.
+        mov     rbp, r11
+%%done:
+%endmacro
+
+;;
+; Wraps a function with 4 or less argument that will go into registers.
+%macro NtWrapFunctionWithAllRegParams 1
+extern NAME(%1)
+BEGINPROC supdrvNtWrap%1
+        NtWrapProlog supdrvNtWrap%1
+        NtWrapLocateMarker
+
+        call    NAME(%1)
+
+        NtWrapEpilog supdrvNtWrap%1
+ENDPROC   supdrvNtWrap%1
+%endmacro
+
+;;
+; Wraps a function with 5 argument, where the first 4 goes into registers.
+%macro NtWrapFunctionWith5Params 1
+extern NAME(%1)
+BEGINPROC supdrvNtWrap%1
+        NtWrapProlog supdrvNtWrap%1
+        NtWrapLocateMarker
+
+        mov     r11, [rdi + 30h]
+        mov     [rsp + 20h], r11
+        call    NAME(%1)
+
+        NtWrapEpilog supdrvNtWrap%1
+ENDPROC   supdrvNtWrap%1
+%endmacro
+
+;;
+; Wraps a function with 6 argument, where the first 4 goes into registers.
+%macro NtWrapFunctionWith6Params 1
+extern NAME(%1)
+BEGINPROC supdrvNtWrap%1
+        NtWrapProlog supdrvNtWrap%1
+        NtWrapLocateMarker
+
+        mov     r11, [rdi + 30h]
+        mov     [rsp + 20h], r11
+        mov     r10, [rdi + 38h]
+        mov     [rsp + 28h], r10
+        call    NAME(%1)
+
+        NtWrapEpilog supdrvNtWrap%1
+ENDPROC   supdrvNtWrap%1
+%endmacro
 
+;;
+; Wraps a function with 7 argument, where the first 4 goes into registers.
+%macro NtWrapFunctionWith7Params 1
+extern NAME(%1)
+BEGINPROC supdrvNtWrap%1
+        NtWrapProlog supdrvNtWrap%1
+        NtWrapLocateMarker
+
+        mov     r11, [rdi + 30h]
+        mov     [rsp + 20h], r11
+        mov     r10, [rdi + 38h]
+        mov     [rsp + 28h], r10
+        mov     rax, [rdi + 40h]
+        mov     [rsp + 30h], rax
+        call    NAME(%1)
+
+        NtWrapEpilog supdrvNtWrap%1
+ENDPROC   supdrvNtWrap%1
+%endmacro
 
-extern RTSemEventMultiWaitNoResume
+extern IoGetStackLimits
 
 ;;
-; @cproto DECLASM(int) supdrvNtWrapRTSemEventMultiWaitNoResume(RTSEMEVENTMULTI EventMultiSem, unsigned cMillies);
+; Helper that cautiously continues the stack marker search
+; NtWrapLocateMarker started.
 ;
-; @param    EventMultiSem       rcx
-; @param    cMillies            rdx
+; The stack layout at the time is something like this.
+;       rbp+08h         callers return address.
+;       rbp-00h         saved rbp
+;       rbp-08h         saved rdi
+;       rbp-09h
+;         thru          unused.
+;       rbp-80h
+;       rbp-88h         our return address.
+;       rbp-89h
+;         thru          callee register dump zone.
+;       rbp-a0h
 ;
-BEGINPROC supdrvNtWrapRTSemEventMultiWaitNoResume
-[proc_frame supdrvNtWrapRTSemEventMultiWaitNoResume]
-        push    rbp
-        [pushreg rbp]
-        mov     rbp, rsp
-        [setframe rbp,0]
-        sub     rsp, 40h
-        [allocstack 0x40]
-        mov     [rbp - 8h], rdi
-        [savereg rdi, 0x38]
-        ;; @todo save more?
-        ;mov     [rbp - 10h], rsi
-        ;[savereg rsi, 0x30]
-[endprolog]
-
+; @param    rax         Current stack location.
+; @param    rdi         Parent stack frame pointer. (This should equal rbp on entry.)
+;
+; Trashes:  rax, r10, r11.
+;           Will use the callers stack frame for register saving ASSUMING that
+;           rbp-80h thru rbp-09h is unused.
+;
+; Modifies: rbp
+;
+BEGINPROC NtWrapLocateMarkerHelper
         ;
-        ; Find the stack marker with the rbp of the entry frame.
-        ; Search a maximum of 4096 bytes.
+        ; Prolog. Save volatile regs and reserve callee space.
         ;
-        mov     rax, rbp
-        and     rax, ~1fh               ; 32-byte align it.
-        mov     r10, 1000h / 20h
-.again:
+        sub     rsp, 20h                ; For IoGetStackLimits().
+        mov     [rdi - 80h], rax
+        mov     [rdi - 78h], rcx
+        mov     [rdi - 70h], rdx
+        mov     [rdi - 68h], r8
+        mov     [rdi - 60h], r9
+
+        ;
+        ; Call VOID IoGetStackLimits(OUT PULONG_PTR LowLimit, OUT PULONG_PTR HighLimit);
+        ;
+        ; Use rdi-40h for the high limit and rdi-50h for the low one, we're only
+        ; interested in the high one.
+        ;
+        lea     rcx, [rdi - 40h]        ; arg #1 LowLimit
+        lea     rdx, [rdi - 50h]        ; arg #2 HighLimit
+        mov     [rdx], eax              ; paranoia - init to end of current search.
+        call    IoGetStackLimits
+
+        ;
+        ; Move the top address into r10, restore rax and continue
+        ; the search. Check that r10 is less than 3 pages from rax.
+        ;
+        mov     rax, [rdi - 80h]        ; Restore eax (see prolog)
+        mov     r10, [rdi - 50h]        ; HighLimit
+        and     r10, ~1fh               ; 32-byte align it (downwards)
+        sub     r10, rax
+        jz      .not_found              ; If already at the top of the stack.
+        cmp     r10, 3000h
+        jae     .out_of_bounds          ; If too far away, something is busted.
+        shr     r10, 5                  ; /= 32.
+
+        ; The loop body.
+.search_loop:
+        cmp     dword [rax      ], 0x20080901
+        je      .candidate
+.continue_searching:
         dec     r10
         jz      .not_found
-        add     rax, 20h
+        lea     rax, [rax + 20h]
+        jmp     .search_loop
 
-        cmp     dword [rax], 0x20080901
-        jne     .again
-        cmp     dword [rax + 4], 0x20080902
-        jne     .again
-        cmp     dword [rax + 16], 0x20080903
-        jne     .again
-        cmp     dword [rax + 20], 0x20080904
-        jne     .again
-        mov     r11, [rax + 8]
-        cmp     r11, [rax + 24]
-        jne     .again
+        ; Found the first marker, check for the rest.
+.candidate:
+        cmp     dword [rax + 04h], 0x20080902
+        jne     .continue_searching
+        cmp     dword [rax + 10h], 0x20080903
+        jne     .continue_searching
+        cmp     dword [rax + 14h], 0x20080904
+        jne     .continue_searching
+        mov     r11,  [rax + 08h]
+        cmp     r11,  [rax + 18h]
+        jne     .continue_searching
 
         ; found it, change rbp.
-        mov     rdi, rbp
         mov     rbp, r11
 
         ;
-        ; Forward the call.
+        ; Restore registers and pop the stack frame.
         ;
-.resume:
-        call    RTSemEventMultiWaitNoResume
+.epilog:
+        mov     r9,  [rdi - 60h]
+        mov     r8,  [rdi - 68h]
+        mov     rdx, [rdi - 70h]
+        mov     rcx, [rdi - 78h]
+        ; mov     rax, [rdi - 80h]
+        add     rsp, 20h
+        ret
 
         ;
-        ; Restore rbp and any saved registers before returning.
+        ; Needless to say, this isn't supposed to happen. Thus the int3.
+        ; Note down r10 and rax.
         ;
-        mov     rbp, rdi
-        ;mov     rsi, [rbp - 10h]
-        mov     rdi, [rbp - 8h]
-        leave
-        ret
-
+.out_of_bounds:
+%ifdef DEBUG
+        int3
+%endif
 .not_found:
+%ifdef DEBUG
         int3
-        mov     rdi, rbp
-        jmp     .resume
-[endproc_frame supdrvNtWrapRTSemEventMultiWaitNoResume]
-ENDPROC   supdrvNtWrapRTSemEventMultiWaitNoResume
+%endif
+        jmp     .epilog
+ENDPROC   NtWrapLocateMarkerHelper
+
+
+
+;
+; This has the same order as the list in SUPDrv.c
+;
+NtWrapFunctionWithAllRegParams  SUPR0ComponentRegisterFactory
+NtWrapFunctionWithAllRegParams  SUPR0ComponentDeregisterFactory
+NtWrapFunctionWithAllRegParams  SUPR0ComponentQueryFactory
+NtWrapFunctionWith5Params       SUPR0ObjRegister
+NtWrapFunctionWithAllRegParams  SUPR0ObjAddRef
+NtWrapFunctionWithAllRegParams  SUPR0ObjRelease
+NtWrapFunctionWithAllRegParams  SUPR0ObjVerifyAccess
+NtWrapFunctionWithAllRegParams  SUPR0LockMem
+NtWrapFunctionWithAllRegParams  SUPR0UnlockMem
+NtWrapFunctionWith5Params       SUPR0ContAlloc
+NtWrapFunctionWithAllRegParams  SUPR0ContFree
+NtWrapFunctionWith5Params       SUPR0LowAlloc
+NtWrapFunctionWithAllRegParams  SUPR0LowFree
+NtWrapFunctionWithAllRegParams  SUPR0MemAlloc
+NtWrapFunctionWithAllRegParams  SUPR0MemGetPhys
+NtWrapFunctionWithAllRegParams  SUPR0MemFree
+NtWrapFunctionWithAllRegParams  SUPR0PageAlloc
+NtWrapFunctionWithAllRegParams  SUPR0PageFree
+;NtWrapFunctionWithAllRegParams  SUPR0Printf            - cannot wrap this buster.
+NtWrapFunctionWithAllRegParams  RTMemAlloc
+NtWrapFunctionWithAllRegParams  RTMemAllocZ
+NtWrapFunctionWithAllRegParams  RTMemFree
+NtWrapFunctionWithAllRegParams  RTMemDup
+NtWrapFunctionWithAllRegParams  RTMemDupEx
+NtWrapFunctionWithAllRegParams  RTMemRealloc
+NtWrapFunctionWithAllRegParams  RTR0MemObjAllocLow
+NtWrapFunctionWithAllRegParams  RTR0MemObjAllocPage
+NtWrapFunctionWithAllRegParams  RTR0MemObjAllocPhys
+NtWrapFunctionWithAllRegParams  RTR0MemObjAllocPhysNC
+NtWrapFunctionWithAllRegParams  RTR0MemObjAllocCont
+NtWrapFunctionWithAllRegParams  RTR0MemObjLockUser
+NtWrapFunctionWith5Params       RTR0MemObjMapKernel
+NtWrapFunctionWith6Params       RTR0MemObjMapUser
+;NtWrapFunctionWithAllRegParams  RTR0MemObjAddress      - not necessary
+;NtWrapFunctionWithAllRegParams  RTR0MemObjAddressR3    - not necessary
+;NtWrapFunctionWithAllRegParams  RTR0MemObjSize         - not necessary
+;NtWrapFunctionWithAllRegParams  RTR0MemObjIsMapping    - not necessary
+;NtWrapFunctionWithAllRegParams  RTR0MemObjGetPagePhysAddr - not necessary
+NtWrapFunctionWithAllRegParams  RTR0MemObjFree
+;NtWrapFunctionWithAllRegParams  RTProcSelf             - not necessary
+;NtWrapFunctionWithAllRegParams  RTR0ProcHandleSelf     - not necessary
+NtWrapFunctionWithAllRegParams  RTSemFastMutexCreate
+NtWrapFunctionWithAllRegParams  RTSemFastMutexDestroy
+NtWrapFunctionWithAllRegParams  RTSemFastMutexRequest
+NtWrapFunctionWithAllRegParams  RTSemFastMutexRelease
+NtWrapFunctionWithAllRegParams  RTSemEventCreate
+NtWrapFunctionWithAllRegParams  RTSemEventSignal
+NtWrapFunctionWithAllRegParams  RTSemEventWait
+NtWrapFunctionWithAllRegParams  RTSemEventWaitNoResume
+NtWrapFunctionWithAllRegParams  RTSemEventDestroy
+NtWrapFunctionWithAllRegParams  RTSemEventMultiCreate
+NtWrapFunctionWithAllRegParams  RTSemEventMultiSignal
+NtWrapFunctionWithAllRegParams  RTSemEventMultiReset
+NtWrapFunctionWithAllRegParams  RTSemEventMultiWait
+NtWrapFunctionWithAllRegParams  RTSemEventMultiWaitNoResume
+NtWrapFunctionWithAllRegParams  RTSemEventMultiDestroy
+NtWrapFunctionWithAllRegParams  RTSpinlockCreate
+NtWrapFunctionWithAllRegParams  RTSpinlockDestroy
+NtWrapFunctionWithAllRegParams  RTSpinlockAcquire
+NtWrapFunctionWithAllRegParams  RTSpinlockRelease
+NtWrapFunctionWithAllRegParams  RTSpinlockAcquireNoInts
+NtWrapFunctionWithAllRegParams  RTSpinlockReleaseNoInts
+;NtWrapFunctionWithAllRegParams  RTTimeNanoTS           - not necessary
+;NtWrapFunctionWithAllRegParams  RTTimeMilliTS          - not necessary
+;NtWrapFunctionWithAllRegParams  RTTimeSystemNanoTS     - not necessary
+;NtWrapFunctionWithAllRegParams  RTTimeSystemMilliTS    - not necessary
+;NtWrapFunctionWithAllRegParams  RTThreadNativeSelf     - not necessary
+NtWrapFunctionWithAllRegParams  RTThreadSleep
+NtWrapFunctionWithAllRegParams  RTThreadYield
+%if 0 ; Thread APIs, Part 2
+;NtWrapFunctionWithAllRegParams  RTThreadSelf
+NtWrapFunctionWith7Params       RTThreadCreate
+NtWrapFunctionWithAllRegParams  RTThreadGetNative
+NtWrapFunctionWithAllRegParams  RTThreadWait
+NtWrapFunctionWithAllRegParams  RTThreadWaitNoResume
+NtWrapFunctionWithAllRegParams  RTThreadGetName
+NtWrapFunctionWithAllRegParams  RTThreadSelfName
+NtWrapFunctionWithAllRegParams  RTThreadGetType
+NtWrapFunctionWithAllRegParams  RTThreadUserSignal
+NtWrapFunctionWithAllRegParams  RTThreadUserReset
+NtWrapFunctionWithAllRegParams  RTThreadUserWait
+NtWrapFunctionWithAllRegParams  RTThreadUserWaitNoResume
+%endif
+;NtWrapFunctionWithAllRegParams  RTLogDefaultInstance   - a bit of a gamble, but we do not want the overhead!
+;NtWrapFunctionWithAllRegParams  RTMpCpuId              - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpCpuIdFromSetIndex  - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpCpuIdToSetIndex    - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpIsCpuPossible      - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpGetCount           - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpGetMaxCpuId        - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpGetOnlineCount     - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpGetOnlineSet       - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpGetSet             - not necessary
+;NtWrapFunctionWithAllRegParams  RTMpIsCpuOnline        - not necessary
+NtWrapFunctionWithAllRegParams  RTMpOnAll
+NtWrapFunctionWithAllRegParams  RTMpOnOthers
+NtWrapFunctionWithAllRegParams  RTMpOnSpecific
+;NtWrapFunctionWithAllRegParams  RTLogRelDefaultInstance - not necessary.
+NtWrapFunctionWithAllRegParams  RTLogSetDefaultInstanceThread
+;NtWrapFunctionWithAllRegParams  RTLogLogger            - can't wrap this buster.
+;NtWrapFunctionWithAllRegParams  RTLogLoggerEx          - can't wrap this buster.
+NtWrapFunctionWithAllRegParams  RTLogLoggerExV
+;NtWrapFunctionWithAllRegParams  RTLogPrintf            - can't wrap this buster. ;; @todo provide va_list log wrappers in RuntimeR0.
+NtWrapFunctionWithAllRegParams  RTLogPrintfV
+NtWrapFunctionWithAllRegParams  AssertMsg1
+;NtWrapFunctionWithAllRegParams  AssertMsg2             - can't wrap this buster.
+
+
+;;
+; @cproto DECLASM(int) supdrvNtWrapVMMR0EntryEx(PFNRT pfnVMMR0EntryEx, PVM pVM, unsigned uOperation, PSUPVMMR0REQHDR pReq, uint64_t u64Arg, PSUPDRVSESSION pSession);
+;
+; @param    pfnVMMR0EntryEx     rcx
+; @param    pVM                 rdx
+; @param    uOperation          r8
+; @param    pReq                r9
+; @param    u64Arg              [rsp + 28h] / [rbp + 30h]
+; @param    pSession            [rsp + 30h] / [rbp + 38h]
+;
+BEGINPROC supdrvNtWrapVMMR0EntryEx
+        NtWrapProlog supdrvNtWrapVMMR0EntryEx
+        NtWrapCreateMarker
+
+        mov     rax, rcx
+        mov     rcx, rdx
+        mov     rdx, r8
+        mov     r8, r9
+        mov     r9, [rbp + 30h]
+        mov     r11, [rbp + 38h]
+        mov     [rsp + 20h], r11
+        call    rax
+
+        NtWrapDestroyMarker
+        NtWrapEpilog supdrvNtWrapVMMR0EntryEx
+ENDPROC   supdrvNtWrapVMMR0EntryEx
+
+
+;;
+; @cproto DECLASM(int)    supdrvNtWrapVMMR0EntryFast(PFNRT pfnVMMR0EntryFast, PVM pVM, unsigned uOperation);
+;
+; @param    pfnVMMR0EntryFast   rcx
+; @param    pVM                 rdx
+; @param    uOperation          r8
+;
+BEGINPROC supdrvNtWrapVMMR0EntryFast
+        NtWrapProlog supdrvNtWrapVMMR0EntryFast
+        NtWrapCreateMarker
+
+        mov     rax, rcx
+        mov     rcx, rdx
+        mov     rdx, r8
+        call    rax
+
+        NtWrapDestroyMarker
+        NtWrapEpilog supdrvNtWrapVMMR0EntryFast
+ENDPROC   supdrvNtWrapVMMR0EntryFast
+
+
+;;
+; @cproto DECLASM(void)   supdrvNtWrapObjDestructor(PFNRT pfnDestruction, void *pvObj, void *pvUser1, void *pvUser2);
+;
+; @param    pfnDestruction      rcx
+; @param    pvObj               rdx
+; @param    pvUser1             r8
+; @param    pvUser2             r9
+;
+BEGINPROC supdrvNtWrapObjDestructor
+        NtWrapProlog supdrvNtWrapObjDestructor
+        NtWrapCreateMarker
+
+        mov     rax, rcx
+        mov     rcx, rdx
+        mov     rdx, r8
+        mov     r8, r9
+        call    rax
+
+        NtWrapDestroyMarker
+        NtWrapEpilog supdrvNtWrapObjDestructor
+ENDPROC   supdrvNtWrapObjDestructor
+
+
+;;
+; @cproto DECLASM(void *) supdrvNtWrapQueryFactoryInterface(PFNRT pfnQueryFactoryInterface, struct SUPDRVFACTORY const *pSupDrvFactory,
+;                                                           PSUPDRVSESSION pSession, const char *pszInterfaceUuid);
+;
+; @param    pfnQueryFactoryInterface    rcx
+; @param    pSupDrvFactory      rdx
+; @param    pSession            r8
+; @param    pszInterfaceUuid    r9
+;
+BEGINPROC supdrvNtWrapQueryFactoryInterface
+        NtWrapProlog supdrvNtWrapQueryFactoryInterface
+        NtWrapCreateMarker
+
+        mov     rax, rcx
+        mov     rcx, rdx
+        mov     rdx, r8
+        mov     r8, r9
+        call    rax
+
+        NtWrapDestroyMarker
+        NtWrapEpilog supdrvNtWrapQueryFactoryInterface
+ENDPROC   supdrvNtWrapQueryFactoryInterface
+
+
+;;
+; @cproto DECLASM(int)    supdrvNtWrapModuleInit(PFNRT pfnModuleInit);
+;
+; @param    pfnModuleInit       rcx
+;
+BEGINPROC supdrvNtWrapModuleInit
+        NtWrapProlog supdrvNtWrapModuleInit
+        NtWrapCreateMarker
+
+        call    rcx
+
+        NtWrapDestroyMarker
+        NtWrapEpilog supdrvNtWrapModuleInit
+ENDPROC   supdrvNtWrapModuleInit
+
+
+;;
+; @cproto DECLASM(void)   supdrvNtWrapModuleTerm(PFNRT pfnModuleTerm);
+;
+; @param    pfnModuleInit       rcx
+;
+BEGINPROC supdrvNtWrapModuleTerm
+        NtWrapProlog supdrvNtWrapModuleTerm
+        NtWrapCreateMarker
+
+        call    rcx
+
+        NtWrapDestroyMarker
+        NtWrapEpilog supdrvNtWrapModuleTerm
+ENDPROC   supdrvNtWrapModuleTerm
+
+
 
  %endif ; RT_ARCH_AMD64
 %endif ; SUPDRV_WITH_UNWIND_HACK
diff -urN VirtualBox-2.0.0/src/VBox/HostDrivers/VBoxNetFlt/solaris/VBoxNetFlt-solaris.c vbox/src/VBox/HostDrivers/VBoxNetFlt/solaris/VBoxNetFlt-solaris.c
--- VirtualBox-2.0.0/src/VBox/HostDrivers/VBoxNetFlt/solaris/VBoxNetFlt-solaris.c	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/HostDrivers/VBoxNetFlt/solaris/VBoxNetFlt-solaris.c	2008-09-08 10:07:22.000000000 +0200
@@ -326,9 +326,9 @@
 static mblk_t *vboxNetFltSolarisMBlkFromSG(PVBOXNETFLTINS pThis, PINTNETSG pSG, uint32_t fDst);
 static unsigned vboxNetFltSolarisMBlkCalcSGSegs(PVBOXNETFLTINS pThis, mblk_t *pMsg);
 static int vboxNetFltSolarisMBlkToSG(PVBOXNETFLTINS pThis, mblk_t *pMsg, PINTNETSG pSG, unsigned cSegs, uint32_t fSrc);
-static int vboxNetFltSolarisIOWorker(PVBOXNETFLTINS pThis, queue_t *pQueue, vboxnetflt_stream_t *pStream, mblk_t *pMsg, uint32_t fSrc);
+static int vboxNetFltSolarisRecv(PVBOXNETFLTINS pThis, vboxnetflt_stream_t *pStream, queue_t *pQueue, mblk_t *pMsg);
 static PVBOXNETFLTINS vboxNetFltSolarisFindInstance(vboxnetflt_stream_t *pStream);
-static void vboxNetFltSolarisFinalizeMBlk(mblk_t *pMsg);
+static mblk_t *vboxNetFltSolarisFixChecksums(mblk_t *pMsg);
 static void vboxNetFltSolarisAnalyzeMBlk(mblk_t *pMsg);
 
 
@@ -518,7 +518,8 @@
  */
 static int VBoxNetFltSolarisGetInfo(dev_info_t *pDip, ddi_info_cmd_t enmCmd, void *pvArg, void **ppResult)
 {
-    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisGetInfo pDip=%p enmCmd=%d pArg=%p instance=%d\n", pDip, enmCmd, getminor((dev_t)pvArg)));
+    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisGetInfo pDip=%p enmCmd=%d pArg=%p instance=%d\n", pDip, enmCmd,
+                getminor((dev_t)pvArg)));
 
     switch (enmCmd)
     {
@@ -555,7 +556,8 @@
 {
     Assert(pQueue);
 
-    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModOpen pQueue=%p pDev=%p fOpenMode=%d fStreamMode=%d\n", pQueue, pDev, fOpenMode, fStreamMode));
+    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModOpen pQueue=%p pDev=%p fOpenMode=%d fStreamMode=%d\n", pQueue, pDev,
+            fOpenMode, fStreamMode));
 
     /*
      * Already open?
@@ -636,7 +638,6 @@
     pQueue->q_ptr = pStream;
     WR(pQueue)->q_ptr = pStream;
 
-    /** @todo Get rid of linked list maintenance; we're not a virtual DLPI device slaving for ring-3 consumers. */
     /*
      * Link it to the list of streams.
      */
@@ -748,123 +749,134 @@
 
     bool fSendUpstream = true;
     vboxnetflt_stream_t *pStream = pQueue->q_ptr;
-    PVBOXNETFLTINS pThis = vboxNetFltSolarisFindInstance(pStream);
 
-    if (pStream->Type == kIpStream)
+    /*
+     * In the unlikely case where VirtualBox crashed and this filter
+     * is somehow still in the host stream we must try not to panic the host.
+     */
+    if (   pStream
+        && pStream->Type == kIpStream
+        && pMsg)
     {
-        switch (DB_TYPE(pMsg))
+        PVBOXNETFLTINS pThis = vboxNetFltSolarisFindInstance(pStream);
+        if (RT_LIKELY(pThis))
         {
-            case M_DATA:
+            switch (DB_TYPE(pMsg))
             {
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut M_DATA\n"));
-
-                vboxNetFltSolarisIOWorker(pThis, pStream->pReadQueue, pStream, pMsg, INTNETTRUNKDIR_WIRE);
-                fSendUpstream = false;          /* vboxNetFltSolarisIOWorker would send it if required, do nothing more here. */
-                break;
-            }
+                case M_DATA:
+                {
+                    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut M_DATA\n"));
 
-            case M_PROTO:
-            case M_PCPROTO:
-            {
-                union DL_primitives *pPrim = (union DL_primitives *)pMsg->b_rptr;
-                t_uscalar_t Prim = pPrim->dl_primitive;
+                    vboxNetFltSolarisRecv(pThis, pStream, pQueue, pMsg);
+                    fSendUpstream = false;          /* vboxNetFltSolarisRecv would send it if required, do nothing more here. */
+                    break;
+                }
 
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_PCPROTO %d\n", Prim));
-                switch (Prim)
+                case M_PROTO:
+                case M_PCPROTO:
                 {
-                    case DL_UNITDATA_IND:
-                    {
-                        /*
-                         * I do not think control would come here... We convert all outgoing fast mode requests
-                         * to raw mode; so I don't think we should really receive any fast mode replies.
-                         */
-                        LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: DL_UNITDATA_IND\n"));
+                    union DL_primitives *pPrim = (union DL_primitives *)pMsg->b_rptr;
+                    t_uscalar_t Prim = pPrim->dl_primitive;
 
-                        vboxNetFltSolarisIOWorker(pThis, pStream->pReadQueue, pStream, pMsg, INTNETTRUNKDIR_WIRE);
-                        fSendUpstream = false;      /* vboxNetFltSolarisIOWorker would send it if required, do nothing more here. */
-                        break;
-                    }
-
-                    case DL_PHYS_ADDR_ACK:
+                    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_PCPROTO %d\n", Prim));
+                    switch (Prim)
                     {
-                        vboxNetFltSolarisCachePhysAddr(pThis, pMsg);
-
-                        /*
-                         * Swallow our fake physical address request acknowledgement.
-                         */
-                        if (pStream->UnAckPrim == DL_PHYS_ADDR_REQ)
+                        case DL_UNITDATA_IND:
                         {
-                            freemsg(pMsg);
-                            fSendUpstream = false;
+                            /*
+                             * I do not think control would come here... We convert all outgoing fast mode requests
+                             * to raw mode; so I don't think we should really receive any fast mode replies.
+                             */
+                            LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: DL_UNITDATA_IND\n"));
+
+                            vboxNetFltSolarisRecv(pThis, pStream, pQueue, pMsg);
+                            fSendUpstream = false;      /* vboxNetFltSolarisRecv would send it if required, do nothing more here. */
+                            break;
                         }
-                        break;
-                    }
 
-                    case DL_OK_ACK:
-                    {
-                        dl_ok_ack_t *pOkAck = (dl_ok_ack_t *)pMsg->b_rptr;
-                        if (pOkAck->dl_correct_primitive == DL_PROMISCON_REQ)
+                        case DL_PHYS_ADDR_ACK:
                         {
-                            LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_PCPROTO: DL_OK_ACK: fPromisc is ON.\n"));
-                            pStream->fPromisc = true;
+                            vboxNetFltSolarisCachePhysAddr(pThis, pMsg);
+
+                            /*
+                             * Swallow our fake physical address request acknowledgement.
+                             */
+                            if (pStream->UnAckPrim == DL_PHYS_ADDR_REQ)
+                            {
+                                freemsg(pMsg);
+                                fSendUpstream = false;
+                            }
+                            break;
                         }
-                        else if (pOkAck->dl_correct_primitive == DL_PROMISCOFF_REQ)
+
+                        case DL_OK_ACK:
                         {
-                            LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_PCPROTO: DL_OK_ACK: fPromisc is OFF.\n"));
-                            pStream->fPromisc = false;
+                            dl_ok_ack_t *pOkAck = (dl_ok_ack_t *)pMsg->b_rptr;
+                            if (pOkAck->dl_correct_primitive == DL_PROMISCON_REQ)
+                            {
+                                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_PCPROTO: DL_OK_ACK: fPromisc is ON.\n"));
+                                pStream->fPromisc = true;
+                            }
+                            else if (pOkAck->dl_correct_primitive == DL_PROMISCOFF_REQ)
+                            {
+                                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_PCPROTO: DL_OK_ACK: fPromisc is OFF.\n"));
+                                pStream->fPromisc = false;
+                            }
+
+                            /*
+                             * Swallow our fake promiscous request acknowledgement.
+                             */
+                            if (pStream->UnAckPrim == pOkAck->dl_correct_primitive)
+                            {
+                                freemsg(pMsg);
+                                fSendUpstream = false;
+                            }
+                            break;
                         }
+                    }
+                    break;
+                }
+
+                case M_IOCACK:
+                {
+                    /*
+                     * Swallow our fake raw/fast path mode request acknowledgement.
+                     */
+                    struct iocblk *pIOC = (struct iocblk *)pMsg->b_rptr;
+                    if (pIOC->ioc_id == pStream->ModeReqId)
+                    {
+                        pStream->ModeReqId = VBOXNETFLT_MODE_REQ_MAGIC;
+                        pStream->fRawMode = !pStream->fRawMode;
 
                         /*
-                         * Swallow our fake promiscous request acknowledgement.
+                         * Somehow raw mode is turned off?? This should never really happen...
                          */
-                        if (pStream->UnAckPrim == pOkAck->dl_correct_primitive)
+                        if (pStream->fRawMode == false)
                         {
-                            freemsg(pMsg);
-                            fSendUpstream = false;
+                            LogFlow((DEVICE_NAME ":re-requesting raw mode!\n"));
+                            vboxNetFltSolarisSetRawMode(pQueue);
                         }
-                        break;
+
+                        freemsg(pMsg);
+                        fSendUpstream = false;
                     }
+                    break;
                 }
-                break;
-            }
 
-            case M_IOCACK:
-            {
-                /*
-                 * Swallow our fake raw/fast path mode request acknowledgement.
-                 */
-                struct iocblk *pIOC = (struct iocblk *)pMsg->b_rptr;
-                if (pIOC->ioc_id == pStream->ModeReqId)
+                case M_FLUSH:
                 {
-                    pStream->ModeReqId = VBOXNETFLT_MODE_REQ_MAGIC;
-                    pStream->fRawMode = !pStream->fRawMode;
-
                     /*
-                     * Somehow raw mode is turned off??
+                     * We must support flushing queues.
                      */
-                    if (pStream->fRawMode == false)
-                    {
-                        LogFlow((DEVICE_NAME ":re-requesting raw mode!!!!!!!!!!!!!!!!!!!!!!!!!!\n"));
-                        vboxNetFltSolarisSetRawMode(pQueue);
-                    }
-
-                    freemsg(pMsg);
-                    fSendUpstream = false;
+                    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_FLUSH\n"));
+                    if (*pMsg->b_rptr & FLUSHR)
+                        flushq(pQueue, FLUSHALL);
+                    break;
                 }
-                break;
-            }
-
-            case M_FLUSH:
-            {
-                /*
-                 * We must support flushing queues.
-                 */
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: M_FLUSH\n"));
-                if (*pMsg->b_rptr & FLUSHR)
-                    flushq(pQueue, FLUSHALL);
-                break;
             }
         }
+        else
+            LogRel((DEVICE_NAME ":VBoxNetFltSolarisModReadPut: Could not find VirtualBox instance!!\n"));
     }
 
     if (   fSendUpstream
@@ -904,103 +916,114 @@
      */
     bool fSendDownstream = true;
     vboxnetflt_stream_t *pStream = pQueue->q_ptr;
-    PVBOXNETFLTINS pThis = vboxNetFltSolarisFindInstance(pStream);
-    int rc;
-    if (pStream->Type == kIpStream)
+
+    /*
+     * In the unlikely case where VirtualBox crashed and this filter
+     * is somehow still in the host stream we must try not to panic the host.
+     */
+    if (   pStream
+        && pStream->Type == kIpStream
+        && pMsg)
     {
-        switch (DB_TYPE(pMsg))
+        PVBOXNETFLTINS pThis = vboxNetFltSolarisFindInstance(pStream);
+        if (RT_LIKELY(pThis))
         {
-            case M_DATA:
+            switch (DB_TYPE(pMsg))
             {
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_DATA\n"));
-                break;
-            }
-
-            case M_PROTO:
-            case M_PCPROTO:
-            {
-                /*
-                 * Queue up other primitives to the service routine.
-                 */
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_PROTO/M_PCPROTO\n"));
+                case M_DATA:
+                {
+                    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_DATA\n"));
+                    break;
+                }
 
-                union DL_primitives *pPrim = (union DL_primitives *)pMsg->b_rptr;
-                t_uscalar_t Prim = pPrim->dl_primitive;
-                switch (Prim)
+                case M_PROTO:
+                case M_PCPROTO:
                 {
-                    case DL_UNITDATA_REQ:
+                    /*
+                     * Queue up other primitives to the service routine.
+                     */
+                    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_PROTO/M_PCPROTO\n"));
+
+                    union DL_primitives *pPrim = (union DL_primitives *)pMsg->b_rptr;
+                    t_uscalar_t Prim = pPrim->dl_primitive;
+                    switch (Prim)
                     {
-                        LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut DL_UNITDATA_REQ\n"));
-                        mblk_t *pRawMsg;
-                        rc = vboxNetFltSolarisUnitDataToRaw(pThis, pMsg, &pRawMsg);
-                        if (VBOX_SUCCESS(rc))
-                            pMsg = pRawMsg;
-                        else
+                        case DL_UNITDATA_REQ:
+                        {
+                            LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut DL_UNITDATA_REQ\n"));
+                            mblk_t *pRawMsg;
+                            int rc = vboxNetFltSolarisUnitDataToRaw(pThis, pMsg, &pRawMsg);
+                            if (VBOX_SUCCESS(rc))
+                                pMsg = pRawMsg;
+                            else
+                                fSendDownstream = false;
+                            break;
+                        }
+
+                        default:
+                        {
+                            /*
+                             * Enqueue other DLPI primitives and service them later.
+                             */
                             fSendDownstream = false;
-                        break;
+                            putq(pQueue, pMsg);
+                            break;
+                        }
                     }
+                    break;
+                }
 
-                    default:
+                case M_IOCTL:
+                {
+                    struct iocblk *pIOC = (struct iocblk *)pMsg->b_rptr;
+                    if (pIOC->ioc_cmd == DL_IOC_HDR_INFO)
                     {
-                        /*
-                         * Enqueue other DLPI primitives and service them later.
-                         */
-                        fSendDownstream = false;
-                        putq(pQueue, pMsg);
-                        break;
+                        if (pThis->fActive)
+                        {
+                            /*
+                             * Somebody is wanting fast path when we need raw mode.
+                             * Since we are evil, let's acknowledge the request ourselves!
+                             */
+                            miocack(pQueue, pMsg, 0, EINVAL);
+                            fSendDownstream = false;
+                            LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut: Fast path request when we need raw mode!\n"));
+                        }
                     }
+                    break;
                 }
-                break;
-            }
 
-            case M_IOCTL:
-            {
-                struct iocblk *pIOC = (struct iocblk *)pMsg->b_rptr;
-                if (pIOC->ioc_cmd == DL_IOC_HDR_INFO)
+                case M_FLUSH:
                 {
-                    if (pThis->fActive)
+                    /*
+                     * Canonical flush courtesy man qreply(9F) while we have a service routine.
+                     */
+                    LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_FLUSH\n"));
+                    if (*pMsg->b_rptr & FLUSHW)
                     {
                         /*
-                         * Somebody is wanting fast path when we need raw mode.
-                         * Since we are evil, let's acknowledge the request ourselves!
+                         * Flush and mark as serviced.
                          */
-                        miocnak(pQueue, pMsg, 0, EINVAL);
-                        fSendDownstream = false;
-                        LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut: Fast path request when we need raw mode!\n"));
+                        flushq(pQueue, FLUSHALL);
+                        *pMsg->b_rptr &= ~FLUSHW;
                     }
-                }
-                break;
-            }
 
-            case M_FLUSH:
-            {
-                /*
-                 * Canonical flush courtesy man qreply(9F) while we have a service routine.
-                 */
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_FLUSH\n"));
-                if (*pMsg->b_rptr & FLUSHW)
-                {
-                    /*
-                     * Flush and mark as serviced.
-                     */
-                    flushq(pQueue, FLUSHALL);
-                    *pMsg->b_rptr &= ~FLUSHW;
-                }
+                    if (*pMsg->b_rptr & FLUSHR)
+                    {
+                        /*
+                         * Send the request upstream.
+                         */
+                        flushq(RD(pQueue), FLUSHALL);
+                        qreply(pQueue, pMsg);
+                    }
+                    else
+                        freemsg(pMsg);
 
-                if (*pMsg->b_rptr & FLUSHR)
-                {
-                    /*
-                     * Send the request upstream.
-                     */
-                    flushq(RD(pQueue), FLUSHALL);
-                    qreply(pQueue, pMsg);
+                    break;
                 }
-                else
-                    freemsg(pMsg);
-
-                break;
             }
         }
+        else
+            LogRel((DEVICE_NAME ":VBoxNetFltSolarisModWritePut: Could not find VirtualBox instance!!\n"));
     }
 
     if (   fSendDownstream
@@ -1035,39 +1058,18 @@
     LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWriteService pQueue=%p\n", pQueue));
 
     /*
-     * Drain the queue as we service the messages.
+     * Implment just the flow controlled service draining of the queue.
+     * Nothing else to do here, we handle all the important stuff in the Put procedure.
      */
     mblk_t *pMsg;
     while (pMsg = getq(pQueue))
     {
-        switch (DB_TYPE(pMsg))
+        if (canputnext(pQueue))
+            putnext(pQueue, pMsg);
+        else
         {
-            case M_DATA:
-            case M_PROTO:
-            case M_PCPROTO:
-            {
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWriteService M_DATA/M_PROTO/M_PCPROTO forwarding downstream\n"));
-                putnext(pQueue, pMsg);
-                break;
-            }
-
-            case M_IOCTL:
-            case M_IOCDATA:
-            {
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWritePut M_IOCTL/M_IOCDATA\n"));
-                putnext(pQueue, pMsg);
-                break;
-            }
-
-            default:
-            {
-                LogFlow((DEVICE_NAME ":VBoxNetFltSolarisModWriteService (Unknown)!\n"));
-                if (canputnext(pQueue))
-                    putnext(pQueue, pMsg);
-                else
-                    putq(pQueue, pMsg);
-                break;
-            }
+            putbq(pQueue, pMsg);
+            break;
         }
     }
 
@@ -1248,7 +1250,8 @@
     {
         bcopy(pMsg->b_rptr + pPhysAddrAck->dl_addr_offset, &pThis->u.s.Mac, sizeof(pThis->u.s.Mac));
 
-        LogFlow((DEVICE_NAME ":vboxNetFltSolarisCachePhysAddr: DL_PHYS_ADDR_ACK: Mac=%.*Rhxs\n", sizeof(pThis->u.s.Mac), &pThis->u.s.Mac));
+        LogFlow((DEVICE_NAME ":vboxNetFltSolarisCachePhysAddr: DL_PHYS_ADDR_ACK: Mac=%.*Rhxs\n", sizeof(pThis->u.s.Mac),
+                    &pThis->u.s.Mac));
     }
 }
 
@@ -1379,7 +1382,8 @@
  */
 static int vboxNetFltSolarisRelink(vnode_t *pVNode, struct lifreq *pInterface, int IpMuxFd, int ArpMuxFd)
 {
-    LogFlow((DEVICE_NAME ":vboxNetFltSolarisRelink: pVNode=%p pInterface=%p IpMuxFd=%d ArpMuxFd=%d\n", pVNode, pInterface, IpMuxFd, ArpMuxFd));
+    LogFlow((DEVICE_NAME ":vboxNetFltSolarisRelink: pVNode=%p pInterface=%p IpMuxFd=%d ArpMuxFd=%d\n", pVNode,
+            pInterface, IpMuxFd, ArpMuxFd));
 
     int NewIpMuxId;
     int NewArpMuxId;
@@ -1520,203 +1524,217 @@
 
     int rc;
     int rc2;
-    int rc3;
     int ret;
-    ldi_ident_t DevId = ldi_ident_from_anon();
+    ldi_ident_t IPDevId = ldi_ident_from_anon();
+    ldi_ident_t ARPDevId = ldi_ident_from_anon();
     ldi_handle_t IPDevHandle;
     ldi_handle_t UDPDevHandle;
     ldi_handle_t ARPDevHandle;
 
     /*
-     * @todo Do opening of each stream separately with error checking.
+     * Open the IP and ARP streams as layered devices.
      */
+    rc = ldi_open_by_name(IP_DEV_NAME, FREAD | FWRITE, kcred, &IPDevHandle, IPDevId);
+    ldi_ident_release(IPDevId);
+    if (rc)
+    {
+        LogRel((DEVICE_NAME ":failed to open the IP stream on '%s'.\n", pThis->szName));
+        return VERR_INTNET_FLT_IF_FAILED;
+    }
+
+    rc = ldi_open_by_name("/dev/arp", FREAD | FWRITE, kcred, &ARPDevHandle, ARPDevId);
+    ldi_ident_release(ARPDevId);
+    if (rc)
+    {
+        LogRel((DEVICE_NAME ":failed to open the ARP stream on '%s'.\n", pThis->szName));
+        ldi_close(IPDevHandle, FREAD | FWRITE, kcred);
+        return VERR_INTNET_FLT_IF_FAILED;
+    }
+
     /*
-     * Open the IP stream as a layered device.
+     * Obtain the interface flags from IP.
      */
-    rc = ldi_open_by_name(IP_DEV_NAME, FREAD | FWRITE, kcred, &IPDevHandle, DevId);
-    rc2 = ldi_open_by_name("/dev/arp", FREAD | FWRITE, kcred, &ARPDevHandle, DevId);
-    if (   !rc
-        && !rc2)
+    rc = vboxNetFltSolarisGetIfFlags(IPDevHandle, &Interface);
+    if (VBOX_SUCCESS(rc))
     {
         /*
-         * Obtain the interface flags from IP.
+         * Open the UDP stream. We sort of cheat here and obtain the vnode so that we can perform
+         * things that are not possible from the layered interface.
          */
-        rc = vboxNetFltSolarisGetIfFlags(IPDevHandle, &Interface);
+        vnode_t *pVNodeUDP = NULL;
+        vnode_t *pVNodeUDPHeld = NULL;
+        TIUSER *pUserUDP = NULL;
+        rc = vboxNetFltSolarisOpenDev(UDP_DEV_NAME, &pVNodeUDP, &pVNodeUDPHeld, &pUserUDP);
         if (VBOX_SUCCESS(rc))
         {
             /*
-             * Open the UDP stream. We sort of cheat here and obtain the vnode so that we can perform
-             * things that are not possible from the layered interface.
+             * Get the multiplexor IDs.
              */
-            vnode_t *pVNodeUDP = NULL;
-            vnode_t *pVNodeUDPHeld = NULL;
-            TIUSER *pUserUDP = NULL;
-            rc = vboxNetFltSolarisOpenDev(UDP_DEV_NAME, &pVNodeUDP, &pVNodeUDPHeld, &pUserUDP);
-            if (VBOX_SUCCESS(rc))
+            rc = ldi_ioctl(IPDevHandle, SIOCGLIFMUXID, (intptr_t)&Interface, FKIOCTL, kcred, &ret);
+            if (!rc)
             {
                 /*
-                 * Get the multiplexor IDs.
+                 * Get the multiplex file descriptor to the lower streams. Generally this is lost
+                 * once a module is I_PLINK, we need to reobtain it for inserting/removing ourselves from the stack.
                  */
-                rc = ldi_ioctl(IPDevHandle, SIOCGLIFMUXID, (intptr_t)&Interface, FKIOCTL, kcred, &ret);
-                if (!rc)
+                int IpMuxFd;
+                int ArpMuxFd;
+                rc = vboxNetFltSolarisMuxIdToFd(pVNodeUDP, Interface.lifr_ip_muxid, &IpMuxFd);
+                rc2 = vboxNetFltSolarisMuxIdToFd(pVNodeUDP, Interface.lifr_arp_muxid, &ArpMuxFd);
+                if (   VBOX_SUCCESS(rc)
+                    && VBOX_SUCCESS(rc2))
                 {
                     /*
-                     * Get the multiplex file descriptor to the lower streams. Generally this is lost
-                     * once a module is I_PLINK, we need to reobtain it for inserting/removing ourselves from the stack.
+                     * We need to I_PUNLINK on these multiplexor IDs before we can start
+                     * operating on the lower stream as insertions are direct operations on the lower stream.
                      */
-                    int IpMuxFd;
-                    int ArpMuxFd;
-                    rc = vboxNetFltSolarisMuxIdToFd(pVNodeUDP, Interface.lifr_ip_muxid, &IpMuxFd);
-                    rc2 = vboxNetFltSolarisMuxIdToFd(pVNodeUDP, Interface.lifr_arp_muxid, &ArpMuxFd);
-                    if (   VBOX_SUCCESS(rc)
-                        && VBOX_SUCCESS(rc2))
+                    int ret;
+                    rc = strioctl(pVNodeUDP, I_PUNLINK, (intptr_t)Interface.lifr_ip_muxid, 0, K_TO_K, kcred, &ret);
+                    rc2 = strioctl(pVNodeUDP, I_PUNLINK, (intptr_t)Interface.lifr_arp_muxid, 0, K_TO_K, kcred, &ret);
+                    if (   !rc
+                        && !rc2)
                     {
                         /*
-                         * We need to I_PUNLINK on these multiplexor IDs before we can start
-                         * operating on the lower stream as insertions are direct operations on the lower stream.
+                         * Obtain the vnode from the useless userland file descriptor.
                          */
-                        int ret;
-                        rc = strioctl(pVNodeUDP, I_PUNLINK, (intptr_t)Interface.lifr_ip_muxid, 0, K_TO_K, kcred, &ret);
-                        rc2 = strioctl(pVNodeUDP, I_PUNLINK, (intptr_t)Interface.lifr_arp_muxid, 0, K_TO_K, kcred, &ret);
-                        if (   !rc
-                            && !rc2)
+                        file_t *pIpFile = getf(IpMuxFd);
+                        file_t *pArpFile = getf(ArpMuxFd);
+                        if (   pIpFile
+                            && pArpFile
+                            && pArpFile->f_vnode
+                            && pIpFile->f_vnode)
                         {
+                            vnode_t *pVNodeIp = pIpFile->f_vnode;
+                            vnode_t *pVNodeArp = pArpFile->f_vnode;
+
                             /*
-                             * Obtain the vnode from the useless userland file descriptor.
+                             * Find the position on the host stack for attaching/detaching ourselves.
                              */
-                            file_t *pIpFile = getf(IpMuxFd);
-                            file_t *pArpFile = getf(ArpMuxFd);
-                            if (   pIpFile
-                                && pArpFile
-                                && pArpFile->f_vnode
-                                && pIpFile->f_vnode)
+                            rc = vboxNetFltSolarisDetermineModPos(fAttach, pVNodeIp, &StrMod.pos);
+                            rc2 = vboxNetFltSolarisDetermineModPos(fAttach, pVNodeArp, &ArpStrMod.pos);
+                            if (   VBOX_SUCCESS(rc)
+                                && VBOX_SUCCESS(rc2))
                             {
-                                vnode_t *pVNodeIp = pIpFile->f_vnode;
-                                vnode_t *pVNodeArp = pArpFile->f_vnode;
+                                /*
+                                 * Set global data which will be grabbed by ModOpen.
+                                 */
+                                g_VBoxNetFltSolarisState.pCurInstance = pThis;
+                                g_VBoxNetFltSolarisState.CurType = kIpStream;
 
                                 /*
-                                 * Find the position on the host stack for attaching/detaching ourselves.
+                                 * Inject/Eject from the host IP stack.
                                  */
-                                rc = vboxNetFltSolarisDetermineModPos(fAttach, pVNodeIp, &StrMod.pos);
-                                rc2 = vboxNetFltSolarisDetermineModPos(fAttach, pVNodeArp, &ArpStrMod.pos);
-                                if (   VBOX_SUCCESS(rc)
-                                    && VBOX_SUCCESS(rc2))
+                                rc = strioctl(pVNodeIp, fAttach ? _I_INSERT : _I_REMOVE, (intptr_t)&StrMod, 0, K_TO_K,
+                                            kcred, &ret);
+                                if (!rc)
                                 {
-                                    /** @todo -XXX- Do each step here with full error checking. I know the if-levels are
-                                      * getting ridiculous but it has to be done as failure here is still possible
-                                      * (though unlikely) given a terribly ackward user configuration or messed up stack.
-                                      */
-                                    /*
-                                     * Set global data which will be grabbed by ModOpen.
-                                     */
-                                    g_VBoxNetFltSolarisState.pCurInstance = pThis;
-                                    g_VBoxNetFltSolarisState.CurType = kIpStream;
-
-                                    /*
-                                     * Inject/Eject from the host IP stack.
-                                     */
-                                    rc = strioctl(pVNodeIp, fAttach ? _I_INSERT : _I_REMOVE, (intptr_t)&StrMod, 0, K_TO_K, kcred, &ret);
-
                                     /*
                                      * Inject/Eject from the host ARP stack.
                                      */
                                     g_VBoxNetFltSolarisState.CurType = kArpStream;
-                                    rc2 = strioctl(pVNodeArp, fAttach ? _I_INSERT : _I_REMOVE, (intptr_t)&ArpStrMod, 0, K_TO_K, kcred, &ret);
-
-                                    g_VBoxNetFltSolarisState.pCurInstance = NULL;
-                                    g_VBoxNetFltSolarisState.CurType = kUndefined;
-
-                                    /*
-                                     * Our job's not yet over; we need to relink the upper and lower streams
-                                     * otherwise we've pretty much screwed up the host interface.
-                                     */
-                                    rc3 = vboxNetFltSolarisRelink(pVNodeUDP, &Interface, IpMuxFd, ArpMuxFd);
-                                    if (   !rc
-                                        && !rc2
-                                        && VBOX_SUCCESS(rc3))
+                                    rc = strioctl(pVNodeArp, fAttach ? _I_INSERT : _I_REMOVE, (intptr_t)&ArpStrMod, 0, K_TO_K,
+                                                kcred, &ret);
+                                    if (!rc)
                                     {
-                                        bool fRawModeOk = !fAttach;         /* Raw mode check is always ok during the detach case */
-                                        if (fAttach)
+                                        g_VBoxNetFltSolarisState.pCurInstance = NULL;
+                                        g_VBoxNetFltSolarisState.CurType = kUndefined;
+
+                                        /*
+                                         * Our job's not yet over; we need to relink the upper and lower streams
+                                         * otherwise we've pretty much screwed up the host interface.
+                                         */
+                                        rc = vboxNetFltSolarisRelink(pVNodeUDP, &Interface, IpMuxFd, ArpMuxFd);
+                                        if (VBOX_SUCCESS(rc))
                                         {
-                                            /*
-                                             * Check if our raw mode request was successful (only in the IP stream).
-                                             */
-                                            vboxnetflt_stream_t *pStream = pThis->u.s.pvStream;
-                                            AssertRelease(pStream);
-                                            if (   pStream->fRawMode == true
-                                                && pStream->ModeReqId == VBOXNETFLT_MODE_REQ_MAGIC)
+                                            bool fRawModeOk = !fAttach;   /* Raw mode check is always ok during the detach case */
+                                            if (fAttach)
+                                            {
+                                                /*
+                                                 * Check if our raw mode request was successful (only in the IP stream).
+                                                 */
+                                                vboxnetflt_stream_t *pStream = pThis->u.s.pvStream;
+                                                if (RT_LIKELY(pStream))
+                                                {
+                                                    if (   pStream->fRawMode == true
+                                                        && pStream->ModeReqId == VBOXNETFLT_MODE_REQ_MAGIC)
+                                                    {
+                                                        pStream->ModeReqId = 0;
+                                                        fRawModeOk = true;
+                                                    }
+                                                }
+                                            }
+
+                                            if (fRawModeOk)
                                             {
-                                                pStream->ModeReqId = 0;
-                                                fRawModeOk = true;
+                                                /*
+                                                 * Close the devices ONLY during the return from function case; otherwise
+                                                 * we end up close twice which is an instant kernel panic.
+                                                 */
+                                                vboxNetFltSolarisCloseDev(pVNodeUDPHeld, pUserUDP);
+                                                ldi_close(ARPDevHandle, FREAD | FWRITE, kcred);
+                                                ldi_close(IPDevHandle, FREAD | FWRITE, kcred);
+
+                                                LogFlow((DEVICE_NAME ":vboxNetFltSolarisModSetup: Success! %s %s@(Ip:%d Arp:%d) "
+                                                        "%s interface %s\n", fAttach ? "Injected" : "Ejected", StrMod.mod_name,
+                                                        StrMod.pos, ArpStrMod.pos, fAttach ? "to" : "from", pThis->szName));
+                                                return VINF_SUCCESS;
                                             }
                                             else
-                                                fRawModeOk = false;
+                                                LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: Raw mode request failed.\n"));
                                         }
-
-                                        if (fRawModeOk)
+                                        else
                                         {
-                                            /*
-                                             * Close the devices ONLY during the return from function case; otherwise
-                                             * we end up close twice which is an instant kernel panic.
-                                             */
-                                            vboxNetFltSolarisCloseDev(pVNodeUDPHeld, pUserUDP);
-                                            ldi_close(IPDevHandle, FREAD | FWRITE, kcred);
-                                            ldi_close(ARPDevHandle, FREAD | FWRITE, kcred);
-                                            ldi_ident_release(DevId);
-
-                                            LogFlow((DEVICE_NAME ":vboxNetFltSolarisModSetup: Success! %s %s@(Ip:%d Arp:%d) %s %s\n",
-                                                    fAttach ? "Attached" : "Detached", StrMod.mod_name, StrMod.pos, ArpStrMod.pos,
-                                                    fAttach ? "to" : "from", pThis->szName));
-                                            return VINF_SUCCESS;
+                                            LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: Relinking failed. Mode=%s rc=%d.\n",
+                                                    fAttach ? "inject" : "eject", rc));
                                         }
-                                        else
-                                            LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: Raw mode request failed.\n"));
-                                    }
-                                    else
-                                    {
-                                        LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: module %s or relinking failed. rc=%d rc2=%d rc3=%d.\n",
-                                                fAttach ? "insert" : "remove", rc, rc2, rc3));
 
                                         /*
                                          * Try failing gracefully during attach.
                                          */
-                                        /** @todo -XXX- see todo above, and remove later accordingly. */
                                         if (fAttach)
-                                        {
                                             strioctl(pVNodeIp, _I_REMOVE, (intptr_t)&StrMod, 0, K_TO_K, kcred, &ret);
-                                            strioctl(pVNodeArp, _I_REMOVE, (intptr_t)&ArpStrMod, 0, K_TO_K, kcred, &ret);
-                                            vboxNetFltSolarisRelink(pVNodeUDP, &Interface, IpMuxFd, ArpMuxFd);
-                                        }
                                     }
+                                    else
+                                    {
+                                        LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to %s the ARP stack. rc=%d\n",
+                                                fAttach ? "inject into" : "eject from", rc));
+                                    }
+
+                                    if (fAttach)
+                                        strioctl(pVNodeIp, _I_REMOVE, (intptr_t)&StrMod, 0, K_TO_K, kcred, &ret);
+
+                                    vboxNetFltSolarisRelink(pVNodeUDP, &Interface, IpMuxFd, ArpMuxFd);
                                 }
                                 else
-                                    LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: vboxNetFltSolarisDetermineModPos failed. rc=%d rc2=%d\n", rc, rc2));
+                                {
+                                    LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to %s the IP stack. rc=%d\n",
+                                            fAttach ? "inject into" : "eject from", rc));
+                                }
                             }
                             else
-                                LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to get vnode from MuxFd.\n"));
+                                LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to find position. rc=%d rc2=%d\n", rc, rc2));
                         }
                         else
-                            LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to unlink upper stream rc=%d rc2=%d.\n", rc, rc2));
+                            LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to get vnode from MuxFd.\n"));
                     }
                     else
-                        LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to get MuxFd from MuxId. rc=%d rc2=%d\n"));
+                        LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to unlink upper stream rc=%d rc2=%d.\n", rc, rc2));
                 }
                 else
-                    LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to get Mux Ids.\n"));
-                vboxNetFltSolarisCloseDev(pVNodeUDPHeld, pUserUDP);
+                    LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to get MuxFd from MuxId. rc=%d rc2=%d\n"));
             }
             else
-                LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to open UDP.\n"));
+                LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to get Mux Ids.\n"));
+            vboxNetFltSolarisCloseDev(pVNodeUDPHeld, pUserUDP);
         }
         else
-            LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: invalid interface '%s'.\n", pThis->szName));
-
-        ldi_close(IPDevHandle, FREAD | FWRITE, kcred);
-        ldi_close(ARPDevHandle, FREAD | FWRITE, kcred);
-        ldi_ident_release(DevId);
+            LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to open UDP.\n"));
     }
     else
-        LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: failed to open IP and/or ARP!\n"));
+        LogRel((DEVICE_NAME ":vboxNetFltSolarisModSetup: invalid interface '%s'.\n", pThis->szName));
+
+    ldi_close(ARPDevHandle, FREAD | FWRITE, kcred);
+    ldi_close(IPDevHandle, FREAD | FWRITE, kcred);
 
     return VERR_INTNET_FLT_IF_FAILED;
 }
@@ -2019,6 +2037,13 @@
     pEtherMsg->b_wptr += cbLen;
 
     pEtherMsg->b_cont = pMsg->b_cont;
+
+    /*
+     * Change the chained blocks to type M_DATA.
+     */
+    for (mblk_t *pTmp = pEtherMsg->b_cont; pTmp; pTmp = pTmp->b_cont)
+        DB_TYPE(pTmp) = M_DATA;
+
     pMsg->b_cont = NULL;
     freemsg(pMsg);
 
@@ -2031,21 +2056,22 @@
  * Worker for routing messages from the wire or from the host.
  *
  * @returns VBox status code.
- * @param   pThis   The instance.
- * @param   pQueue  Pointer to the queue.
- * @param   pMsg    Pointer to the message.
- * @param   fSrc    The source of the frame.
+ * @param   pThis       The instance.
+ * @param   pStream     Pointer to the stream.
+ * @param   pQueue      Pointer to the queue.
+ * @param   pOrigMsg    Pointer to the message.
  */
-static int vboxNetFltSolarisIOWorker(PVBOXNETFLTINS pThis, queue_t *pQueue, vboxnetflt_stream_t *pStream, mblk_t *pMsg, uint32_t fSrc)
+static int vboxNetFltSolarisRecv(PVBOXNETFLTINS pThis, vboxnetflt_stream_t *pStream, queue_t *pQueue, mblk_t *pOrigMsg)
 {
-    LogFlow((DEVICE_NAME ":vboxNetFltSolarisIOWorker pThis=%p pQueue=%p pMsg=%p fSrc=%d\n", pThis, pQueue, pMsg, fSrc));
+    LogFlow((DEVICE_NAME ":vboxNetFltSolarisRecv pThis=%p pOrigMsg=%p\n", pThis, pOrigMsg));
 
     AssertCompile(sizeof(struct ether_header) == sizeof(RTNETETHERHDR));
+    Assert(pStream->Type == kIpStream);
 
     /*
      * Make a copy as we will alter pMsg.
      */
-    mblk_t *pOrigMsg = copymsg(pMsg);
+    mblk_t *pMsg = copymsg(pOrigMsg);
 
     /*
      * Sort out M_PROTO and M_DATA.
@@ -2061,66 +2087,77 @@
         else
         {
             freemsg(pMsg);
-            LogRel((DEVICE_NAME ":vboxNetFltSolarisIOWorker invalid message!\n"));
+            LogRel((DEVICE_NAME ":vboxNetFltSolarisRecv invalid message!\n"));
             return VERR_GENERAL_FAILURE;
         }
     }
 
     /*
-     * Figure out the source of the frame based on the source Mac address.
+     * Figure out the source of the packet based on the source Mac address.
      */
+    /** @todo Is there a more fool-proof way to determine if the packet was indeed sent from the host?? */
+    uint32_t fSrc = INTNETTRUNKDIR_WIRE;
     PRTNETETHERHDR pEthHdr = (PRTNETETHERHDR)pMsg->b_rptr;
     if (vboxNetFltPortOsIsHostMac(pThis, &pEthHdr->SrcMac))
         fSrc = INTNETTRUNKDIR_HOST;
 
-#if 0
-    vboxNetFltSolarisAnalyzeMBlk(pMsg);
-#endif
-
-    /*
-     * Don't route ARP stream packets from the wire up the internal network,
-     * because we already get them on the IP stream under full promiscous mode.
-     * This avoids sending 2 copies of packets into the internal network.
-     */
-    bool fDropIt = false;
-    if (    pStream->Type == kIpStream
-         || (pStream->Type == kArpStream && (fSrc & INTNETTRUNKDIR_HOST)))      /** Do we really need these?? */
-    {
-        unsigned cSegs = vboxNetFltSolarisMBlkCalcSGSegs(pThis, pMsg);
-        PINTNETSG pSG = (PINTNETSG)alloca(RT_OFFSETOF(INTNETSG, aSegs[cSegs]));
-        int rc = vboxNetFltSolarisMBlkToSG(pThis, pMsg, pSG, cSegs, fSrc);
-        if (VBOX_FAILURE(rc))
+    bool fChecksumAdjusted = false;
+#if 1
+    if (fSrc & INTNETTRUNKDIR_HOST)
+    {
+        mblk_t *pCorrectedMsg = vboxNetFltSolarisFixChecksums(pMsg);
+        if (pCorrectedMsg)
         {
-            LogRel((DEVICE_NAME ":vboxNetFltSolarisMBlkToSG failed. rc=%d\n", rc));
-            return rc;
+            fChecksumAdjusted = true;
+            pMsg = pCorrectedMsg;
         }
+    }
+#endif
 
-        fDropIt = pThis->pSwitchPort->pfnRecv(pThis->pSwitchPort, pSG, fSrc);
+    /*
+     * Route all received packets into the internal network.
+     */
+    unsigned cSegs = vboxNetFltSolarisMBlkCalcSGSegs(pThis, pMsg);
+    PINTNETSG pSG = (PINTNETSG)alloca(RT_OFFSETOF(INTNETSG, aSegs[cSegs]));
+    int rc = vboxNetFltSolarisMBlkToSG(pThis, pMsg, pSG, cSegs, fSrc);
+    if (VBOX_FAILURE(rc))
+    {
+        LogRel((DEVICE_NAME ":vboxNetFltSolarisMBlkToSG failed. rc=%d\n", rc));
+        return rc;
     }
 
+    bool fDropIt = pThis->pSwitchPort->pfnRecv(pThis->pSwitchPort, pSG, fSrc);
+
+    /*
+     * Drop messages consumed by the internal network.
+     */
     if (fDropIt)
     {
-        LogFlow((DEVICE_NAME ":Packet consumed by internal network.\n"));
+        LogFlow((DEVICE_NAME ":vboxNetFltSolarisRecv Packet consumed by internal network.\n"));
         freemsg(pOrigMsg);
         freemsg(pMsg);
     }
     else
     {
         /*
-         * Packets from the host must be send down as raw mode packets.
-         * Packets from the wire, we don't care; just push the original
-         * upstream in whatever way we go it.
+         * Packets from the host, push them up in raw mode.
+         * Packets from the wire, we must push them in their original form
+         * as upstream consumers expect this format.
          */
         if (pStream->fRawMode)
         {
             if (fSrc & INTNETTRUNKDIR_HOST)
             {
-                if (fOriginalIsRaw)
+                /* Raw packets with correct checksums, pass-through the original */
+                if (    fOriginalIsRaw
+                    && !fChecksumAdjusted)
+                {
                     putnext(pQueue, pOrigMsg);
-                else
+                }
+                else    /* For M_PROTO packets or checksum corrected raw packets, pass-through the raw */
                 {
                     putnext(pQueue, pMsg);
-                    pMsg = pOrigMsg;    /* for freeing the M_PROTO message */
+                    pMsg = pOrigMsg;        /* for the freemsg that follows */
                 }
             }
             else    /* INTNETTRUNKDIR_WIRE */
@@ -2160,112 +2197,135 @@
 
 /**
  * Finalize the message to be fed into the internal network.
+ * Verifies and tries to fix checksums for TCP, UDP and IP.
  *
+ * @returns Corrected message or NULL if no change was required.
  * @param   pMsg    Pointer to the message block.
  *                  This must not be DLPI linked messages, must be M_DATA.
  *
- * @remarks We don't compute ethernet CRC here.
+ * @remarks If this function returns a checksum adjusted message, the
+ *          passed in input message has been freed and should not be
+ *          referenced anymore by the caller.
  */
-static void vboxNetFltSolarisFinalizeMBlk(mblk_t *pMsg)
+static mblk_t *vboxNetFltSolarisFixChecksums(mblk_t *pMsg)
 {
-    LogFlow((DEVICE_NAME ":vboxNetFltSolarisFinalizeMBlk pMsg=%p\n"));
+    LogFlow((DEVICE_NAME ":vboxNetFltSolarisFixChecksums pMsg=%p\n"));
 
     Assert(DB_TYPE(pMsg) == M_DATA);
 
-    /*
-     * Concatenate chained mblks.
-     */
-    if (pMsg->b_cont)
+    if (MBLKL(pMsg) < sizeof(RTNETETHERHDR))
     {
-        mblk_t *pFullMsg = allocb(msgdsize(pMsg), BPRI_MED);
-        if (!pFullMsg)
-        {
-            LogRel((DEVICE_NAME ":vboxNetFltSolarisFinalizeMBlk failed to alloc new message.\n"));
-            return;
-        }
+        LogRel((DEVICE_NAME ":vboxNetFltSolarisFixChecksums Packet shorter than ethernet header size!\n"));
+        return NULL;
+    }
 
-        for (mblk_t *pTmp = pMsg; pTmp; pTmp = pTmp->b_cont)
+    PRTNETETHERHDR pEthHdr = (PRTNETETHERHDR)pMsg->b_rptr;
+    if (pEthHdr->EtherType == RT_H2BE_U16(RTNET_ETHERTYPE_IPV4))
+    {
+        /*
+         * Check if we have a complete packet or being fed a chain.
+         */
+        size_t cbIpPacket = 0;
+        mblk_t *pFullMsg = NULL;
+        if (pMsg->b_cont)
         {
-            if (DB_TYPE(pTmp) == M_DATA)
+            LogFlow((DEVICE_NAME ":Chained mblk_t.\n"));
+
+            /*
+             * Handle chain by making a packet copy to verify if the IP checksum is correct.
+             * Contributions to calculating IP checksums from a chained message block with
+             * odd/non-pulled up sizes are welcome.
+             */
+            size_t cbFullMsg = msgdsize(pMsg);
+            mblk_t *pFullMsg = allocb(cbFullMsg, BPRI_MED);
+            LogFlow((DEVICE_NAME ":msgdsize returns %d\n", cbFullMsg));
+            if (RT_UNLIKELY(!pFullMsg))
             {
-                bcopy(pTmp->b_rptr, pFullMsg->b_wptr, MBLKL(pTmp));
-                pFullMsg->b_wptr += MBLKL(pTmp);
+                LogRel((DEVICE_NAME ":vboxNetFltSolarisFixChecksums failed to alloc new message of %d bytes.\n", cbFullMsg));
+                return false;
             }
-            else
+
+            for (mblk_t *pTmp = pMsg; pTmp; pTmp = pTmp->b_cont)
             {
-                LogRel((DEVICE_NAME ":vboxNetFltSolarisFinalizeMBlk non-M_DATA chained message!\n"));
-                freemsg(pFullMsg);
-                return;
+                if (DB_TYPE(pTmp) == M_DATA)
+                {
+                    bcopy(pTmp->b_rptr, pFullMsg->b_wptr, MBLKL(pTmp));
+                    pFullMsg->b_wptr += MBLKL(pTmp);
+                }
+                else
+                    LogFlow((DEVICE_NAME ":Not M_DATA.. this is really bad.\n"));
             }
-        }
 
-        freemsg(pMsg);
-        pMsg = pFullMsg;
-        DB_TYPE(pMsg) = M_DATA;
-    }
+            DB_TYPE(pFullMsg) = M_DATA;
+            pEthHdr = (PRTNETETHERHDR)pFullMsg->b_rptr;
+            cbIpPacket = MBLKL(pFullMsg) - sizeof(RTNETETHERHDR);
+        }
+        else
+            cbIpPacket = MBLKL(pMsg) - sizeof(RTNETETHERHDR);
 
-    size_t cbMsg = MBLKL(pMsg);
-    if (cbMsg > sizeof(RTNETETHERHDR))
-    {
-        PRTNETETHERHDR pEthHdr = (PRTNETETHERHDR)pMsg->b_rptr;
-        if (pEthHdr->EtherType == RT_H2BE_U16(RTNET_ETHERTYPE_IPV4))
+        /*
+         * Check if the IP checksum is valid.
+         */
+        PRTNETIPV4 pIpHdr = (PRTNETIPV4)(pEthHdr + 1);
+        if (!RTNetIPv4IsHdrValid(pIpHdr, cbIpPacket, cbIpPacket))
         {
-            cbMsg -= sizeof(RTNETETHERHDR);
+            LogFlow((DEVICE_NAME ":Invalid IP checksum detected. Trying to fix...\n"));
 
-            PRTNETIPV4 pIpHdr = NULL;
-            if (cbMsg > sizeof(RTNETIPV4))
-                pIpHdr = (PRTNETIPV4)(pEthHdr + 1);
-            else
+            /*
+             * Fix up TCP/UDP and IP checksums if they're incomplete/invalid.
+             */
+            if (pIpHdr->ip_p == RTNETIPV4_PROT_TCP)
             {
-                LogRel((DEVICE_NAME ":IP packet too short.\n"));
-                return;
-            }
+                size_t cbTcpPacket = cbIpPacket - (pIpHdr->ip_hl << 2);
 
-            if (RTNetIPv4IsHdrValid(pIpHdr, cbMsg, cbMsg))
-            {
-#if 0
-                /*
-                 * Fix up TCP checksum.
-                 */
-                if (pIpHdr->ip_p == RTNETIPV4_PROT_TCP)
+                PRTNETTCP pTcpHdr = (PRTNETTCP)(pIpHdr + 1);
+                if (!RTNetIPv4IsTCPValid(pIpHdr, pTcpHdr, cbTcpPacket, NULL, cbTcpPacket))
                 {
-                    PRTNETTCP pTcpHdr = (PRTNETTCP)(pIpHdr + 1);
-                    cbLen -= pIpHdr->ip_hl * 4;
-                    if (!RTNetIPv4IsTCPValid(pIpHdr, pTcpHdr, cbLen, NULL, cbLen))
-                    {
-                        /*
-                         * @todo -XXX- this will horribly fail for an mblk_t chain! Fix this later by allocating, copying temp buffer.
-                         */
-                        RTNetIPv4TCPChecksum(pIpHdr, pTcpHdr, NULL);
-                        LogFlow((DEVICE_NAME ":computed TCP checksum.\n"));
-                    }
+                    RTNetIPv4TCPChecksum(pIpHdr, pTcpHdr, NULL);
+                    LogFlow((DEVICE_NAME ":fixed TCP checkum.\n"));
                 }
+                else
+                    LogFlow((DEVICE_NAME ":valid TCP checksum invalid IP checksum...\n"));
+            }
+            else if (pIpHdr->ip_p == RTNETIPV4_PROT_UDP)
+            {
+                size_t cbUdpPacket = cbIpPacket - (pIpHdr->ip_hl << 2);
 
-                /*
-                 * Fix up UDP checksum.
-                 */
-                if (pIpHdr->ip_p == RTNETIPV4_PROT_UDP)
-                {
-                    PRTNETUDP pUdpHdr = (PRTNETUDP)(pIpHdr + 1);
-                    cbLen -= pIpHdr->ip_hl * 4;
-                    RTNetIPv4UDPChecksum(pIpHdr, pUdpHdr, pUdpHdr + 1);
-                    LogFlow((DEVICE_NAME ":computed UDP checksum.\n"));
-                }
-                RTNetIPv4HdrChecksum(pIpHdr);
-                LogFlow((DEVICE_NAME ":computed IP checksum.\n"));
-#endif
+                PRTNETUDP pUdpHdr = (PRTNETUDP)(pIpHdr + 1);
+                RTNetIPv4UDPChecksum(pIpHdr, pUdpHdr, pUdpHdr + 1);
+
+                LogFlow((DEVICE_NAME ":fixed UDP checksum.\n"));
             }
             else
             {
-                RTNetIPv4HdrChecksum(pIpHdr);
-                LogFlow((DEVICE_NAME ":Re-Computed IP Header.\n"));
+                LogFlow((DEVICE_NAME ":Non TCP/UDP protocol with invalid IP header!\n"));
+            }
+
+            RTNetIPv4HdrChecksum(pIpHdr);
+            LogFlow((DEVICE_NAME ":fixed IP checkum.\n"));
+
+            /*
+             * If we made a copy and the checksum is corrected on the copy,
+             * free the original, return the checksum fixed copy.
+             */
+            if (pFullMsg)
+            {
+                freemsg(pMsg);
+                return pFullMsg;
             }
+
+            return pMsg;
         }
-        else
-            LogFlow((DEVICE_NAME ":EtherType=%x D=%.6Rhxs S=%.6Rhxs\n", RT_H2BE_U16(pEthHdr->EtherType), &pEthHdr->DstMac, &pEthHdr->SrcMac));
+
+        /*
+         * If we made a copy and the checksum is NOT corrected, free the copy,
+         * and return NULL.
+         */
+        if (pFullMsg)
+            freemsg(pFullMsg);
     }
-    else
-        LogRel((DEVICE_NAME ":Packet shorter than ethernet header size!\n"));
+
+    return NULL;
 }
 
 
@@ -2301,7 +2361,8 @@
     }
     else
     {
-        LogFlow((DEVICE_NAME ":Unknown EtherType=%x D=%.6Rhxs S=%.6Rhxs\n", RT_H2BE_U16(pEthHdr->EtherType), &pEthHdr->DstMac, &pEthHdr->SrcMac));
+        LogFlow((DEVICE_NAME ":Unknown EtherType=%x D=%.6Rhxs S=%.6Rhxs\n", RT_H2BE_U16(pEthHdr->EtherType), &pEthHdr->DstMac,
+                    &pEthHdr->SrcMac));
         /* LogFlow((DEVICE_NAME ":%.*Vhxd\n", MBLKL(pMsg), pMsg->b_rptr)); */
     }
 }
diff -urN VirtualBox-2.0.0/src/VBox/Installer/solaris/Makefile.kmk vbox/src/VBox/Installer/solaris/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/Installer/solaris/Makefile.kmk	2008-09-08 10:06:34.000000000 +0200
+++ vbox/src/VBox/Installer/solaris/Makefile.kmk	2008-09-08 10:07:22.000000000 +0200
@@ -88,7 +88,7 @@
 	$(if $(VBOX_WITH_QT4GUI),libVBoxQtCore.so.4,) \
 	$(if $(VBOX_WITH_QT4GUI),libVBoxQtGui.so.4,) \
 	$(if $(VBOX_WITH_DEBUGGER_GUI),VBoxDbg.so,) \
-	$(if $(VBOX_WITH_PYTHON),VBoxPython.so,) \
+	$(if $(VBOX_WITH_PYTHON),$(if $(findstring amd64,$(KBUILD_ARCH)),64/VBoxPython.so,VBoxPython.so),) \
 	VBoxSettings.so \
 	components/VBoxC.so \
 	components/VBoxSVCM.so \
diff -urN VirtualBox-2.0.0/src/VBox/Main/ConsoleImpl.cpp vbox/src/VBox/Main/ConsoleImpl.cpp
--- VirtualBox-2.0.0/src/VBox/Main/ConsoleImpl.cpp	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/ConsoleImpl.cpp	2008-09-08 10:07:17.000000000 +0200
@@ -331,6 +331,7 @@
 
     mcAudioRefs = 0;
     mcVRDPClients = 0;
+    mu32SingleRDPClientId = 0;
 
     unconst (mVMMDev) = new VMMDev(this);
     AssertReturn (mVMMDev, E_FAIL);
@@ -512,27 +513,6 @@
                     )
             ));
 
-    /* Multiconnection check. */
-    BOOL allowMultiConnection = FALSE;
-    hrc = mVRDPServer->COMGETTER(AllowMultiConnection) (&allowMultiConnection);
-    AssertComRCReturn (hrc, VERR_ACCESS_DENIED);
-
-    LogFlowFunc(("allowMultiConnection %d, mcVRDPClients = %d\n", allowMultiConnection, mcVRDPClients));
-
-    if (allowMultiConnection == FALSE)
-    {
-        /* Note: the variable is incremented in ClientConnect callback, which is called when the client
-         * is successfully connected, that is after the ClientLogon callback. Therefore the mcVRDPClients
-         * value is 0 for first client.
-         */
-        if (mcVRDPClients > 0)
-        {
-            /* Reject. */
-            LogRel(("VRDPAUTH: Multiple connections are not enabled. Access denied.\n"));
-            return VERR_ACCESS_DENIED;
-        }
-    }
-
     switch (authType)
     {
         case VRDPAuthType_Null:
@@ -626,15 +606,56 @@
     LogFlowFunc (("Result = %d\n", result));
     LogFlowFuncLeave();
 
-    if (result == VRDPAuthAccessGranted)
+    if (result != VRDPAuthAccessGranted)
     {
-        LogRel(("VRDPAUTH: Access granted.\n"));
-        return VINF_SUCCESS;
+        /* Reject. */
+        LogRel(("VRDPAUTH: Access denied.\n"));
+        return VERR_ACCESS_DENIED;
+    }
+
+    LogRel(("VRDPAUTH: Access granted.\n"));
+
+    /* Multiconnection check must be made after authentication, so bad clients would not interfere with a good one. */
+    BOOL allowMultiConnection = FALSE;
+    hrc = mVRDPServer->COMGETTER(AllowMultiConnection) (&allowMultiConnection);
+    AssertComRCReturn (hrc, VERR_ACCESS_DENIED);
+    
+    BOOL reuseSingleConnection = FALSE;
+    hrc = mVRDPServer->COMGETTER(ReuseSingleConnection) (&reuseSingleConnection);
+    AssertComRCReturn (hrc, VERR_ACCESS_DENIED);
+
+    LogFlowFunc(("allowMultiConnection %d, reuseSingleConnection = %d, mcVRDPClients = %d, mu32SingleRDPClientId = %d\n", allowMultiConnection, reuseSingleConnection, mcVRDPClients, mu32SingleRDPClientId));
+
+    if (allowMultiConnection == FALSE)
+    {
+        /* Note: the 'mcVRDPClients' variable is incremented in ClientConnect callback, which is called when the client
+         * is successfully connected, that is after the ClientLogon callback. Therefore the mcVRDPClients
+         * value is 0 for first client.
+         */
+        if (mcVRDPClients != 0)
+        {
+            Assert(mcVRDPClients == 1);
+            /* There is a client already.
+             * If required drop the existing client connection and let the connecting one in.
+             */
+            if (reuseSingleConnection)
+            {
+                LogRel(("VRDPAUTH: Multiple connections are not enabled. Disconnecting existing client.\n"));
+                mConsoleVRDPServer->DisconnectClient (mu32SingleRDPClientId, false);
+            }
+            else
+            {
+                /* Reject. */
+                LogRel(("VRDPAUTH: Multiple connections are not enabled. Access denied.\n"));
+                return VERR_ACCESS_DENIED;
+            }
+        }
+
+        /* Save the connected client id. From now on it will be necessary to disconnect this one. */
+        mu32SingleRDPClientId = u32ClientId;
     }
 
-    /* Reject. */
-    LogRel(("VRDPAUTH: Access denied.\n"));
-    return VERR_ACCESS_DENIED;
+    return VINF_SUCCESS;
 }
 
 void Console::VRDPClientConnect (uint32_t u32ClientId)
diff -urN VirtualBox-2.0.0/src/VBox/Main/ConsoleVRDPServer.cpp vbox/src/VBox/Main/ConsoleVRDPServer.cpp
--- VirtualBox-2.0.0/src/VBox/Main/ConsoleVRDPServer.cpp	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/ConsoleVRDPServer.cpp	2008-09-08 10:07:17.000000000 +0200
@@ -1135,6 +1135,16 @@
 #endif /* VBOX_WITH_VRDP */
 }
 
+void ConsoleVRDPServer::DisconnectClient (uint32_t u32ClientId, bool fReconnect)
+{
+#ifdef VBOX_WITH_VRDP
+    if (mpEntryPoints && mhServer)
+    {
+        mpEntryPoints->VRDPDisconnect (mhServer, u32ClientId, fReconnect);
+    }
+#endif /* VBOX_WITH_VRDP */
+}
+
 void ConsoleVRDPServer::MousePointerUpdate (const VRDPCOLORPOINTER *pPointer)
 {
 #ifdef VBOX_WITH_VRDP
diff -urN VirtualBox-2.0.0/src/VBox/Main/darwin/PerformanceDarwin.cpp vbox/src/VBox/Main/darwin/PerformanceDarwin.cpp
--- VirtualBox-2.0.0/src/VBox/Main/darwin/PerformanceDarwin.cpp	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/darwin/PerformanceDarwin.cpp	2008-09-08 10:07:17.000000000 +0200
@@ -63,10 +63,13 @@
 class CollectorDarwin : public CollectorHAL
 {
 public:
+    CollectorDarwin();
     virtual int getRawHostCpuLoad(uint64_t *user, uint64_t *kernel, uint64_t *idle);
     virtual int getHostMemoryUsage(ULONG *total, ULONG *used, ULONG *available);
     virtual int getRawProcessCpuLoad(RTPROCESS process, uint64_t *user, uint64_t *kernel, uint64_t *total);
     virtual int getProcessMemoryUsage(RTPROCESS process, ULONG *used);
+private:
+    ULONG totalRAM;
 };
 
 MetricFactoryDarwin::MetricFactoryDarwin()
@@ -75,6 +78,23 @@
     Assert(mHAL);
 }
 
+CollectorDarwin::CollectorDarwin()
+{
+    uint64_t hostMemory;
+    int mib[2];
+    size_t size;
+
+    mib[0] = CTL_HW;
+    mib[1] = HW_MEMSIZE;
+
+    size = sizeof(hostMemory);
+    if (sysctl(mib, 2, &hostMemory, &size, NULL, 0) == -1) {
+        Log(("sysctl() -> %s", strerror(errno)));
+        hostMemory = 0;
+    }
+    totalRAM = (ULONG)(hostMemory / 1024);
+}
+
 int CollectorDarwin::getRawHostCpuLoad(uint64_t *user, uint64_t *kernel, uint64_t *idle)
 {
     kern_return_t krc;
@@ -112,20 +132,7 @@
         return RTErrConvertFromDarwinKern(krc);
     }
 
-    uint64_t hostMemory;
-    int mib[2];
-    size_t size;
-
-    mib[0] = CTL_HW;
-    mib[1] = HW_MEMSIZE;
-
-    size = sizeof(hostMemory);
-    if (sysctl(mib, 2, &hostMemory, &size, NULL, 0) == -1) {
-        int error = errno;
-        Log(("sysctl() -> %s", strerror(error)));
-        return RTErrConvertFromErrno(error);
-    }
-    *total = (ULONG)(hostMemory / 1024);
+    *total = totalRAM;
     *available = info.free_count * (PAGE_SIZE / 1024);
     *used = *total - *available;
     return VINF_SUCCESS;
diff -urN VirtualBox-2.0.0/src/VBox/Main/HostImpl.cpp vbox/src/VBox/Main/HostImpl.cpp
--- VirtualBox-2.0.0/src/VBox/Main/HostImpl.cpp	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/HostImpl.cpp	2008-09-08 10:07:17.000000000 +0200
@@ -821,7 +821,7 @@
         return E_POINTER;
     AutoWriteLock alock (this);
     CHECK_READY();
-    *count = RTMpGetCount();
+    *count = RTMpGetPresentCount();
     return S_OK;
 }
 
diff -urN VirtualBox-2.0.0/src/VBox/Main/idl/VirtualBox.xidl vbox/src/VBox/Main/idl/VirtualBox.xidl
--- VirtualBox-2.0.0/src/VBox/Main/idl/VirtualBox.xidl	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/idl/VirtualBox.xidl	2008-09-08 10:07:17.000000000 +0200
@@ -9679,7 +9679,7 @@
 
   <interface
      name="IVRDPServer" extends="$unknown"
-     uuid="ed9d31ae-867f-45fc-b727-6740084d1883"
+     uuid="f4584ae7-6bce-474b-83d6-17d235e6aa89"
      wsmap="managed"
      >
     <attribute name="enabled" type="boolean">
@@ -9718,6 +9718,14 @@
       </desc>
     </attribute>
 
+    <attribute name="reuseSingleConnection" type="boolean">
+      <desc>
+        Flag whether the existing connection must be dropped and a new connection
+        must be established by the VRDP server, when a new client connects in single
+        connection mode.
+      </desc>
+    </attribute>
+
   </interface>
 
 
diff -urN VirtualBox-2.0.0/src/VBox/Main/include/ConsoleImpl.h vbox/src/VBox/Main/include/ConsoleImpl.h
--- VirtualBox-2.0.0/src/VBox/Main/include/ConsoleImpl.h	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/include/ConsoleImpl.h	2008-09-08 10:07:16.000000000 +0200
@@ -471,6 +471,7 @@
 
     int mcAudioRefs;
     volatile uint32_t mcVRDPClients;
+    uint32_t mu32SingleRDPClientId; /* The id of a connected client in the single connection mode. */
 
     static const char *sSSMConsoleUnit;
     static uint32_t sSSMConsoleVer;
diff -urN VirtualBox-2.0.0/src/VBox/Main/include/ConsoleVRDPServer.h vbox/src/VBox/Main/include/ConsoleVRDPServer.h
--- VirtualBox-2.0.0/src/VBox/Main/include/ConsoleVRDPServer.h	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/include/ConsoleVRDPServer.h	2008-09-08 10:07:16.000000000 +0200
@@ -97,6 +97,7 @@
     }
 
     void EnableConnections (void);
+    void DisconnectClient (uint32_t u32ClientId, bool fReconnect);
     void MousePointerUpdate (const VRDPCOLORPOINTER *pPointer);
     void MousePointerHide (void);
 
diff -urN VirtualBox-2.0.0/src/VBox/Main/include/VRDPServerImpl.h vbox/src/VBox/Main/include/VRDPServerImpl.h
--- VirtualBox-2.0.0/src/VBox/Main/include/VRDPServerImpl.h	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/include/VRDPServerImpl.h	2008-09-08 10:07:16.000000000 +0200
@@ -47,7 +47,8 @@
                     mVRDPAddress == that.mVRDPAddress &&
                     mAuthType == that.mAuthType &&
                     mAuthTimeout == that.mAuthTimeout &&
-                    mAllowMultiConnection == that.mAllowMultiConnection);
+                    mAllowMultiConnection == that.mAllowMultiConnection &&
+                    mReuseSingleConnection == that.mReuseSingleConnection);
         }
 
         BOOL mEnabled;
@@ -56,6 +57,7 @@
         VRDPAuthType_T mAuthType;
         ULONG mAuthTimeout;
         BOOL mAllowMultiConnection;
+        BOOL mReuseSingleConnection;
     };
 
     VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT (VRDPServer)
@@ -95,6 +97,8 @@
     STDMETHOD(COMSETTER(AuthTimeout)) (ULONG aTimeout);
     STDMETHOD(COMGETTER(AllowMultiConnection)) (BOOL *aAllowMultiConnection);
     STDMETHOD(COMSETTER(AllowMultiConnection)) (BOOL aAllowMultiConnection);
+    STDMETHOD(COMGETTER(ReuseSingleConnection)) (BOOL *aReuseSingleConnection);
+    STDMETHOD(COMSETTER(ReuseSingleConnection)) (BOOL aReuseSingleConnection);
 
     // IVRDPServer methods
 
diff -urN VirtualBox-2.0.0/src/VBox/Main/testcase/tstCollector.cpp vbox/src/VBox/Main/testcase/tstCollector.cpp
--- VirtualBox-2.0.0/src/VBox/Main/testcase/tstCollector.cpp	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/testcase/tstCollector.cpp	2008-09-08 10:07:17.000000000 +0200
@@ -32,6 +32,9 @@
 #include "../linux/PerformanceLinux.cpp"
 #endif
 #ifdef RT_OS_WINDOWS
+#define _WIN32_DCOM
+#include <objidl.h>
+#include <objbase.h>
 #include "../win/PerformanceWin.cpp"
 #endif
 #ifdef RT_OS_OS2
@@ -61,6 +64,21 @@
     return 0;
 }
 
+#define CALLS_PER_SECOND(n,fn) \
+    nCalls = 0; \
+    start = RTTimeMilliTS(); \
+    do { \
+        rc = collector->fn; \
+        ++nCalls; \
+    } while(RTTimeMilliTS() - start < 1000); \
+    if (RT_FAILURE(rc)) \
+    { \
+        RTPrintf("tstCollector: "#fn" -> %Vrc\n", rc); \
+    } \
+    else \
+        RTPrintf("%50s -- %u calls per second\n", #fn, nCalls); \
+    totalTime += n * 1000000 / nCalls
+
 int main(int argc, char *argv[])
 {
     /*
@@ -73,6 +91,22 @@
         RTPrintf("tstCollector: RTR3Init() -> %d\n", rc);
         return 1;
     }
+#ifdef RT_OS_WINDOWS
+    HRESULT hRes = CoInitialize(NULL);
+    /*
+     * Need to initialize security to access performance enumerators.
+     */
+    hRes = CoInitializeSecurity(
+        NULL,
+        -1,
+        NULL,
+        NULL,
+        RPC_C_AUTHN_LEVEL_NONE,
+        RPC_C_IMP_LEVEL_IMPERSONATE,
+        NULL, EOAC_NONE, 0);
+#endif
+
+    uint64_t start;
 
     pm::CollectorHAL *collector = createCollector();
     if (!collector)
@@ -80,7 +114,7 @@
         RTPrintf("tstCollector: createMetricFactory() failed\n", rc);
         return 1;
     }
-
+#if 1
     uint64_t hostUserStart, hostKernelStart, hostIdleStart;
     uint64_t hostUserStop, hostKernelStop, hostIdleStop, hostTotal;
 
@@ -138,7 +172,7 @@
         RTPrintf("tstCollector: getRawProcessCpuLoad() -> %Vrc\n", rc);
         return 1;
     }
-    uint64_t start = RTTimeMilliTS();
+    start = RTTimeMilliTS();
     while(RTTimeMilliTS() - start < 5000); // Loop for 5 seconds
     rc = collector->getRawHostCpuLoad(&hostUserStop, &hostKernelStop, &hostIdleStop);
     if (RT_FAILURE(rc))
@@ -181,10 +215,29 @@
     RTPrintf("tstCollector: host mem used      = %lu kB\n", used);
     RTPrintf("tstCollector: host mem available = %lu kB\n", available);
     RTPrintf("tstCollector: process mem used   = %lu kB\n", processUsed);
-
+#endif
+    RTPrintf("\ntstCollector: TESTING - Performance\n\n");
+    unsigned nCalls;
+    ULONG tmp;
+    uint64_t tmp64;
+    uint32_t totalTime = 0;
+    RTPROCESS pid = RTProcSelf();
+    /* Host CPU load */
+    CALLS_PER_SECOND(1, getRawHostCpuLoad(&tmp64, &tmp64, &tmp64));
+    /* Process CPU load */
+    CALLS_PER_SECOND(100, getRawProcessCpuLoad(pid, &tmp64, &tmp64, &tmp64));
+    /* Host CPU speed */
+    CALLS_PER_SECOND(1, getHostCpuMHz(&tmp));
+    /* Host RAM usage */
+    CALLS_PER_SECOND(1, getHostMemoryUsage(&tmp, &tmp, &tmp));
+    /* Process RAM usage */
+    CALLS_PER_SECOND(100, getProcessMemoryUsage(pid, &tmp));
+    
+    printf("%.2f%% of CPU time\n", totalTime / 10000.);
+    
     delete collector;
 
-    printf ("tstCollector FINISHED.\n");
+    printf ("\ntstCollector FINISHED.\n");
 
     return rc;
 }
diff -urN VirtualBox-2.0.0/src/VBox/Main/xml/VirtualBox-settings-common.xsd vbox/src/VBox/Main/xml/VirtualBox-settings-common.xsd
--- VirtualBox-2.0.0/src/VBox/Main/xml/VirtualBox-settings-common.xsd	2008-09-08 10:06:28.000000000 +0200
+++ vbox/src/VBox/Main/xml/VirtualBox-settings-common.xsd	2008-09-08 10:07:17.000000000 +0200
@@ -471,6 +471,7 @@
   <xsd:attribute name="authType" type="TVRDPAuthType" default="Null"/>
   <xsd:attribute name="authTimeout" type="xsd:unsignedInt" default="5000"/>
   <xsd:attribute name="allowMultiConnection" type="xsd:boolean" default="false"/>
+  <xsd:attribute name="reuseSingleConnection" type="xsd:boolean" default="false"/>
 </xsd:complexType>
 
 <xsd:complexType name="TBIOS">
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/common/log/log.cpp vbox/src/VBox/Runtime/common/log/log.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/common/log/log.cpp	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/common/log/log.cpp	2008-09-08 10:07:19.000000000 +0200
@@ -93,13 +93,9 @@
 #ifdef IN_GC
 /** Default logger instance. */
 extern "C" DECLIMPORT(RTLOGGERRC)   g_Logger;
-/** Default relese logger instance. */
-extern "C" DECLIMPORT(RTLOGGERRC)   g_RelLogger;
 #else /* !IN_GC */
 /** Default logger instance. */
 static PRTLOGGER                    g_pLogger;
-/** Default release logger instance. */
-static PRTLOGGER                    g_pRelLogger;
 #endif /* !IN_GC */
 #ifdef IN_RING3
 /** The RTThreadGetWriteLockCount() change caused by the logger mutex semaphore. */
@@ -932,7 +928,7 @@
  * @param   cchMask     The length of the mask, including modifiers. The modifiers is why
  *                      we update *ppachMask on match.
  */
-static bool rtlogIsGroupMatching(const char *pszGrp, const char **ppachMask, unsigned cchMask)
+static bool rtlogIsGroupMatching(const char *pszGrp, const char **ppachMask, size_t cchMask)
 {
     const char *pachMask;
 
@@ -1518,60 +1514,6 @@
 
 
 /**
- * Gets the default release logger instance.
- *
- * @returns Pointer to default release logger instance.
- * @returns NULL if no default release logger instance available.
- */
-RTDECL(PRTLOGGER)   RTLogRelDefaultInstance(void)
-{
-#ifdef IN_GC
-    return &g_RelLogger;
-#else /* !IN_GC */
-    return g_pRelLogger;
-#endif /* !IN_GC */
-}
-
-
-#ifndef IN_GC
-/**
- * Sets the default logger instance.
- *
- * @returns iprt status code.
- * @param   pLogger     The new default release logger instance.
- */
-RTDECL(PRTLOGGER) RTLogRelSetDefaultInstance(PRTLOGGER pLogger)
-{
-    return (PRTLOGGER)ASMAtomicXchgPtr((void * volatile *)&g_pRelLogger, pLogger);
-}
-#endif /* !IN_GC */
-
-
-/**
- * Write to a logger instance.
- *
- * @param   pLogger     Pointer to logger instance.
- * @param   pvCallerRet Ignored.
- * @param   pszFormat   Format string.
- * @param   ...         Format arguments.
- */
-RTDECL(void) RTLogLogger(PRTLOGGER pLogger, void *pvCallerRet, const char *pszFormat, ...)
-{
-    va_list args;
-    va_start(args, pszFormat);
-#if defined(RT_OS_DARWIN) && defined(RT_ARCH_X86) && defined(IN_RING3)
-    /* manually align the stack before doing the call.
-     * We boldly assume that there is a stack frame here! */
-    __asm__ __volatile__("andl $-32, %%esp\t\n" ::: "%esp");
-    RTLogLoggerExV(pLogger, 0, ~0U, pszFormat, args);
-#else
-    RTLogLoggerExV(pLogger, 0, ~0U, pszFormat, args);
-#endif
-    va_end(args);
-}
-
-
-/**
  * Write to a logger instance.
  *
  * @param   pLogger     Pointer to logger instance.
@@ -1596,114 +1538,21 @@
  *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
  *                      only for internal usage!
  * @param   pszFormat   Format string.
- * @param   ...         Format arguments.
- * @remark  This is a worker function of LogIt.
- */
-RTDECL(void) RTLogLoggerEx(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, ...)
-{
-    va_list args;
-    va_start(args, pszFormat);
-    RTLogLoggerExV(pLogger, fFlags, iGroup, pszFormat, args);
-    va_end(args);
-}
-
-
-/**
- * Write to a logger instance.
- *
- * This function will check whether the instance, group and flags makes up a
- * logging kind which is currently enabled before writing anything to the log.
- *
- * @param   pLogger     Pointer to logger instance. If NULL the default logger instance will be attempted.
- * @param   fFlags      The logging flags.
- * @param   iGroup      The group.
- *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
- *                      only for internal usage!
- * @param   pszFormat   Format string.
  * @param   args        Format arguments.
  */
 RTDECL(void) RTLogLoggerExV(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, va_list args)
 {
-    /*
-     * A NULL logger means default instance.
-     */
-    if (!pLogger)
-    {
-        pLogger = RTLogDefaultInstance();
-        if (!pLogger)
-            return;
-    }
-    rtlogLogger(pLogger, fFlags, iGroup, pszFormat, args);
-}
-
-
-/**
- * Write to a logger instance, defaulting to the release one.
- *
- * This function will check whether the instance, group and flags makes up a
- * logging kind which is currently enabled before writing anything to the log.
- *
- * @param   pLogger     Pointer to logger instance.
- * @param   fFlags      The logging flags.
- * @param   iGroup      The group.
- *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
- *                      only for internal usage!
- * @param   pszFormat   Format string.
- * @param   ...         Format arguments.
- * @remark  This is a worker function for LogRelIt.
- */
-RTDECL(void) RTLogRelLogger(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, ...)
-{
-    va_list args;
-    va_start(args, pszFormat);
-    RTLogRelLoggerV(pLogger, fFlags, iGroup, pszFormat, args);
-    va_end(args);
-}
-
+    int rc;
 
-/**
- * Write to a logger instance, defaulting to the release one.
- *
- * This function will check whether the instance, group and flags makes up a
- * logging kind which is currently enabled before writing anything to the log.
- *
- * @param   pLogger     Pointer to logger instance. If NULL the default release instance is attempted.
- * @param   fFlags      The logging flags.
- * @param   iGroup      The group.
- *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
- *                      only for internal usage!
- * @param   pszFormat   Format string.
- * @param   args        Format arguments.
- */
-RTDECL(void) RTLogRelLoggerV(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, va_list args)
-{
     /*
      * A NULL logger means default instance.
      */
     if (!pLogger)
     {
-        pLogger = RTLogRelDefaultInstance();
+        pLogger = RTLogDefaultInstance();
         if (!pLogger)
             return;
     }
-    rtlogLogger(pLogger, fFlags, iGroup, pszFormat, args);
-}
-
-
-/**
- * Worker for the RTLog[Rel]Logger*() functions.
- *
- * @param   pLogger     Pointer to logger instance.
- * @param   fFlags      The logging flags.
- * @param   iGroup      The group.
- *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
- *                      only for internal usage!
- * @param   pszFormat   Format string.
- * @param   args        Format arguments.
- */
-static void rtlogLogger(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, va_list args)
-{
-    int rc;
 
     /*
      * Validate and correct iGroup.
@@ -1756,23 +1605,6 @@
 
 
 /**
- * printf like function for writing to the default log.
- *
- * @param   pszFormat   Printf like format string.
- * @param   ...         Optional arguments as specified in pszFormat.
- *
- * @remark The API doesn't support formatting of floating point numbers at the moment.
- */
-RTDECL(void) RTLogPrintf(const char *pszFormat, ...)
-{
-    va_list args;
-    va_start(args, pszFormat);
-    RTLogPrintfV(pszFormat, args);
-    va_end(args);
-}
-
-
-/**
  * vprintf like function for writing to the default log.
  *
  * @param   pszFormat   Printf like format string.
@@ -1787,37 +1619,6 @@
 
 
 /**
- * printf like function for writing to the default release log.
- *
- * @param   pszFormat   Printf like format string.
- * @param   ...         Optional arguments as specified in pszFormat.
- *
- * @remark The API doesn't support formatting of floating point numbers at the moment.
- */
-RTDECL(void) RTLogRelPrintf(const char *pszFormat, ...)
-{
-    va_list args;
-    va_start(args, pszFormat);
-    RTLogRelPrintfV(pszFormat, args);
-    va_end(args);
-}
-
-
-/**
- * vprintf like function for writing to the default release log.
- *
- * @param   pszFormat   Printf like format string.
- * @param   args        Optional arguments as specified in pszFormat.
- *
- * @remark The API doesn't support formatting of floating point numbers at the moment.
- */
-RTDECL(void) RTLogRelPrintfV(const char *pszFormat, va_list args)
-{
-    RTLogRelLoggerV(NULL, 0, ~0U, pszFormat, args);
-}
-
-
-/**
  * Writes the buffer to the given log device without checking for buffered
  * data or anything.
  * Used by the RTLogFlush() function.
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/common/log/logellipsis.cpp vbox/src/VBox/Runtime/common/log/logellipsis.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/common/log/logellipsis.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vbox/src/VBox/Runtime/common/log/logellipsis.cpp	2008-09-08 10:07:19.000000000 +0200
@@ -0,0 +1,101 @@
+/** @file
+ * Runtime VBox - Logger, the ellipsis variants.
+ */
+
+/*
+ * Copyright (C) 2006-2007 Sun Microsystems, Inc.
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ *
+ * The contents of this file may alternatively be used under the terms
+ * of the Common Development and Distribution License Version 1.0
+ * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
+ * VirtualBox OSE distribution, in which case the provisions of the
+ * CDDL are applicable instead of those of the GPL.
+ *
+ * You may elect to license modified versions of this file under the
+ * terms and conditions of either the GPL or the CDDL or both.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 USA or visit http://www.sun.com if you need
+ * additional information or have any questions.
+ */
+
+/*******************************************************************************
+*   Header Files                                                               *
+*******************************************************************************/
+#include <iprt/log.h>
+#include <iprt/asm.h>
+#include <iprt/stdarg.h>
+
+
+/**
+ * Write to a logger instance.
+ *
+ * @param   pLogger     Pointer to logger instance.
+ * @param   pvCallerRet Ignored.
+ * @param   pszFormat   Format string.
+ * @param   ...         Format arguments.
+ */
+RTDECL(void) RTLogLogger(PRTLOGGER pLogger, void *pvCallerRet, const char *pszFormat, ...)
+{
+    va_list args;
+    va_start(args, pszFormat);
+#if defined(RT_OS_DARWIN) && defined(RT_ARCH_X86) && defined(IN_RING3)
+    /* manually align the stack before doing the call.
+     * We boldly assume that there is a stack frame here! */
+    __asm__ __volatile__("andl $-32, %%esp\t\n" ::: "%esp");
+    RTLogLoggerExV(pLogger, 0, ~0U, pszFormat, args);
+#else
+    RTLogLoggerExV(pLogger, 0, ~0U, pszFormat, args);
+#endif
+    va_end(args);
+}
+
+
+/**
+ * Write to a logger instance.
+ *
+ * This function will check whether the instance, group and flags makes up a
+ * logging kind which is currently enabled before writing anything to the log.
+ *
+ * @param   pLogger     Pointer to logger instance. If NULL the default logger instance will be attempted.
+ * @param   fFlags      The logging flags.
+ * @param   iGroup      The group.
+ *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
+ *                      only for internal usage!
+ * @param   pszFormat   Format string.
+ * @param   ...         Format arguments.
+ * @remark  This is a worker function of LogIt.
+ */
+RTDECL(void) RTLogLoggerEx(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, ...)
+{
+    va_list args;
+    va_start(args, pszFormat);
+    RTLogLoggerExV(pLogger, fFlags, iGroup, pszFormat, args);
+    va_end(args);
+}
+
+
+/**
+ * printf like function for writing to the default log.
+ *
+ * @param   pszFormat   Printf like format string.
+ * @param   ...         Optional arguments as specified in pszFormat.
+ *
+ * @remark The API doesn't support formatting of floating point numbers at the moment.
+ */
+RTDECL(void) RTLogPrintf(const char *pszFormat, ...)
+{
+    va_list args;
+    va_start(args, pszFormat);
+    RTLogPrintfV(pszFormat, args);
+    va_end(args);
+}
+
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/common/log/logrel.cpp vbox/src/VBox/Runtime/common/log/logrel.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/common/log/logrel.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vbox/src/VBox/Runtime/common/log/logrel.cpp	2008-09-08 10:07:19.000000000 +0200
@@ -0,0 +1,144 @@
+/** @file
+ * Runtime VBox - Logger.
+ */
+
+/*
+ * Copyright (C) 2006-2007 Sun Microsystems, Inc.
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ *
+ * The contents of this file may alternatively be used under the terms
+ * of the Common Development and Distribution License Version 1.0
+ * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
+ * VirtualBox OSE distribution, in which case the provisions of the
+ * CDDL are applicable instead of those of the GPL.
+ *
+ * You may elect to license modified versions of this file under the
+ * terms and conditions of either the GPL or the CDDL or both.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 USA or visit http://www.sun.com if you need
+ * additional information or have any questions.
+ */
+
+
+/*******************************************************************************
+*   Header Files                                                               *
+*******************************************************************************/
+#include <iprt/log.h>
+#ifndef IN_GC
+# include <iprt/alloc.h>
+# include <iprt/process.h>
+# include <iprt/semaphore.h>
+# include <iprt/thread.h>
+# include <iprt/mp.h>
+#endif
+#ifdef IN_RING3
+# include <iprt/file.h>
+# include <iprt/path.h>
+#endif
+#include <iprt/time.h>
+#include <iprt/asm.h>
+#include <iprt/assert.h>
+#include <iprt/err.h>
+#include <iprt/param.h>
+
+#include <iprt/stdarg.h>
+#include <iprt/string.h>
+#include <iprt/ctype.h>
+#ifdef IN_RING3
+# include <iprt/alloca.h>
+# include <stdio.h>
+#endif
+
+
+/*******************************************************************************
+*   Global Variables                                                           *
+*******************************************************************************/
+#ifdef IN_GC
+/** Default relese logger instance. */
+extern "C" DECLIMPORT(RTLOGGERRC)   g_RelLogger;
+#else /* !IN_GC */
+/** Default release logger instance. */
+static PRTLOGGER                    g_pRelLogger;
+#endif /* !IN_GC */
+
+
+/**
+ * Gets the default release logger instance.
+ *
+ * @returns Pointer to default release logger instance.
+ * @returns NULL if no default release logger instance available.
+ */
+RTDECL(PRTLOGGER)   RTLogRelDefaultInstance(void)
+{
+#ifdef IN_GC
+    return &g_RelLogger;
+#else /* !IN_GC */
+    return g_pRelLogger;
+#endif /* !IN_GC */
+}
+
+
+#ifndef IN_GC
+/**
+ * Sets the default logger instance.
+ *
+ * @returns iprt status code.
+ * @param   pLogger     The new default release logger instance.
+ */
+RTDECL(PRTLOGGER) RTLogRelSetDefaultInstance(PRTLOGGER pLogger)
+{
+    return (PRTLOGGER)ASMAtomicXchgPtr((void * volatile *)&g_pRelLogger, pLogger);
+}
+#endif /* !IN_GC */
+
+
+/**
+ * Write to a logger instance, defaulting to the release one.
+ *
+ * This function will check whether the instance, group and flags makes up a
+ * logging kind which is currently enabled before writing anything to the log.
+ *
+ * @param   pLogger     Pointer to logger instance. If NULL the default release instance is attempted.
+ * @param   fFlags      The logging flags.
+ * @param   iGroup      The group.
+ *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
+ *                      only for internal usage!
+ * @param   pszFormat   Format string.
+ * @param   args        Format arguments.
+ */
+RTDECL(void) RTLogRelLoggerV(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, va_list args)
+{
+    /*
+     * A NULL logger means default instance.
+     */
+    if (!pLogger)
+    {
+        pLogger = RTLogRelDefaultInstance();
+        if (!pLogger)
+            return;
+    }
+    RTLogLoggerExV(pLogger, fFlags, iGroup, pszFormat, args);
+}
+
+
+/**
+ * vprintf like function for writing to the default release log.
+ *
+ * @param   pszFormat   Printf like format string.
+ * @param   args        Optional arguments as specified in pszFormat.
+ *
+ * @remark The API doesn't support formatting of floating point numbers at the moment.
+ */
+RTDECL(void) RTLogRelPrintfV(const char *pszFormat, va_list args)
+{
+    RTLogRelLoggerV(NULL, 0, ~0U, pszFormat, args);
+}
+
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/common/log/logrelellipsis.cpp vbox/src/VBox/Runtime/common/log/logrelellipsis.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/common/log/logrelellipsis.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vbox/src/VBox/Runtime/common/log/logrelellipsis.cpp	2008-09-08 10:07:19.000000000 +0200
@@ -0,0 +1,76 @@
+/** @file
+ * Runtime VBox - Logger, the release ellipsis variants.
+ */
+
+/*
+ * Copyright (C) 2006-2007 Sun Microsystems, Inc.
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ *
+ * The contents of this file may alternatively be used under the terms
+ * of the Common Development and Distribution License Version 1.0
+ * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
+ * VirtualBox OSE distribution, in which case the provisions of the
+ * CDDL are applicable instead of those of the GPL.
+ *
+ * You may elect to license modified versions of this file under the
+ * terms and conditions of either the GPL or the CDDL or both.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 USA or visit http://www.sun.com if you need
+ * additional information or have any questions.
+ */
+
+/*******************************************************************************
+*   Header Files                                                               *
+*******************************************************************************/
+#include <iprt/log.h>
+#include <iprt/stdarg.h>
+
+
+/**
+ * Write to a logger instance, defaulting to the release one.
+ *
+ * This function will check whether the instance, group and flags makes up a
+ * logging kind which is currently enabled before writing anything to the log.
+ *
+ * @param   pLogger     Pointer to logger instance.
+ * @param   fFlags      The logging flags.
+ * @param   iGroup      The group.
+ *                      The value ~0U is reserved for compatability with RTLogLogger[V] and is
+ *                      only for internal usage!
+ * @param   pszFormat   Format string.
+ * @param   ...         Format arguments.
+ * @remark  This is a worker function for LogRelIt.
+ */
+RTDECL(void) RTLogRelLogger(PRTLOGGER pLogger, unsigned fFlags, unsigned iGroup, const char *pszFormat, ...)
+{
+    va_list args;
+    va_start(args, pszFormat);
+    RTLogRelLoggerV(pLogger, fFlags, iGroup, pszFormat, args);
+    va_end(args);
+}
+
+
+/**
+ * printf like function for writing to the default release log.
+ *
+ * @param   pszFormat   Printf like format string.
+ * @param   ...         Optional arguments as specified in pszFormat.
+ *
+ * @remark The API doesn't support formatting of floating point numbers at the moment.
+ */
+RTDECL(void) RTLogRelPrintf(const char *pszFormat, ...)
+{
+    va_list args;
+    va_start(args, pszFormat);
+    RTLogRelPrintfV(pszFormat, args);
+    va_end(args);
+}
+
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/generic/mppresent-generic.cpp vbox/src/VBox/Runtime/generic/mppresent-generic.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/generic/mppresent-generic.cpp	1970-01-01 01:00:00.000000000 +0100
+++ vbox/src/VBox/Runtime/generic/mppresent-generic.cpp	2008-09-08 10:07:18.000000000 +0200
@@ -0,0 +1,52 @@
+/** @file
+ * IPRT - Multiprocessor, Stubs for the RTMp*Present* API.
+ */
+
+/*
+ * Copyright (C) 2008 Sun Microsystems, Inc.
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ *
+ * The contents of this file may alternatively be used under the terms
+ * of the Common Development and Distribution License Version 1.0
+ * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
+ * VirtualBox OSE distribution, in which case the provisions of the
+ * CDDL are applicable instead of those of the GPL.
+ *
+ * You may elect to license modified versions of this file under the
+ * terms and conditions of either the GPL or the CDDL or both.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
+ * Clara, CA 95054 USA or visit http://www.sun.com if you need
+ * additional information or have any questions.
+ */
+
+/*******************************************************************************
+*   Header Files                                                               *
+*******************************************************************************/
+#include <iprt/mp.h>
+
+
+RTDECL(PRTCPUSET) RTMpGetPresentSet(PRTCPUSET pSet)
+{
+    return RTMpGetSet(pSet);
+}
+
+
+RTDECL(RTCPUID) RTMpGetPresentCount(void)
+{
+    return RTMpGetCount();
+}
+
+
+RTDECL(bool) RTMpIsCpuPresent(RTCPUID idCpu)
+{
+    return RTMpIsCpuPossible(idCpu);
+}
+
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/Makefile.kmk vbox/src/VBox/Runtime/Makefile.kmk
--- VirtualBox-2.0.0/src/VBox/Runtime/Makefile.kmk	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/Makefile.kmk	2008-09-08 10:07:18.000000000 +0200
@@ -185,6 +185,9 @@
 	common/ldr/ldrNative.cpp \
 	common/ldr/ldrPE.cpp \
 	common/log/log.cpp \
+	common/log/logellipsis.cpp \
+	common/log/logrel.cpp \
+	common/log/logrelellipsis.cpp \
 	common/log/logcom.cpp \
 	common/log/logformat.cpp \
 	common/misc/assert.cpp \
@@ -293,6 +296,7 @@
 	generic/RTMpGetMaxFrequency-generic.cpp \
 	generic/RTRandAdvCreateSystemFaster-generic.cpp \
 	generic/RTRandAdvCreateSystemTruer-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/semnoint-generic.cpp \
 	generic/semsrw-generic.cpp \
 	nt/RTErrConvertFromNtStatus.cpp \
@@ -334,6 +338,7 @@
 	generic/RTTimeLocalNow-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
 	generic/RTUuidCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/utf16locale-generic.cpp \
 	generic/uuid-generic.cpp \
 	r3/linux/mp-linux.cpp \
@@ -384,6 +389,7 @@
 	generic/RTTimeLocalNow-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
 	generic/RTUuidCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/semnoint-generic.cpp \
 	generic/semsrw-generic.cpp \
 	generic/timer-generic.cpp \
@@ -425,6 +431,7 @@
 	generic/RTTimeLocalNow-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
 	generic/RTUuidCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/sched-generic.cpp \
 	generic/timer-generic.cpp \
 	generic/utf16locale-generic.cpp \
@@ -462,6 +469,7 @@
 	generic/RTTimeLocalNow-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
 	generic/RTUuidCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/sched-generic.cpp \
 	generic/utf16locale-generic.cpp \
 	generic/uuid-generic.cpp \
@@ -554,6 +562,7 @@
 	generic/RTSystemQueryOSInfo-generic.cpp \
 	generic/RTTimeLocalNow-generic.cpp \
 	generic/RTUuidCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/sched-generic.cpp \
 	generic/semnoint-generic.cpp \
 	generic/semsrw-generic.cpp \
@@ -690,7 +699,7 @@
 VBoxRT_INST                    = $(INST_DLL) $(INST_TESTCASE)
 endif
 VBoxRT_DEFS                    = $(RuntimeR3_DEFS) IN_SUP_R3 IN_SUP_R3
-VBoxRT_DEFS.$(KBUILD_TYPE)      = $(RuntimeR3_DEFS.$(KBUILD_TYPE))
+VBoxRT_DEFS.$(KBUILD_TYPE)     = $(RuntimeR3_DEFS.$(KBUILD_TYPE))
 VBoxRT_SOURCES                 = \
 	VBox/VBoxRTDeps.cpp \
 	$(RuntimeR3_SOURCES)
@@ -700,7 +709,7 @@
 VBoxRT_SOURCES.win.x86        += r3/win/VBoxRT-win32.def
 VBoxRT_SOURCES.win.amd64      += r3/win/VBoxRT-win64.def
 VBoxRT_INCS                    = $(RuntimeR3_INCS)
-VBoxRT_INCS.$(KBUILD_TARGET)    = $(RuntimeR3_INCS.$(KBUILD_TARGET))
+VBoxRT_INCS.$(KBUILD_TARGET)   = $(RuntimeR3_INCS.$(KBUILD_TARGET))
 VBoxRT_INCS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH) = $(RuntimeR3_INCS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
 VBoxRT_LIBS                    = \
 	$(PATH_LIB)/SUPR3$(VBOX_SUFF_LIB) \
@@ -826,6 +835,8 @@
 	common/checksum/crc64.cpp \
 	common/checksum/md5.cpp \
 	common/checksum/ipv4.cpp \
+	common/log/logellipsis.cpp \
+	common/log/logrelellipsis.cpp \
 	common/log/logcom.cpp \
 	common/log/logformat.cpp \
 	common/misc/assert.cpp \
@@ -927,11 +938,15 @@
 endif
 
 RuntimeR0Drv_SOURCES    = \
+	common/alloc/alloc.cpp \
 	common/checksum/crc32.cpp \
 	common/checksum/crc64.cpp \
 	common/checksum/md5.cpp \
 	common/checksum/ipv4.cpp \
 	common/log/log.cpp \
+	common/log/logellipsis.cpp \
+	common/log/logrel.cpp \
+	common/log/logrelellipsis.cpp \
 	common/log/logcom.cpp \
 	common/log/logformat.cpp \
 	common/misc/assert.cpp \
@@ -960,6 +975,7 @@
 	common/err/RTErrConvertToErrno.cpp \
 	generic/RTAssertDoBreakpoint-generic.cpp \
 	generic/RTLogWriteStdOut-stub-generic.cpp \
+	generic/mppresent-generic.cpp \
 	r0drv/linux/alloc-r0drv-linux.c \
 	r0drv/linux/initterm-r0drv-linux.c \
 	r0drv/linux/memobj-r0drv-linux.c \
@@ -990,6 +1006,7 @@
 	common/string/strpbrk.cpp \
 	generic/RTAssertDoBreakpoint-generic.cpp \
 	generic/RTLogWriteStdOut-stub-generic.cpp \
+	generic/mppresent-generic.cpp \
 	nt/RTErrConvertFromNtStatus.cpp \
 	r0drv/memobj-r0drv.cpp \
 	r0drv/mpnotification-r0drv.c \
@@ -1034,6 +1051,7 @@
 	generic/RTMpGetSet-generic.cpp \
 	generic/RTMpIsCpuOnline-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	generic/timer-generic.cpp \
 	r0drv/generic/RTMpOn-r0drv-generic.cpp \
 	r0drv/generic/mpnotification-r0drv-generic.cpp \
@@ -1080,6 +1098,7 @@
 	generic/RTMpGetSet-generic.cpp \
 	generic/RTMpIsCpuOnline-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	os2/RTErrConvertFromOS2.cpp \
 	os2/sys0.asm \
 	r0drv/memobj-r0drv.cpp \
@@ -1128,6 +1147,7 @@
 	generic/RTMpGetSet-generic.cpp \
 	generic/RTMpIsCpuOnline-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	r0drv/generic/RTMpOn-r0drv-generic.cpp \
 	r0drv/generic/mpnotification-r0drv-generic.cpp \
 	r0drv/freebsd/alloc-r0drv-freebsd.c \
@@ -1152,6 +1172,7 @@
 	generic/RTAssertDoBreakpoint-generic.cpp \
 	generic/RTLogWriteStdOut-stub-generic.cpp \
 	generic/RTTimerCreate-generic.cpp \
+	generic/mppresent-generic.cpp \
 	r0drv/memobj-r0drv.cpp \
 	r0drv/mpnotification-r0drv.c
 
@@ -1248,6 +1269,7 @@
  	generic/RTMpGetSet-generic.cpp \
  	generic/RTMpIsCpuOnline-generic.cpp \
 	generic/RTLogWriteStdOut-stub-generic.cpp \
+	generic/mppresent-generic.cpp \
 	r0drv/generic/RTMpOn-r0drv-generic.cpp \
 	r0drv/generic/mpnotification-r0drv-generic.cpp \
  	r0drv/solaris/alloc-r0drv-solaris.c \
@@ -1281,6 +1303,9 @@
 RuntimeGC_INCS          = include
 RuntimeGC_SOURCES       = \
 	common/log/log.cpp \
+	common/log/logellipsis.cpp \
+	common/log/logrel.cpp \
+	common/log/logrelellipsis.cpp \
 	common/log/logcom.cpp \
 	common/log/logformat.cpp \
 	common/misc/assert.cpp \
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c vbox/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c
--- VirtualBox-2.0.0/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c	2008-09-08 10:07:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* $Revision$ */
+/* $Revision$ */
 /** @file
  * IPRT - Ring-0 Memory Objects, Linux.
  */
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/r0drv/linux/timer-r0drv-linux.c vbox/src/VBox/Runtime/r0drv/linux/timer-r0drv-linux.c
--- VirtualBox-2.0.0/src/VBox/Runtime/r0drv/linux/timer-r0drv-linux.c	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/r0drv/linux/timer-r0drv-linux.c	2008-09-08 10:07:18.000000000 +0200
@@ -468,7 +468,7 @@
     do
     {
         RTMpGetOnlineSet(&OnlineSet);
-        for (iCpu = 0; iCpu <= pTimer->cCpus; iCpu++)
+        for (iCpu = 0; iCpu < pTimer->cCpus; iCpu++)
         {
             Assert(pTimer->aSubTimers[iCpu].enmState != RTTIMERLNXSTATE_MP_STOPPING);
             rtTimerLnxSetState(&pTimer->aSubTimers[iCpu].enmState,
@@ -496,7 +496,7 @@
      */
     RTSpinlockAcquire(pTimer->hSpinlock, &Tmp);
 
-    for (iCpu = 0; iCpu <= pTimer->cCpus; iCpu++)
+    for (iCpu = 0; iCpu < pTimer->cCpus; iCpu++)
         if (rtTimerLnxCmpXchgState(&pTimer->aSubTimers[iCpu].enmState, RTTIMERLNXSTATE_STOPPED, RTTIMERLNXSTATE_STARTING))
         {
             /** @todo very odd case for a rainy day. Cpus that temporarily went offline while
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/r3/solaris/mp-solaris.cpp vbox/src/VBox/Runtime/r3/solaris/mp-solaris.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/r3/solaris/mp-solaris.cpp	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/r3/solaris/mp-solaris.cpp	2008-09-08 10:07:18.000000000 +0200
@@ -222,6 +222,13 @@
 }
 
 
+RTDECL(bool) RTMpIsCpuPresent(RTCPUID idCpu)
+{
+    int iStatus = p_online(idCpu, P_STATUS);
+    return iStatus != -1;
+}
+
+
 RTDECL(RTCPUID) RTMpGetCount(void)
 {
     /*
@@ -263,3 +270,32 @@
     return pSet;
 }
 
+
+RTDECL(PRTCPUSET) RTMpGetPresentSet(PRTCPUSET pSet)
+{
+#ifdef RT_STRICT
+    long cCpusPresent = 0;
+#endif
+    RTCpuSetEmpty(pSet);
+    RTCPUID cCpus = RTMpGetCount();
+    for (RTCPUID idCpu = 0; idCpu < cCpus; idCpu++)
+        if (RTMpIsCpuPresent(idCpu))
+        {
+            RTCpuSetAdd(pSet, idCpu);
+#ifdef RT_STRICT
+            cCpusPresent++;
+#endif
+        }
+    Assert(cCpusPresent == RTMpGetPresentCount());
+    return pSet;
+}
+
+
+RTDECL(RTCPUID) RTMpGetPresentCount(void)
+{
+    /*
+     * Solaris has sysconf.
+     */
+    return sysconf(_SC_NPROCESSORS_CONF);
+}
+
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/testcase/tstMp-1.cpp vbox/src/VBox/Runtime/testcase/tstMp-1.cpp
--- VirtualBox-2.0.0/src/VBox/Runtime/testcase/tstMp-1.cpp	2008-09-08 10:06:30.000000000 +0200
+++ vbox/src/VBox/Runtime/testcase/tstMp-1.cpp	2008-09-08 10:07:19.000000000 +0200
@@ -48,7 +48,6 @@
     RTR3Init();
     RTPrintf("tstMp-1: TESTING...\n");
 
-#if defined(RT_OS_OS2) || defined(RT_OS_WINDOWS) || defined(RT_OS_LINUX) || defined(RT_OS_DARWIN)
     /*
      * Present and possible CPUs.
      */
@@ -78,8 +77,21 @@
             RTCPUID idCpu = RTMpCpuIdFromSetIndex(iCpu);
             if (RTCpuSetIsMemberByIndex(&Set, iCpu))
             {
-                RTPrintf("tstMp-1: %2d - id %d: %u/%u MHz %s\n", iCpu, (int)idCpu, RTMpGetCurFrequency(idCpu),
-                         RTMpGetMaxFrequency(idCpu), RTMpIsCpuOnline(idCpu) ? "online" : "offline");
+                RTPrintf("tstMp-1: %2d - id %d: %u/%u MHz", iCpu, (int)idCpu,
+                         RTMpGetCurFrequency(idCpu), RTMpGetMaxFrequency(idCpu));
+                if (RTMpIsCpuPresent(idCpu))
+                    RTPrintf(RTMpIsCpuOnline(idCpu) ? " online\n" : " offline\n");
+                else
+                {
+                    if (!RTMpIsCpuOnline(idCpu))
+                        RTPrintf(" absent\n");
+                    else
+                    {
+                        RTPrintf(" online but absent!\n");
+                        RTPrintf("tstMp-1: FAILURE: Cpu with index %d is report as !RTIsCpuPresent while RTIsCpuOnline returns true!\n", iCpu);
+                        g_cErrors++;
+                    }
+                }
                 if (!RTMpIsCpuPossible(idCpu))
                 {
                     RTPrintf("tstMp-1: FAILURE: Cpu with index %d is returned by RTCpuSet but not RTMpIsCpuPossible!\n", iCpu);
@@ -170,9 +182,66 @@
         g_cErrors++;
     }
 
-#else
-    RTPrintf("tstMp-1: SKIPPED - RTMp is not implemented on this host OS.\n");
-#endif
+    /*
+     * Present CPUs.
+     */
+    RTCPUID cCpusPresent = RTMpGetPresentCount();
+    if (cCpusPresent > 0)
+    {
+        if (    cCpusPresent <= cCpus
+            &&  cCpusPresent >= cCpusOnline)
+            RTPrintf("tstMp-1: RTMpGetPresentCount -> %d\n", (int)cCpusPresent);
+        else
+        {
+            RTPrintf("tstMp-1: FAILURE: RTMpGetPresentCount -> %d, expected <= %d and >= %d\n", (int)cCpusPresent, (int)cCpus, (int)cCpusOnline);
+            g_cErrors++;
+        }
+    }
+    else
+    {
+        RTPrintf("tstMp-1: FAILURE: RTMpGetPresentCount -> %d\n", (int)cCpusPresent);
+        g_cErrors++;
+        cCpusPresent = 1;
+    }
+
+    RTCPUSET SetPresent;
+    pSet = RTMpGetPresentSet(&SetPresent);
+    if (pSet == &SetPresent)
+    {
+        if (RTCpuSetCount(&SetPresent) <= 0)
+        {
+            RTPrintf("tstMp-1: FAILURE: RTMpGetPresentSet returned an empty set!\n");
+            g_cErrors++;
+        }
+        else if ((RTCPUID)RTCpuSetCount(&SetPresent) != cCpusPresent)
+        {
+            RTPrintf("tstMp-1: FAILURE: RTMpGetPresentSet returned a bad value; %d, expected = %d\n",
+                     RTCpuSetCount(&SetPresent), cCpusPresent);
+            g_cErrors++;
+        }
+        RTPrintf("tstMp-1: Present CPU mask:\n");
+        for (int iCpu = 0; iCpu < RTCPUSET_MAX_CPUS; iCpu++)
+            if (RTCpuSetIsMemberByIndex(&SetPresent, iCpu))
+            {
+                RTCPUID idCpu = RTMpCpuIdFromSetIndex(iCpu);
+                RTPrintf("tstMp-1: %2d - id %d: %u/%u MHz %s\n", iCpu, (int)idCpu, RTMpGetCurFrequency(idCpu),
+                         RTMpGetMaxFrequency(idCpu), RTMpIsCpuPresent(idCpu) ? "present" : "absent");
+                if (!RTCpuSetIsMemberByIndex(&Set, iCpu))
+                {
+                    RTPrintf("tstMp-1: FAILURE: online cpu with index %2d is not a member of the possible cpu set!\n", iCpu);
+                    g_cErrors++;
+                }
+            }
+
+        /* There isn't any sane way of testing RTMpIsCpuPresent really... :-/ */
+    }
+    else
+    {
+        RTPrintf("tstMp-1: FAILURE: RTMpGetPresentSet -> %p, expected %p\n", pSet, &Set);
+        g_cErrors++;
+    }
+
+
 
     if (!g_cErrors)
         RTPrintf("tstMp-1: SUCCESS\n", g_cErrors);
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR0.asm vbox/src/VBox/Runtime/win/amd64/ASMGetDR0.asm
--- VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR0.asm	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/win/amd64/ASMGetDR0.asm	2008-09-08 10:07:18.000000000 +0200
@@ -45,3 +45,7 @@
 ENDPROC ASMGetDR0
 
 
+BEGINPROC_EXPORTED ASMSetDR0
+        mov     dr0, rcx
+        ret
+ENDPROC ASMSetDR0
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR1.asm vbox/src/VBox/Runtime/win/amd64/ASMGetDR1.asm
--- VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR1.asm	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/win/amd64/ASMGetDR1.asm	2008-09-08 10:07:18.000000000 +0200
@@ -44,3 +44,7 @@
 ENDPROC ASMGetDR1
 
 
+BEGINPROC_EXPORTED ASMSetDR1
+        mov     dr1, rcx
+        ret
+ENDPROC ASMSetDR1
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR2.asm vbox/src/VBox/Runtime/win/amd64/ASMGetDR2.asm
--- VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR2.asm	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/win/amd64/ASMGetDR2.asm	2008-09-08 10:07:18.000000000 +0200
@@ -45,3 +45,7 @@
 ENDPROC ASMGetDR2
 
 
+BEGINPROC_EXPORTED ASMSetDR2
+        mov     dr2, rcx
+        ret
+ENDPROC ASMSetDR2
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR3.asm vbox/src/VBox/Runtime/win/amd64/ASMGetDR3.asm
--- VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR3.asm	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/win/amd64/ASMGetDR3.asm	2008-09-08 10:07:18.000000000 +0200
@@ -45,3 +45,7 @@
 ENDPROC ASMGetDR3
 
 
+BEGINPROC_EXPORTED ASMSetDR3
+        mov     dr3, rcx
+        ret
+ENDPROC ASMSetDR3
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR6.asm vbox/src/VBox/Runtime/win/amd64/ASMGetDR6.asm
--- VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR6.asm	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/win/amd64/ASMGetDR6.asm	2008-09-08 10:07:18.000000000 +0200
@@ -44,3 +44,7 @@
 ENDPROC ASMGetDR6
 
 
+BEGINPROC_EXPORTED ASMSetDR6
+        mov     dr6, rcx
+        ret
+ENDPROC ASMSetDR6
diff -urN VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR7.asm vbox/src/VBox/Runtime/win/amd64/ASMGetDR7.asm
--- VirtualBox-2.0.0/src/VBox/Runtime/win/amd64/ASMGetDR7.asm	2008-09-08 10:06:29.000000000 +0200
+++ vbox/src/VBox/Runtime/win/amd64/ASMGetDR7.asm	2008-09-08 10:07:18.000000000 +0200
@@ -43,3 +43,7 @@
         ret
 ENDPROC ASMGetDR7
 
+BEGINPROC_EXPORTED ASMSetDR7
+        mov     dr7, rcx
+        ret
+ENDPROC ASMSetDR7
diff -urN VirtualBox-2.0.0/src/VBox/VMM/CPUM.cpp vbox/src/VBox/VMM/CPUM.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/CPUM.cpp	2008-09-08 10:06:32.000000000 +0200
+++ vbox/src/VBox/VMM/CPUM.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -705,7 +705,7 @@
     pCtx->trHid.Attr.n.u1Present    = 1;
     pCtx->trHid.Attr.n.u4Type       = X86_SEL_TYPE_SYS_386_TSS_BUSY;
 
-    pCtx->dr6                       = UINT32_C(0xFFFF0FF0);
+    pCtx->dr6                       = X86_DR6_INIT_VAL;
     pCtx->dr7                       = 0x400;
 
     pCtx->fpu.FTW                   = 0xff;         /* All tags are set, i.e. the regs are empty. */
diff -urN VirtualBox-2.0.0/src/VBox/VMM/EM.cpp vbox/src/VBox/VMM/EM.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/EM.cpp	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/VMM/EM.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -2291,6 +2291,10 @@
         case VERR_VMX_INVALID_VMCS_FIELD:
         case VERR_VMX_INVALID_VMCS_PTR:
         case VERR_VMX_INVALID_VMXON_PTR:
+        case VERR_VMX_UNEXPECTED_INTERRUPTION_EXIT_CODE:
+        case VERR_VMX_UNEXPECTED_EXCEPTION:
+        case VERR_VMX_UNEXPECTED_EXIT_CODE:
+        case VERR_VMX_INVALID_GUEST_STATE:
             HWACCMR3CheckError(pVM, rc);
             break;
         /*
diff -urN VirtualBox-2.0.0/src/VBox/VMM/HWACCM.cpp vbox/src/VBox/VMM/HWACCM.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/HWACCM.cpp	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/VMM/HWACCM.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -124,6 +124,7 @@
     STAM_REG(pVM, &pVM->hwaccm.s.StatExitGuestGP,   STAMTYPE_COUNTER, "/HWACCM/Exit/Trap/Guest/#GP",    STAMUNIT_OCCURENCES,    "Nr of occurances");
     STAM_REG(pVM, &pVM->hwaccm.s.StatExitGuestMF,   STAMTYPE_COUNTER, "/HWACCM/Exit/Trap/Guest/#MF",    STAMUNIT_OCCURENCES,    "Nr of occurances");
     STAM_REG(pVM, &pVM->hwaccm.s.StatExitGuestDE,   STAMTYPE_COUNTER, "/HWACCM/Exit/Trap/Guest/#DE",    STAMUNIT_OCCURENCES,    "Nr of occurances");
+    STAM_REG(pVM, &pVM->hwaccm.s.StatExitGuestDB,   STAMTYPE_COUNTER, "/HWACCM/Exit/Trap/Guest/#DB",    STAMUNIT_OCCURENCES,    "Nr of occurances");
     STAM_REG(pVM, &pVM->hwaccm.s.StatExitInvpg,     STAMTYPE_COUNTER, "/HWACCM/Exit/Instr/Invlpg",      STAMUNIT_OCCURENCES,    "Nr of occurances");
     STAM_REG(pVM, &pVM->hwaccm.s.StatExitInvd,      STAMTYPE_COUNTER, "/HWACCM/Exit/Instr/Invd",        STAMUNIT_OCCURENCES,    "Nr of occurances");
     STAM_REG(pVM, &pVM->hwaccm.s.StatExitCpuid,     STAMTYPE_COUNTER, "/HWACCM/Exit/Instr/Cpuid",       STAMUNIT_OCCURENCES,    "Nr of occurances");
@@ -509,6 +510,11 @@
             LogRel(("HWACCM: MSR_IA32_VMX_CR4_FIXED1       = %VX64\n", pVM->hwaccm.s.vmx.msr.vmx_cr4_fixed1));
             LogRel(("HWACCM: MSR_IA32_VMX_VMCS_ENUM        = %VX64\n", pVM->hwaccm.s.vmx.msr.vmx_vmcs_enum));
 
+            LogRel(("HWACCM: VMCS physaddr                 = %VHp\n", pVM->hwaccm.s.vmx.pVMCSPhys));
+            LogRel(("HWACCM: Real mode TSS physaddr        = %VHp\n", pVM->hwaccm.s.vmx.pRealModeTSSPhys));
+            LogRel(("HWACCM: TPR shadow physaddr           = %VHp\n", pVM->hwaccm.s.vmx.pAPICPhys));
+            LogRel(("HWACCM: MSR bitmap physaddr           = %VHp\n", pVM->hwaccm.s.vmx.pMSRBitmapPhys));
+
             /* Only try once. */
             pVM->hwaccm.s.fInitialized = true;
 
diff -urN VirtualBox-2.0.0/src/VBox/VMM/HWACCMInternal.h vbox/src/VBox/VMM/HWACCMInternal.h
--- VirtualBox-2.0.0/src/VBox/VMM/HWACCMInternal.h	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/VMM/HWACCMInternal.h	2008-09-08 10:07:21.000000000 +0200
@@ -32,6 +32,8 @@
 #include <iprt/cpuset.h>
 #include <iprt/mp.h>
 
+////#define VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+
 #if HC_ARCH_BITS == 64
 /* Enable 64 bits guest support. */
 # define VBOX_ENABLE_64_BITS_GUESTS
@@ -108,11 +110,11 @@
  *  Currently #NM and #PF only
  */
 #ifdef VBOX_STRICT
-#define HWACCM_VMX_TRAP_MASK                RT_BIT(X86_XCPT_DE) | RT_BIT(X86_XCPT_NM) | RT_BIT(X86_XCPT_PF) | RT_BIT(X86_XCPT_UD) | RT_BIT(X86_XCPT_NP) | RT_BIT(X86_XCPT_SS) | RT_BIT(X86_XCPT_GP) | RT_BIT(X86_XCPT_MF)
+#define HWACCM_VMX_TRAP_MASK                RT_BIT(X86_XCPT_DE) | RT_BIT(X86_XCPT_DB) | RT_BIT(X86_XCPT_NM) | RT_BIT(X86_XCPT_PF) | RT_BIT(X86_XCPT_UD) | RT_BIT(X86_XCPT_NP) | RT_BIT(X86_XCPT_SS) | RT_BIT(X86_XCPT_GP) | RT_BIT(X86_XCPT_MF)
 #define HWACCM_SVM_TRAP_MASK                HWACCM_VMX_TRAP_MASK
 #else
-#define HWACCM_VMX_TRAP_MASK                RT_BIT(X86_XCPT_NM) | RT_BIT(X86_XCPT_PF)
-#define HWACCM_SVM_TRAP_MASK                HWACCM_VMX_TRAP_MASK
+#define HWACCM_VMX_TRAP_MASK                RT_BIT(X86_XCPT_DB) | RT_BIT(X86_XCPT_NM) | RT_BIT(X86_XCPT_PF)
+#define HWACCM_SVM_TRAP_MASK                RT_BIT(X86_XCPT_NM) | RT_BIT(X86_XCPT_PF)
 #endif
 /** @} */
 
@@ -374,6 +376,17 @@
     /** Currenty shadow paging mode. */
     PGMMODE                 enmShadowMode;
 
+
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+    struct
+    {
+        /* Saved host debug registers. */
+        uint64_t                dr0, dr1, dr2, dr3, dr6, dr7;
+        bool                    fHostDR7Saved;
+        bool                    fHostDebugRegsSaved;
+    } savedhoststate;
+#endif
+
     STAMPROFILEADV          StatEntry;
     STAMPROFILEADV          StatExit;
     STAMPROFILEADV          StatInGC;
@@ -389,6 +402,7 @@
     STAMCOUNTER             StatExitGuestNP;
     STAMCOUNTER             StatExitGuestGP;
     STAMCOUNTER             StatExitGuestDE;
+    STAMCOUNTER             StatExitGuestDB;
     STAMCOUNTER             StatExitGuestMF;
     STAMCOUNTER             StatExitInvpg;
     STAMCOUNTER             StatExitInvd;
diff -urN VirtualBox-2.0.0/src/VBox/VMM/VMMAll/EMAll.cpp vbox/src/VBox/VMM/VMMAll/EMAll.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/VMMAll/EMAll.cpp	2008-09-08 10:06:32.000000000 +0200
+++ vbox/src/VBox/VMM/VMMAll/EMAll.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -2197,6 +2197,7 @@
 
     if (VBOX_SUCCESS(rc))
     {
+        /* @todo: we don't fail if illegal bits are set/cleared for e.g. dr7 */
         rc = CPUMSetGuestDRx(pVM, DestRegDrx, val);
         if (VBOX_SUCCESS(rc))
             return rc;
diff -urN VirtualBox-2.0.0/src/VBox/VMM/VMMAll/PGMAllBth.h vbox/src/VBox/VMM/VMMAll/PGMAllBth.h
--- VirtualBox-2.0.0/src/VBox/VMM/VMMAll/PGMAllBth.h	2008-09-08 10:06:33.000000000 +0200
+++ vbox/src/VBox/VMM/VMMAll/PGMAllBth.h	2008-09-08 10:07:21.000000000 +0200
@@ -2106,6 +2106,7 @@
 
             if (pPdeDst->n.u1Present)
             {
+#ifndef IN_RING0
                 /* Bail out here as pgmPoolGetPageByHCPhys will return NULL and we'll crash below.
                  * Our individual shadow handlers will provide more information and force a fatal exit.
                  */
@@ -2115,7 +2116,7 @@
                     STAM_PROFILE_STOP(&pVM->pgm.s.CTXMID(Stat,DirtyBitTracking), a);
                     return VINF_SUCCESS;
                 }
-
+#endif
                 /*
                  * Map shadow page table.
                  */
@@ -2185,7 +2186,7 @@
     STAM_COUNTER_INC(&pVM->pgm.s.StatGCDirtyTrackRealPF);
 #  endif
     STAM_PROFILE_STOP(&pVM->pgm.s.CTXMID(Stat, DirtyBitTracking), a);
-    LogFlow(("CheckPageFault: real page fault at %VGv (%d)\n", GCPtrPage, uPageFaultLevel));
+    Log(("CheckPageFault: real page fault at %VGv (%d)\n", GCPtrPage, uPageFaultLevel));
 
     if (
 #  if PGM_GST_TYPE == PGM_TYPE_AMD64
diff -urN VirtualBox-2.0.0/src/VBox/VMM/VMMR0/HWACCMR0.cpp vbox/src/VBox/VMM/VMMR0/HWACCMR0.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/VMMR0/HWACCMR0.cpp	2008-09-08 10:06:32.000000000 +0200
+++ vbox/src/VBox/VMM/VMMR0/HWACCMR0.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -742,6 +742,20 @@
     /* Always load the guest's FPU/XMM state on-demand. */
     CPUMDeactivateGuestFPUState(pVM);
 
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+    /*
+     * Check if host debug registers are armed. All context switches set DR7 back to 0x400.
+     */
+    uint64_t u64DR7 = ASMGetDR7();
+    if (u64DR7 & X86_DR7_ENABLED_MASK)
+    {
+        pVM->hwaccm.s.savedhoststate.dr7  = u64DR7;
+        pVM->hwaccm.s.savedhoststate.fHostDR7Saved = true;
+    }
+    else
+        pVM->hwaccm.s.savedhoststate.fHostDR7Saved = false;
+#endif
+
     /* Always reload the host context and the guest's CR0 register. (!!!!) */
     pVM->hwaccm.s.fContextUseFlags |= HWACCM_CHANGED_GUEST_CR0 | HWACCM_CHANGED_HOST_CONTEXT;
 
@@ -790,6 +804,26 @@
         pVM->hwaccm.s.fContextUseFlags |= HWACCM_CHANGED_GUEST_CR0;
     }
 
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+    /* Restore the host debug registers. First dr0-3, then dr6 and only then dr7! */
+    if (pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved)
+    {
+        ASMSetDR0(pVM->hwaccm.s.savedhoststate.dr0);
+        ASMSetDR1(pVM->hwaccm.s.savedhoststate.dr1);
+        ASMSetDR2(pVM->hwaccm.s.savedhoststate.dr2);
+        ASMSetDR3(pVM->hwaccm.s.savedhoststate.dr3);
+        ASMSetDR6(pVM->hwaccm.s.savedhoststate.dr6);
+        pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved = false;
+    }
+    if (pVM->hwaccm.s.savedhoststate.fHostDR7Saved)
+    {
+        ASMSetDR7(pVM->hwaccm.s.savedhoststate.dr7);
+        pVM->hwaccm.s.savedhoststate.fHostDR7Saved = false;
+    }
+#endif
+
+    /* Resync the debug register on the next entry. */
+    pVM->hwaccm.s.fContextUseFlags |= HWACCM_CHANGED_GUEST_DEBUG;
     return HWACCMR0Globals.pfnLeaveSession(pVM);
 }
 
diff -urN VirtualBox-2.0.0/src/VBox/VMM/VMMR0/HWSVMR0.cpp vbox/src/VBox/VMM/VMMR0/HWSVMR0.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/VMMR0/HWSVMR0.cpp	2008-09-08 10:06:32.000000000 +0200
+++ vbox/src/VBox/VMM/VMMR0/HWSVMR0.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -274,9 +274,9 @@
     else
         pVMCB->ctrl.u16InterceptWrCRx = RT_BIT(0) | RT_BIT(4) | RT_BIT(8);
 
-    /* Intercept all DRx reads and writes. */
-    pVMCB->ctrl.u16InterceptRdDRx = RT_BIT(0) | RT_BIT(1) | RT_BIT(2) | RT_BIT(3) | RT_BIT(4) | RT_BIT(5) | RT_BIT(6) | RT_BIT(7);
-    pVMCB->ctrl.u16InterceptWrDRx = RT_BIT(0) | RT_BIT(1) | RT_BIT(2) | RT_BIT(3) | RT_BIT(4) | RT_BIT(5) | RT_BIT(6) | RT_BIT(7);
+    /* Intercept all DRx reads and writes. (@todo not necessary to intercept all) */
+    pVMCB->ctrl.u16InterceptRdDRx = 0xFFFF;
+    pVMCB->ctrl.u16InterceptWrDRx = 0xFFFF;
 
     /* Currently we don't care about DRx reads or writes. DRx registers are trashed.
      * All breakpoints are automatically cleared when the VM exits.
@@ -684,16 +684,58 @@
     /* Debug registers. */
     if (pVM->hwaccm.s.fContextUseFlags & HWACCM_CHANGED_GUEST_DEBUG)
     {
-        /** @todo DR0-6 */
-        val  = pCtx->dr7;
-        val &= ~(RT_BIT(11) | RT_BIT(12) | RT_BIT(14) | RT_BIT(15));    /* must be zero */
-        val |= 0x400;                                       /* must be one */
-#ifdef VBOX_STRICT
-        val = 0x400;
+        pCtx->dr7 &= 0xffffffff;                                              /* upper 32 bits reserved */
+        pCtx->dr7 &= ~(RT_BIT(11) | RT_BIT(12) | RT_BIT(14) | RT_BIT(15));    /* must be zero */
+        pCtx->dr7 |= 0x400;                                                   /* must be one */
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+        pVMCB->guest.u64DR7 = pCtx->dr7;
+#else
+        pVMCB->guest.u64DR7 = 0x400;
 #endif
-        pVMCB->guest.u64DR7 = val;
-
         pVMCB->guest.u64DR6 = pCtx->dr6;
+
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+        /* Any guest breakpoints enabled? */
+        if (    (pCtx->dr7 & X86_DR7_ENABLED_MASK)
+            &&  !pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved)
+        {
+            /* Save the host debug register; a bit paranoid if the host has no active breakpoints set in dr7, but we
+             * do not want anything from the guest to leak into the host!
+             */
+            pVM->hwaccm.s.savedhoststate.dr0 = ASMGetDR0();
+            pVM->hwaccm.s.savedhoststate.dr1 = ASMGetDR1();
+            pVM->hwaccm.s.savedhoststate.dr2 = ASMGetDR2();
+            pVM->hwaccm.s.savedhoststate.dr3 = ASMGetDR3();
+            pVM->hwaccm.s.savedhoststate.dr6 = ASMGetDR6();
+            pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved = true;
+
+            /* Make sure DR7 is harmless or else we could trigger breakpoints when restoring dr0-3 (!) */
+            ASMSetDR7(0x400);
+        }
+
+        if (pCtx->dr7 & (X86_DR7_L0|X86_DR7_G0))
+        {
+            ASMSetDR0(pCtx->dr0);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+        if (pCtx->dr7 & (X86_DR7_L1|X86_DR7_G1))
+        {
+            ASMSetDR1(pCtx->dr1);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+        if (pCtx->dr7 & (X86_DR7_L2|X86_DR7_G2))
+        {
+            ASMSetDR2(pCtx->dr2);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+        if (pCtx->dr7 & (X86_DR7_L3|X86_DR7_G3))
+        {
+            ASMSetDR3(pCtx->dr3);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+
+        /* No need to sync DR6; all DR6 reads are intercepted. */
+#endif /* VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT */
     }
 
     /* EIP, ESP and EFLAGS */
@@ -933,7 +975,7 @@
         pVM->hwaccm.s.svm.fForceTLBFlush = true;
     }
     else
-        Assert(!pCpu->fFlushTLB);
+        Assert(!pCpu->fFlushTLB || pVM->hwaccm.s.svm.fAlwaysFlushTLB);
 
     pVM->hwaccm.s.svm.idLastCpu = pCpu->idCpu;
 
@@ -960,9 +1002,10 @@
         Assert(!pCpu->fFlushTLB || pVM->hwaccm.s.svm.fAlwaysFlushTLB);
 
         /* We never increase uCurrentASID in the fAlwaysFlushTLB (erratum 170) case. */
-        if (!pCpu->uCurrentASID)
+        if (!pCpu->uCurrentASID || !pVM->hwaccm.s.svm.uCurrentASID)
             pVM->hwaccm.s.svm.uCurrentASID = pCpu->uCurrentASID = 1;
 
+        Assert(!pVM->hwaccm.s.svm.fAlwaysFlushTLB || pVM->hwaccm.s.svm.fForceTLBFlush);
         pVMCB->ctrl.TLBCtrl.n.u1TLBFlush = pVM->hwaccm.s.svm.fForceTLBFlush;
     }
     AssertMsg(pVM->hwaccm.s.svm.cTLBFlushes == pCpu->cTLBFlushes, ("Flush count mismatch for cpu %d (%x vs %x)\n", pCpu->idCpu, pVM->hwaccm.s.svm.cTLBFlushes, pCpu->cTLBFlushes));
@@ -1166,6 +1209,16 @@
     pCtx->SysEnter.eip      = pVMCB->guest.u64SysEnterEIP;
     pCtx->SysEnter.esp      = pVMCB->guest.u64SysEnterESP;
 
+    /* Remaining guest CPU context: TR, IDTR, GDTR, LDTR; must sync everything otherwise we can get out of sync when jumping to ring 3. */
+    SVM_READ_SELREG(LDTR, ldtr);
+    SVM_READ_SELREG(TR, tr);
+
+    pCtx->gdtr.cbGdt        = pVMCB->guest.GDTR.u32Limit;
+    pCtx->gdtr.pGdt         = pVMCB->guest.GDTR.u64Base;
+
+    pCtx->idtr.cbIdt        = pVMCB->guest.IDTR.u32Limit;
+    pCtx->idtr.pIdt         = pVMCB->guest.IDTR.u64Base;
+
     /* Note: no reason to sync back the CRx and DRx registers. They can't be changed by the guest. */
     /* Note: only in the nested paging case can CR3 & CR4 be changed by the guest. */
     if (    pVM->hwaccm.s.fNestedPaging
@@ -1188,9 +1241,9 @@
 
     Log2(("exitCode = %x\n", exitCode));
 
-    /* Sync back the debug registers. */
-    /** @todo Implement debug registers correctly. */
+    /* Sync back DR6 as it could have been changed by hitting breakpoints. */
     pCtx->dr6 = pVMCB->guest.u64DR6;
+    /* DR7.GD can be cleared by debug exceptions, so sync it back as well. */
     pCtx->dr7 = pVMCB->guest.u64DR7;
 
     /* Check if an injected event was interrupted prematurely. */
@@ -1254,10 +1307,32 @@
         {
 #ifdef DEBUG
         case X86_XCPT_DB:
+        {
+#if 0 /* revisit */
             rc = DBGFR0Trap01Handler(pVM, CPUMCTX2CORE(pCtx), pVMCB->guest.u64DR6);
             Assert(rc != VINF_EM_RAW_GUEST_TRAP);
             break;
 #endif
+            /* @todo we don't really need to intercept this here. It's easy to sync back dr7 & dr6 after each world switch. */
+            /* Sync back DR6 and DR7 here. */
+            pCtx->dr6  = pVMCB->guest.u64DR6;
+            pCtx->dr7  = pVMCB->guest.u64DR7;
+
+            STAM_COUNTER_INC(&pVM->hwaccm.s.StatExitGuestDB);
+            Log(("Trap %x (debug) at %VGv\n", vector, pCtx->rip));
+
+            /* Reinject the exception. */
+            Event.au64[0]    = 0;
+            Event.n.u3Type   = SVM_EVENT_EXCEPTION; /* trap or fault */
+            Event.n.u1Valid  = 1;
+            Event.n.u8Vector = X86_XCPT_DB;
+
+            SVMR0InjectEvent(pVM, pVMCB, pCtx, &Event);
+
+            STAM_PROFILE_ADV_STOP(&pVM->hwaccm.s.StatExit, x);
+            goto ResumeExecution;
+        }
+#endif
 
         case X86_XCPT_NM:
         {
@@ -1403,7 +1478,7 @@
 #ifdef VBOX_STRICT
         case X86_XCPT_GP:   /* General protection failure exception.*/
         case X86_XCPT_UD:   /* Unknown opcode exception. */
-        case X86_XCPT_DE:   /* Debug exception. */
+        case X86_XCPT_DE:   /* Divide error. */
         case X86_XCPT_SS:   /* Stack segment exception. */
         case X86_XCPT_NP:   /* Segment not present exception. */
         {
@@ -1653,6 +1728,7 @@
         if (rc == VINF_SUCCESS)
         {
             /* EIP has been updated already. */
+            pVM->hwaccm.s.fContextUseFlags |= HWACCM_CHANGED_GUEST_DEBUG;
 
             /* Only resume if successful. */
             STAM_PROFILE_ADV_STOP(&pVM->hwaccm.s.StatExit, x);
@@ -1877,18 +1953,6 @@
     }
 
 end:
-    if (fGuestStateSynced)
-    {
-        /* Remaining guest CPU context: TR, IDTR, GDTR, LDTR. */
-        SVM_READ_SELREG(LDTR, ldtr);
-        SVM_READ_SELREG(TR, tr);
-
-        pCtx->gdtr.cbGdt        = pVMCB->guest.GDTR.u32Limit;
-        pCtx->gdtr.pGdt         = pVMCB->guest.GDTR.u64Base;
-
-        pCtx->idtr.cbIdt        = pVMCB->guest.IDTR.u32Limit;
-        pCtx->idtr.pIdt         = pVMCB->guest.IDTR.u64Base;
-    }
 
     /* Signal changes for the recompiler. */
     CPUMSetChangedFlags(pVM, CPUM_CHANGED_SYSENTER_MSR | CPUM_CHANGED_LDTR | CPUM_CHANGED_GDTR | CPUM_CHANGED_IDTR | CPUM_CHANGED_TR | CPUM_CHANGED_HIDDEN_SEL_REGS);
diff -urN VirtualBox-2.0.0/src/VBox/VMM/VMMR0/HWVMXR0.cpp vbox/src/VBox/VMM/VMMR0/HWVMXR0.cpp
--- VirtualBox-2.0.0/src/VBox/VMM/VMMR0/HWVMXR0.cpp	2008-09-08 10:06:32.000000000 +0200
+++ vbox/src/VBox/VMM/VMMR0/HWVMXR0.cpp	2008-09-08 10:07:21.000000000 +0200
@@ -964,12 +964,59 @@
     /* Debug registers. */
     if (pVM->hwaccm.s.fContextUseFlags & HWACCM_CHANGED_GUEST_DEBUG)
     {
-        val  = pCtx->dr7 & 0xffffffff;                                  /* upper 32 bits reserved */
-        val &= ~(RT_BIT(11) | RT_BIT(12) | RT_BIT(14) | RT_BIT(15));    /* must be zero */
-        val |= 0x400;                                                   /* must be one */
-        rc |= VMXWriteVMCS(VMX_VMCS_GUEST_DR7,              val);
+        pCtx->dr7 &= 0xffffffff;                                              /* upper 32 bits reserved */
+        pCtx->dr7 &= ~(RT_BIT(11) | RT_BIT(12) | RT_BIT(14) | RT_BIT(15));    /* must be zero */
+        pCtx->dr7 |= 0x400;                                                   /* must be one */
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+        rc |= VMXWriteVMCS(VMX_VMCS_GUEST_DR7,  pCtx->dr7);
+#else
+        rc |= VMXWriteVMCS(VMX_VMCS_GUEST_DR7,  0x400);
+#endif
         AssertRC(rc);
 
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+        /* Any guest breakpoints enabled? */
+        if (    (pCtx->dr7 & X86_DR7_ENABLED_MASK)
+            &&  !pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved)
+        {
+            /* Save the host debug register; a bit paranoid if the host has no active breakpoints set in dr7, but we
+             * do not want anything from the guest to leak into the host!
+             */
+            pVM->hwaccm.s.savedhoststate.dr0 = ASMGetDR0();
+            pVM->hwaccm.s.savedhoststate.dr1 = ASMGetDR1();
+            pVM->hwaccm.s.savedhoststate.dr2 = ASMGetDR2();
+            pVM->hwaccm.s.savedhoststate.dr3 = ASMGetDR3();
+            pVM->hwaccm.s.savedhoststate.dr6 = ASMGetDR6();
+            pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved = true;
+
+            /* Make sure DR7 is harmless or else we could trigger breakpoints when restoring dr0-3 (!) */
+            ASMSetDR7(0x400);
+        }
+
+        if (pCtx->dr7 & (X86_DR7_L0|X86_DR7_G0))
+        {
+            ASMSetDR0(pCtx->dr0);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+        if (pCtx->dr7 & (X86_DR7_L1|X86_DR7_G1))
+        {
+            ASMSetDR1(pCtx->dr1);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+        if (pCtx->dr7 & (X86_DR7_L2|X86_DR7_G2))
+        {
+            ASMSetDR2(pCtx->dr2);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+        if (pCtx->dr7 & (X86_DR7_L3|X86_DR7_G3))
+        {
+            ASMSetDR3(pCtx->dr3);
+            Assert(pVM->hwaccm.s.savedhoststate.fHostDebugRegsSaved);
+        }
+
+        /* No need to sync DR6; all DR6 reads are intercepted. */
+#endif /* VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT */
+
         /* IA32_DEBUGCTL MSR. */
         rc  = VMXWriteVMCS(VMX_VMCS_GUEST_DEBUGCTL_FULL,    0);
         rc |= VMXWriteVMCS(VMX_VMCS_GUEST_DEBUGCTL_HIGH,    0);
@@ -1143,19 +1190,6 @@
         Log(("Invalid VMX_VMCS_CTRL_EXIT_CONTROLS: one\n"));
 #endif
 
-#if 0
-    /*
-     * Check if debug registers are armed.
-     */
-    uint32_t u32DR7 = ASMGetDR7();
-    if (u32DR7 & X86_DR7_ENABLED_MASK)
-    {
-        pVM->cpum.s.fUseFlags |= CPUM_USE_DEBUG_REGS_HOST;
-    }
-    else
-        pVM->cpum.s.fUseFlags &= ~CPUM_USE_DEBUG_REGS_HOST;
-#endif
-
     /* We can jump to this point to resume execution after determining that a VM-exit is innocent.
      */
 ResumeExecution:
@@ -1520,9 +1554,6 @@
 
     CPUMSetGuestCR2(pVM, ASMGetCR2());
 
-    VMXReadVMCS(VMX_VMCS_GUEST_DR7,              &val);
-    CPUMSetGuestDR7(pVM, val);
-
     /* Guest CPU context: ES, CS, SS, DS, FS, GS. */
     VMX_READ_SELREG(ES, es);
     VMX_READ_SELREG(SS, ss);
@@ -1541,6 +1572,20 @@
     VMXReadVMCS(VMX_VMCS_GUEST_SYSENTER_ESP,     &val);
     pCtx->SysEnter.esp      = val;
 
+    /* Misc. registers; must sync everything otherwise we can get out of sync when jumping to ring 3. */
+    VMX_READ_SELREG(LDTR, ldtr);
+    VMX_READ_SELREG(TR, tr);
+
+    VMXReadVMCS(VMX_VMCS_GUEST_GDTR_LIMIT,       &val);
+    pCtx->gdtr.cbGdt        = val;
+    VMXReadVMCS(VMX_VMCS_GUEST_GDTR_BASE,        &val);
+    pCtx->gdtr.pGdt         = val;
+
+    VMXReadVMCS(VMX_VMCS_GUEST_IDTR_LIMIT,       &val);
+    pCtx->idtr.cbIdt        = val;
+    VMXReadVMCS(VMX_VMCS_GUEST_IDTR_BASE,        &val);
+    pCtx->idtr.pIdt         = val;
+
     /** @note NOW IT'S SAFE FOR LOGGING! */
     Log2(("Raw exit reason %08x\n", exitReason));
 
@@ -1714,10 +1759,49 @@
                 goto ResumeExecution;
             }
 
+            case X86_XCPT_DB:   /* Debug exception. */
+            {
+                /* DR6, DR7.GD and IA32_DEBUGCTL.LBR are not updated yet. 
+                 *
+                 * Exit qualification bits:
+                 *  3:0     B0-B3 which breakpoint condition was met
+                 * 12:4     Reserved (0)
+                 * 13       BD - debug register access detected
+                 * 14       BS - single step execution or branch taken
+                 * 63:15    Reserved (0)
+                 */
+
+#ifdef VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT
+                /* Update DR6 here. */
+                pCtx->dr6  = X86_DR6_INIT_VAL;
+                pCtx->dr6 |= (exitQualification & (X86_DR6_B0|X86_DR6_B1|X86_DR6_B2|X86_DR6_B3|X86_DR6_BD|X86_DR6_BS));
+
+                /* X86_DR7_GD will be cleared if drx accesses should be trapped inside the guest. */
+                pCtx->dr7 &= ~X86_DR7_GD;
+
+                /* Paranoia. */
+                pCtx->dr7 &= 0xffffffff;                                              /* upper 32 bits reserved */
+                pCtx->dr7 &= ~(RT_BIT(11) | RT_BIT(12) | RT_BIT(14) | RT_BIT(15));    /* must be zero */
+                pCtx->dr7 |= 0x400;                                                   /* must be one */
+
+                /* Resync DR7 */
+                rc = VMXWriteVMCS(VMX_VMCS_GUEST_DR7, pCtx->dr7);
+                AssertRC(rc);
+#endif /* VBOX_WITH_HWACCM_DEBUG_REGISTER_SUPPORT */
+
+                STAM_COUNTER_INC(&pVM->hwaccm.s.StatExitGuestDB);
+                Log(("Trap %x (debug) at %VGv exit qualification %VX64\n", vector, pCtx->rip, exitQualification));
+                rc = VMXR0InjectEvent(pVM, pCtx, VMX_VMCS_CTRL_ENTRY_IRQ_INFO_FROM_EXIT_INT_INFO(intInfo), cbInstr, errCode);
+                AssertRC(rc);
+
+                STAM_PROFILE_ADV_STOP(&pVM->hwaccm.s.StatExit, x);
+                goto ResumeExecution;
+            }
+
 #ifdef VBOX_STRICT
+            case X86_XCPT_DE:   /* Divide error. */
             case X86_XCPT_GP:   /* General protection failure exception.*/
             case X86_XCPT_UD:   /* Unknown opcode exception. */
-            case X86_XCPT_DE:   /* Debug exception. */
             case X86_XCPT_SS:   /* Stack segment exception. */
             case X86_XCPT_NP:   /* Segment not present exception. */
             {
@@ -1750,14 +1834,14 @@
 #endif
             default:
                 AssertMsgFailed(("Unexpected vm-exit caused by exception %x\n", vector));
-                rc = VERR_EM_INTERNAL_ERROR;
+                rc = VERR_VMX_UNEXPECTED_EXCEPTION;
                 break;
             } /* switch (vector) */
 
             break;
 
         default:
-            rc = VERR_EM_INTERNAL_ERROR;
+            rc = VERR_VMX_UNEXPECTED_INTERRUPTION_EXIT_CODE;
             AssertFailed();
             break;
         }
@@ -1948,6 +2032,7 @@
             rc = EMInterpretDRxWrite(pVM, CPUMCTX2CORE(pCtx),
                                      VMX_EXIT_QUALIFICATION_DRX_REGISTER(exitQualification),
                                      VMX_EXIT_QUALIFICATION_DRX_GENREG(exitQualification));
+            pVM->hwaccm.s.fContextUseFlags |= HWACCM_CHANGED_GUEST_DEBUG;
             Log2(("DR7=%08x\n", pCtx->dr7));
         }
         else
@@ -2206,35 +2291,19 @@
         VMXReadVMCS(VMX_VMCS_GUEST_IDTR_BASE, &val);
         Log(("VMX_VMCS_GUEST_IDTR_BASE    %VGv\n", val));
 #endif /* VBOX_STRICT */
-        rc = VERR_EM_INTERNAL_ERROR;
+        rc = VERR_VMX_INVALID_GUEST_STATE;
         break;
     }
 
     case VMX_EXIT_ERR_MSR_LOAD:         /* 34 VM-entry failure due to MSR loading. */
     case VMX_EXIT_ERR_MACHINE_CHECK:    /* 41 VM-entry failure due to machine-check. */
     default:
-        rc = VERR_EM_INTERNAL_ERROR;
+        rc = VERR_VMX_UNEXPECTED_EXIT_CODE;
         AssertMsgFailed(("Unexpected exit code %d\n", exitReason));                 /* Can't happen. */
         break;
 
     }
 end:
-    if (fGuestStateSynced)
-    {
-        /* Remaining guest CPU context: TR, IDTR, GDTR, LDTR. */
-        VMX_READ_SELREG(LDTR, ldtr);
-        VMX_READ_SELREG(TR, tr);
-
-        VMXReadVMCS(VMX_VMCS_GUEST_GDTR_LIMIT,       &val);
-        pCtx->gdtr.cbGdt        = val;
-        VMXReadVMCS(VMX_VMCS_GUEST_GDTR_BASE,        &val);
-        pCtx->gdtr.pGdt         = val;
-
-        VMXReadVMCS(VMX_VMCS_GUEST_IDTR_LIMIT,       &val);
-        pCtx->idtr.cbIdt        = val;
-        VMXReadVMCS(VMX_VMCS_GUEST_IDTR_BASE,        &val);
-        pCtx->idtr.pIdt         = val;
-    }
 
     /* Signal changes for the recompiler. */
     CPUMSetChangedFlags(pVM, CPUM_CHANGED_SYSENTER_MSR | CPUM_CHANGED_LDTR | CPUM_CHANGED_GDTR | CPUM_CHANGED_IDTR | CPUM_CHANGED_TR | CPUM_CHANGED_HIDDEN_SEL_REGS);
